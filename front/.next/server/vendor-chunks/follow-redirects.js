/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/follow-redirects";
exports.ids = ["vendor-chunks/follow-redirects"];
exports.modules = {

/***/ "(ssr)/./node_modules/follow-redirects/debug.js":
/*!************************************************!*\
  !*** ./node_modules/follow-redirects/debug.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var debug;\r\n\r\nmodule.exports = function () {\r\n  if (!debug) {\r\n    try {\r\n      /* eslint global-require: off */\r\n      debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")(\"follow-redirects\");\r\n    }\r\n    catch (error) { /* */ }\r\n    if (typeof debug !== \"function\") {\r\n      debug = function () { /* */ };\r\n    }\r\n  }\r\n  debug.apply(null, arguments);\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZm9sbG93LXJlZGlyZWN0cy9kZWJ1Zy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsc0RBQU87QUFDN0I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXN0X2NvdXJzZS8uL25vZGVfbW9kdWxlcy9mb2xsb3ctcmVkaXJlY3RzL2RlYnVnLmpzP2U4N2QiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGRlYnVnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKCFkZWJ1Zykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLyogZXNsaW50IGdsb2JhbC1yZXF1aXJlOiBvZmYgKi9cclxuICAgICAgZGVidWcgPSByZXF1aXJlKFwiZGVidWdcIikoXCJmb2xsb3ctcmVkaXJlY3RzXCIpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IC8qICovIH1cclxuICAgIGlmICh0eXBlb2YgZGVidWcgIT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHsgLyogKi8gfTtcclxuICAgIH1cclxuICB9XHJcbiAgZGVidWcuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/follow-redirects/debug.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/follow-redirects/index.js":
/*!************************************************!*\
  !*** ./node_modules/follow-redirects/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var url = __webpack_require__(/*! url */ \"url\");\r\nvar URL = url.URL;\r\nvar http = __webpack_require__(/*! http */ \"http\");\r\nvar https = __webpack_require__(/*! https */ \"https\");\r\nvar Writable = (__webpack_require__(/*! stream */ \"stream\").Writable);\r\nvar assert = __webpack_require__(/*! assert */ \"assert\");\r\nvar debug = __webpack_require__(/*! ./debug */ \"(ssr)/./node_modules/follow-redirects/debug.js\");\r\n\r\n// Whether to use the native URL object or the legacy url module\r\nvar useNativeURL = false;\r\ntry {\r\n  assert(new URL());\r\n}\r\ncatch (error) {\r\n  useNativeURL = error.code === \"ERR_INVALID_URL\";\r\n}\r\n\r\n// URL fields to preserve in copy operations\r\nvar preservedUrlFields = [\r\n  \"auth\",\r\n  \"host\",\r\n  \"hostname\",\r\n  \"href\",\r\n  \"path\",\r\n  \"pathname\",\r\n  \"port\",\r\n  \"protocol\",\r\n  \"query\",\r\n  \"search\",\r\n  \"hash\",\r\n];\r\n\r\n// Create handlers that pass events from native requests\r\nvar events = [\"abort\", \"aborted\", \"connect\", \"error\", \"socket\", \"timeout\"];\r\nvar eventHandlers = Object.create(null);\r\nevents.forEach(function (event) {\r\n  eventHandlers[event] = function (arg1, arg2, arg3) {\r\n    this._redirectable.emit(event, arg1, arg2, arg3);\r\n  };\r\n});\r\n\r\n// Error types with codes\r\nvar InvalidUrlError = createErrorType(\r\n  \"ERR_INVALID_URL\",\r\n  \"Invalid URL\",\r\n  TypeError\r\n);\r\nvar RedirectionError = createErrorType(\r\n  \"ERR_FR_REDIRECTION_FAILURE\",\r\n  \"Redirected request failed\"\r\n);\r\nvar TooManyRedirectsError = createErrorType(\r\n  \"ERR_FR_TOO_MANY_REDIRECTS\",\r\n  \"Maximum number of redirects exceeded\",\r\n  RedirectionError\r\n);\r\nvar MaxBodyLengthExceededError = createErrorType(\r\n  \"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\",\r\n  \"Request body larger than maxBodyLength limit\"\r\n);\r\nvar WriteAfterEndError = createErrorType(\r\n  \"ERR_STREAM_WRITE_AFTER_END\",\r\n  \"write after end\"\r\n);\r\n\r\n// istanbul ignore next\r\nvar destroy = Writable.prototype.destroy || noop;\r\n\r\n// An HTTP(S) request that can be redirected\r\nfunction RedirectableRequest(options, responseCallback) {\r\n  // Initialize the request\r\n  Writable.call(this);\r\n  this._sanitizeOptions(options);\r\n  this._options = options;\r\n  this._ended = false;\r\n  this._ending = false;\r\n  this._redirectCount = 0;\r\n  this._redirects = [];\r\n  this._requestBodyLength = 0;\r\n  this._requestBodyBuffers = [];\r\n\r\n  // Attach a callback if passed\r\n  if (responseCallback) {\r\n    this.on(\"response\", responseCallback);\r\n  }\r\n\r\n  // React to responses of native requests\r\n  var self = this;\r\n  this._onNativeResponse = function (response) {\r\n    try {\r\n      self._processResponse(response);\r\n    }\r\n    catch (cause) {\r\n      self.emit(\"error\", cause instanceof RedirectionError ?\r\n        cause : new RedirectionError({ cause: cause }));\r\n    }\r\n  };\r\n\r\n  // Perform the first request\r\n  this._performRequest();\r\n}\r\nRedirectableRequest.prototype = Object.create(Writable.prototype);\r\n\r\nRedirectableRequest.prototype.abort = function () {\r\n  destroyRequest(this._currentRequest);\r\n  this._currentRequest.abort();\r\n  this.emit(\"abort\");\r\n};\r\n\r\nRedirectableRequest.prototype.destroy = function (error) {\r\n  destroyRequest(this._currentRequest, error);\r\n  destroy.call(this, error);\r\n  return this;\r\n};\r\n\r\n// Writes buffered data to the current native request\r\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\r\n  // Writing is not allowed if end has been called\r\n  if (this._ending) {\r\n    throw new WriteAfterEndError();\r\n  }\r\n\r\n  // Validate input and shift parameters if necessary\r\n  if (!isString(data) && !isBuffer(data)) {\r\n    throw new TypeError(\"data should be a string, Buffer or Uint8Array\");\r\n  }\r\n  if (isFunction(encoding)) {\r\n    callback = encoding;\r\n    encoding = null;\r\n  }\r\n\r\n  // Ignore empty buffers, since writing them doesn't invoke the callback\r\n  // https://github.com/nodejs/node/issues/22066\r\n  if (data.length === 0) {\r\n    if (callback) {\r\n      callback();\r\n    }\r\n    return;\r\n  }\r\n  // Only write when we don't exceed the maximum body length\r\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\r\n    this._requestBodyLength += data.length;\r\n    this._requestBodyBuffers.push({ data: data, encoding: encoding });\r\n    this._currentRequest.write(data, encoding, callback);\r\n  }\r\n  // Error when we exceed the maximum body length\r\n  else {\r\n    this.emit(\"error\", new MaxBodyLengthExceededError());\r\n    this.abort();\r\n  }\r\n};\r\n\r\n// Ends the current native request\r\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\r\n  // Shift parameters if necessary\r\n  if (isFunction(data)) {\r\n    callback = data;\r\n    data = encoding = null;\r\n  }\r\n  else if (isFunction(encoding)) {\r\n    callback = encoding;\r\n    encoding = null;\r\n  }\r\n\r\n  // Write data if needed and end\r\n  if (!data) {\r\n    this._ended = this._ending = true;\r\n    this._currentRequest.end(null, null, callback);\r\n  }\r\n  else {\r\n    var self = this;\r\n    var currentRequest = this._currentRequest;\r\n    this.write(data, encoding, function () {\r\n      self._ended = true;\r\n      currentRequest.end(null, null, callback);\r\n    });\r\n    this._ending = true;\r\n  }\r\n};\r\n\r\n// Sets a header value on the current native request\r\nRedirectableRequest.prototype.setHeader = function (name, value) {\r\n  this._options.headers[name] = value;\r\n  this._currentRequest.setHeader(name, value);\r\n};\r\n\r\n// Clears a header value on the current native request\r\nRedirectableRequest.prototype.removeHeader = function (name) {\r\n  delete this._options.headers[name];\r\n  this._currentRequest.removeHeader(name);\r\n};\r\n\r\n// Global timeout for all underlying requests\r\nRedirectableRequest.prototype.setTimeout = function (msecs, callback) {\r\n  var self = this;\r\n\r\n  // Destroys the socket on timeout\r\n  function destroyOnTimeout(socket) {\r\n    socket.setTimeout(msecs);\r\n    socket.removeListener(\"timeout\", socket.destroy);\r\n    socket.addListener(\"timeout\", socket.destroy);\r\n  }\r\n\r\n  // Sets up a timer to trigger a timeout event\r\n  function startTimer(socket) {\r\n    if (self._timeout) {\r\n      clearTimeout(self._timeout);\r\n    }\r\n    self._timeout = setTimeout(function () {\r\n      self.emit(\"timeout\");\r\n      clearTimer();\r\n    }, msecs);\r\n    destroyOnTimeout(socket);\r\n  }\r\n\r\n  // Stops a timeout from triggering\r\n  function clearTimer() {\r\n    // Clear the timeout\r\n    if (self._timeout) {\r\n      clearTimeout(self._timeout);\r\n      self._timeout = null;\r\n    }\r\n\r\n    // Clean up all attached listeners\r\n    self.removeListener(\"abort\", clearTimer);\r\n    self.removeListener(\"error\", clearTimer);\r\n    self.removeListener(\"response\", clearTimer);\r\n    self.removeListener(\"close\", clearTimer);\r\n    if (callback) {\r\n      self.removeListener(\"timeout\", callback);\r\n    }\r\n    if (!self.socket) {\r\n      self._currentRequest.removeListener(\"socket\", startTimer);\r\n    }\r\n  }\r\n\r\n  // Attach callback if passed\r\n  if (callback) {\r\n    this.on(\"timeout\", callback);\r\n  }\r\n\r\n  // Start the timer if or when the socket is opened\r\n  if (this.socket) {\r\n    startTimer(this.socket);\r\n  }\r\n  else {\r\n    this._currentRequest.once(\"socket\", startTimer);\r\n  }\r\n\r\n  // Clean up on events\r\n  this.on(\"socket\", destroyOnTimeout);\r\n  this.on(\"abort\", clearTimer);\r\n  this.on(\"error\", clearTimer);\r\n  this.on(\"response\", clearTimer);\r\n  this.on(\"close\", clearTimer);\r\n\r\n  return this;\r\n};\r\n\r\n// Proxy all other public ClientRequest methods\r\n[\r\n  \"flushHeaders\", \"getHeader\",\r\n  \"setNoDelay\", \"setSocketKeepAlive\",\r\n].forEach(function (method) {\r\n  RedirectableRequest.prototype[method] = function (a, b) {\r\n    return this._currentRequest[method](a, b);\r\n  };\r\n});\r\n\r\n// Proxy all public ClientRequest properties\r\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\r\n  Object.defineProperty(RedirectableRequest.prototype, property, {\r\n    get: function () { return this._currentRequest[property]; },\r\n  });\r\n});\r\n\r\nRedirectableRequest.prototype._sanitizeOptions = function (options) {\r\n  // Ensure headers are always present\r\n  if (!options.headers) {\r\n    options.headers = {};\r\n  }\r\n\r\n  // Since http.request treats host as an alias of hostname,\r\n  // but the url module interprets host as hostname plus port,\r\n  // eliminate the host property to avoid confusion.\r\n  if (options.host) {\r\n    // Use hostname if set, because it has precedence\r\n    if (!options.hostname) {\r\n      options.hostname = options.host;\r\n    }\r\n    delete options.host;\r\n  }\r\n\r\n  // Complete the URL object when necessary\r\n  if (!options.pathname && options.path) {\r\n    var searchPos = options.path.indexOf(\"?\");\r\n    if (searchPos < 0) {\r\n      options.pathname = options.path;\r\n    }\r\n    else {\r\n      options.pathname = options.path.substring(0, searchPos);\r\n      options.search = options.path.substring(searchPos);\r\n    }\r\n  }\r\n};\r\n\r\n\r\n// Executes the next native request (initial or redirect)\r\nRedirectableRequest.prototype._performRequest = function () {\r\n  // Load the native protocol\r\n  var protocol = this._options.protocol;\r\n  var nativeProtocol = this._options.nativeProtocols[protocol];\r\n  if (!nativeProtocol) {\r\n    throw new TypeError(\"Unsupported protocol \" + protocol);\r\n  }\r\n\r\n  // If specified, use the agent corresponding to the protocol\r\n  // (HTTP and HTTPS use different types of agents)\r\n  if (this._options.agents) {\r\n    var scheme = protocol.slice(0, -1);\r\n    this._options.agent = this._options.agents[scheme];\r\n  }\r\n\r\n  // Create the native request and set up its event handlers\r\n  var request = this._currentRequest =\r\n        nativeProtocol.request(this._options, this._onNativeResponse);\r\n  request._redirectable = this;\r\n  for (var event of events) {\r\n    request.on(event, eventHandlers[event]);\r\n  }\r\n\r\n  // RFC7230§5.3.1: When making a request directly to an origin server, […]\r\n  // a client MUST send only the absolute path […] as the request-target.\r\n  this._currentUrl = /^\\//.test(this._options.path) ?\r\n    url.format(this._options) :\r\n    // When making a request to a proxy, […]\r\n    // a client MUST send the target URI in absolute-form […].\r\n    this._options.path;\r\n\r\n  // End a redirected request\r\n  // (The first request must be ended explicitly with RedirectableRequest#end)\r\n  if (this._isRedirect) {\r\n    // Write the request entity and end\r\n    var i = 0;\r\n    var self = this;\r\n    var buffers = this._requestBodyBuffers;\r\n    (function writeNext(error) {\r\n      // Only write if this request has not been redirected yet\r\n      /* istanbul ignore else */\r\n      if (request === self._currentRequest) {\r\n        // Report any write errors\r\n        /* istanbul ignore if */\r\n        if (error) {\r\n          self.emit(\"error\", error);\r\n        }\r\n        // Write the next buffer if there are still left\r\n        else if (i < buffers.length) {\r\n          var buffer = buffers[i++];\r\n          /* istanbul ignore else */\r\n          if (!request.finished) {\r\n            request.write(buffer.data, buffer.encoding, writeNext);\r\n          }\r\n        }\r\n        // End the request if `end` has been called on us\r\n        else if (self._ended) {\r\n          request.end();\r\n        }\r\n      }\r\n    }());\r\n  }\r\n};\r\n\r\n// Processes a response from the current native request\r\nRedirectableRequest.prototype._processResponse = function (response) {\r\n  // Store the redirected response\r\n  var statusCode = response.statusCode;\r\n  if (this._options.trackRedirects) {\r\n    this._redirects.push({\r\n      url: this._currentUrl,\r\n      headers: response.headers,\r\n      statusCode: statusCode,\r\n    });\r\n  }\r\n\r\n  // RFC7231§6.4: The 3xx (Redirection) class of status code indicates\r\n  // that further action needs to be taken by the user agent in order to\r\n  // fulfill the request. If a Location header field is provided,\r\n  // the user agent MAY automatically redirect its request to the URI\r\n  // referenced by the Location field value,\r\n  // even if the specific status code is not understood.\r\n\r\n  // If the response is not a redirect; return it as-is\r\n  var location = response.headers.location;\r\n  if (!location || this._options.followRedirects === false ||\r\n      statusCode < 300 || statusCode >= 400) {\r\n    response.responseUrl = this._currentUrl;\r\n    response.redirects = this._redirects;\r\n    this.emit(\"response\", response);\r\n\r\n    // Clean up\r\n    this._requestBodyBuffers = [];\r\n    return;\r\n  }\r\n\r\n  // The response is a redirect, so abort the current request\r\n  destroyRequest(this._currentRequest);\r\n  // Discard the remainder of the response to avoid waiting for data\r\n  response.destroy();\r\n\r\n  // RFC7231§6.4: A client SHOULD detect and intervene\r\n  // in cyclical redirections (i.e., \"infinite\" redirection loops).\r\n  if (++this._redirectCount > this._options.maxRedirects) {\r\n    throw new TooManyRedirectsError();\r\n  }\r\n\r\n  // Store the request headers if applicable\r\n  var requestHeaders;\r\n  var beforeRedirect = this._options.beforeRedirect;\r\n  if (beforeRedirect) {\r\n    requestHeaders = Object.assign({\r\n      // The Host header was set by nativeProtocol.request\r\n      Host: response.req.getHeader(\"host\"),\r\n    }, this._options.headers);\r\n  }\r\n\r\n  // RFC7231§6.4: Automatic redirection needs to done with\r\n  // care for methods not known to be safe, […]\r\n  // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change\r\n  // the request method from POST to GET for the subsequent request.\r\n  var method = this._options.method;\r\n  if ((statusCode === 301 || statusCode === 302) && this._options.method === \"POST\" ||\r\n      // RFC7231§6.4.4: The 303 (See Other) status code indicates that\r\n      // the server is redirecting the user agent to a different resource […]\r\n      // A user agent can perform a retrieval request targeting that URI\r\n      // (a GET or HEAD request if using HTTP) […]\r\n      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {\r\n    this._options.method = \"GET\";\r\n    // Drop a possible entity and headers related to it\r\n    this._requestBodyBuffers = [];\r\n    removeMatchingHeaders(/^content-/i, this._options.headers);\r\n  }\r\n\r\n  // Drop the Host header, as the redirect might lead to a different host\r\n  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);\r\n\r\n  // If the redirect is relative, carry over the host of the last request\r\n  var currentUrlParts = parseUrl(this._currentUrl);\r\n  var currentHost = currentHostHeader || currentUrlParts.host;\r\n  var currentUrl = /^\\w+:/.test(location) ? this._currentUrl :\r\n    url.format(Object.assign(currentUrlParts, { host: currentHost }));\r\n\r\n  // Create the redirected request\r\n  var redirectUrl = resolveUrl(location, currentUrl);\r\n  debug(\"redirecting to\", redirectUrl.href);\r\n  this._isRedirect = true;\r\n  spreadUrlObject(redirectUrl, this._options);\r\n\r\n  // Drop confidential headers when redirecting to a less secure protocol\r\n  // or to a different domain that is not a superdomain\r\n  if (redirectUrl.protocol !== currentUrlParts.protocol &&\r\n     redirectUrl.protocol !== \"https:\" ||\r\n     redirectUrl.host !== currentHost &&\r\n     !isSubdomain(redirectUrl.host, currentHost)) {\r\n    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);\r\n  }\r\n\r\n  // Evaluate the beforeRedirect callback\r\n  if (isFunction(beforeRedirect)) {\r\n    var responseDetails = {\r\n      headers: response.headers,\r\n      statusCode: statusCode,\r\n    };\r\n    var requestDetails = {\r\n      url: currentUrl,\r\n      method: method,\r\n      headers: requestHeaders,\r\n    };\r\n    beforeRedirect(this._options, responseDetails, requestDetails);\r\n    this._sanitizeOptions(this._options);\r\n  }\r\n\r\n  // Perform the redirected request\r\n  this._performRequest();\r\n};\r\n\r\n// Wraps the key/value object of protocols with redirect functionality\r\nfunction wrap(protocols) {\r\n  // Default settings\r\n  var exports = {\r\n    maxRedirects: 21,\r\n    maxBodyLength: 10 * 1024 * 1024,\r\n  };\r\n\r\n  // Wrap each protocol\r\n  var nativeProtocols = {};\r\n  Object.keys(protocols).forEach(function (scheme) {\r\n    var protocol = scheme + \":\";\r\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\r\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\r\n\r\n    // Executes a request, following redirects\r\n    function request(input, options, callback) {\r\n      // Parse parameters, ensuring that input is an object\r\n      if (isURL(input)) {\r\n        input = spreadUrlObject(input);\r\n      }\r\n      else if (isString(input)) {\r\n        input = spreadUrlObject(parseUrl(input));\r\n      }\r\n      else {\r\n        callback = options;\r\n        options = validateUrl(input);\r\n        input = { protocol: protocol };\r\n      }\r\n      if (isFunction(options)) {\r\n        callback = options;\r\n        options = null;\r\n      }\r\n\r\n      // Set defaults\r\n      options = Object.assign({\r\n        maxRedirects: exports.maxRedirects,\r\n        maxBodyLength: exports.maxBodyLength,\r\n      }, input, options);\r\n      options.nativeProtocols = nativeProtocols;\r\n      if (!isString(options.host) && !isString(options.hostname)) {\r\n        options.hostname = \"::1\";\r\n      }\r\n\r\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\r\n      debug(\"options\", options);\r\n      return new RedirectableRequest(options, callback);\r\n    }\r\n\r\n    // Executes a GET request, following redirects\r\n    function get(input, options, callback) {\r\n      var wrappedRequest = wrappedProtocol.request(input, options, callback);\r\n      wrappedRequest.end();\r\n      return wrappedRequest;\r\n    }\r\n\r\n    // Expose the properties on the wrapped protocol\r\n    Object.defineProperties(wrappedProtocol, {\r\n      request: { value: request, configurable: true, enumerable: true, writable: true },\r\n      get: { value: get, configurable: true, enumerable: true, writable: true },\r\n    });\r\n  });\r\n  return exports;\r\n}\r\n\r\nfunction noop() { /* empty */ }\r\n\r\nfunction parseUrl(input) {\r\n  var parsed;\r\n  /* istanbul ignore else */\r\n  if (useNativeURL) {\r\n    parsed = new URL(input);\r\n  }\r\n  else {\r\n    // Ensure the URL is valid and absolute\r\n    parsed = validateUrl(url.parse(input));\r\n    if (!isString(parsed.protocol)) {\r\n      throw new InvalidUrlError({ input });\r\n    }\r\n  }\r\n  return parsed;\r\n}\r\n\r\nfunction resolveUrl(relative, base) {\r\n  /* istanbul ignore next */\r\n  return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));\r\n}\r\n\r\nfunction validateUrl(input) {\r\n  if (/^\\[/.test(input.hostname) && !/^\\[[:0-9a-f]+\\]$/i.test(input.hostname)) {\r\n    throw new InvalidUrlError({ input: input.href || input });\r\n  }\r\n  if (/^\\[/.test(input.host) && !/^\\[[:0-9a-f]+\\](:\\d+)?$/i.test(input.host)) {\r\n    throw new InvalidUrlError({ input: input.href || input });\r\n  }\r\n  return input;\r\n}\r\n\r\nfunction spreadUrlObject(urlObject, target) {\r\n  var spread = target || {};\r\n  for (var key of preservedUrlFields) {\r\n    spread[key] = urlObject[key];\r\n  }\r\n\r\n  // Fix IPv6 hostname\r\n  if (spread.hostname.startsWith(\"[\")) {\r\n    spread.hostname = spread.hostname.slice(1, -1);\r\n  }\r\n  // Ensure port is a number\r\n  if (spread.port !== \"\") {\r\n    spread.port = Number(spread.port);\r\n  }\r\n  // Concatenate path\r\n  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;\r\n\r\n  return spread;\r\n}\r\n\r\nfunction removeMatchingHeaders(regex, headers) {\r\n  var lastValue;\r\n  for (var header in headers) {\r\n    if (regex.test(header)) {\r\n      lastValue = headers[header];\r\n      delete headers[header];\r\n    }\r\n  }\r\n  return (lastValue === null || typeof lastValue === \"undefined\") ?\r\n    undefined : String(lastValue).trim();\r\n}\r\n\r\nfunction createErrorType(code, message, baseClass) {\r\n  // Create constructor\r\n  function CustomError(properties) {\r\n    Error.captureStackTrace(this, this.constructor);\r\n    Object.assign(this, properties || {});\r\n    this.code = code;\r\n    this.message = this.cause ? message + \": \" + this.cause.message : message;\r\n  }\r\n\r\n  // Attach constructor and set default properties\r\n  CustomError.prototype = new (baseClass || Error)();\r\n  Object.defineProperties(CustomError.prototype, {\r\n    constructor: {\r\n      value: CustomError,\r\n      enumerable: false,\r\n    },\r\n    name: {\r\n      value: \"Error [\" + code + \"]\",\r\n      enumerable: false,\r\n    },\r\n  });\r\n  return CustomError;\r\n}\r\n\r\nfunction destroyRequest(request, error) {\r\n  for (var event of events) {\r\n    request.removeListener(event, eventHandlers[event]);\r\n  }\r\n  request.on(\"error\", noop);\r\n  request.destroy(error);\r\n}\r\n\r\nfunction isSubdomain(subdomain, domain) {\r\n  assert(isString(subdomain) && isString(domain));\r\n  var dot = subdomain.length - domain.length - 1;\r\n  return dot > 0 && subdomain[dot] === \".\" && subdomain.endsWith(domain);\r\n}\r\n\r\nfunction isString(value) {\r\n  return typeof value === \"string\" || value instanceof String;\r\n}\r\n\r\nfunction isFunction(value) {\r\n  return typeof value === \"function\";\r\n}\r\n\r\nfunction isBuffer(value) {\r\n  return typeof value === \"object\" && (\"length\" in value);\r\n}\r\n\r\nfunction isURL(value) {\r\n  return URL && value instanceof URL;\r\n}\r\n\r\n// Exports\r\nmodule.exports = wrap({ http: http, https: https });\r\nmodule.exports.wrap = wrap;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZm9sbG93LXJlZGlyZWN0cy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsZ0JBQUs7QUFDdkI7QUFDQSxXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsWUFBWSxtQkFBTyxDQUFDLG9CQUFPO0FBQzNCLGVBQWUsc0RBQTBCO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixZQUFZLG1CQUFPLENBQUMsK0RBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsY0FBYztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdDQUFnQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0NBQXdDO0FBQy9ELEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsbUJBQW1CO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0VBQXNFO0FBQ3ZGLGFBQWEsa0VBQWtFO0FBQy9FLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xELG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL3Rlc3RfY291cnNlLy4vbm9kZV9tb2R1bGVzL2ZvbGxvdy1yZWRpcmVjdHMvaW5kZXguanM/OGNiZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdXJsID0gcmVxdWlyZShcInVybFwiKTtcclxudmFyIFVSTCA9IHVybC5VUkw7XHJcbnZhciBodHRwID0gcmVxdWlyZShcImh0dHBcIik7XHJcbnZhciBodHRwcyA9IHJlcXVpcmUoXCJodHRwc1wiKTtcclxudmFyIFdyaXRhYmxlID0gcmVxdWlyZShcInN0cmVhbVwiKS5Xcml0YWJsZTtcclxudmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XHJcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoXCIuL2RlYnVnXCIpO1xyXG5cclxuLy8gV2hldGhlciB0byB1c2UgdGhlIG5hdGl2ZSBVUkwgb2JqZWN0IG9yIHRoZSBsZWdhY3kgdXJsIG1vZHVsZVxyXG52YXIgdXNlTmF0aXZlVVJMID0gZmFsc2U7XHJcbnRyeSB7XHJcbiAgYXNzZXJ0KG5ldyBVUkwoKSk7XHJcbn1cclxuY2F0Y2ggKGVycm9yKSB7XHJcbiAgdXNlTmF0aXZlVVJMID0gZXJyb3IuY29kZSA9PT0gXCJFUlJfSU5WQUxJRF9VUkxcIjtcclxufVxyXG5cclxuLy8gVVJMIGZpZWxkcyB0byBwcmVzZXJ2ZSBpbiBjb3B5IG9wZXJhdGlvbnNcclxudmFyIHByZXNlcnZlZFVybEZpZWxkcyA9IFtcclxuICBcImF1dGhcIixcclxuICBcImhvc3RcIixcclxuICBcImhvc3RuYW1lXCIsXHJcbiAgXCJocmVmXCIsXHJcbiAgXCJwYXRoXCIsXHJcbiAgXCJwYXRobmFtZVwiLFxyXG4gIFwicG9ydFwiLFxyXG4gIFwicHJvdG9jb2xcIixcclxuICBcInF1ZXJ5XCIsXHJcbiAgXCJzZWFyY2hcIixcclxuICBcImhhc2hcIixcclxuXTtcclxuXHJcbi8vIENyZWF0ZSBoYW5kbGVycyB0aGF0IHBhc3MgZXZlbnRzIGZyb20gbmF0aXZlIHJlcXVlc3RzXHJcbnZhciBldmVudHMgPSBbXCJhYm9ydFwiLCBcImFib3J0ZWRcIiwgXCJjb25uZWN0XCIsIFwiZXJyb3JcIiwgXCJzb2NrZXRcIiwgXCJ0aW1lb3V0XCJdO1xyXG52YXIgZXZlbnRIYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbmV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xyXG4gIGV2ZW50SGFuZGxlcnNbZXZlbnRdID0gZnVuY3Rpb24gKGFyZzEsIGFyZzIsIGFyZzMpIHtcclxuICAgIHRoaXMuX3JlZGlyZWN0YWJsZS5lbWl0KGV2ZW50LCBhcmcxLCBhcmcyLCBhcmczKTtcclxuICB9O1xyXG59KTtcclxuXHJcbi8vIEVycm9yIHR5cGVzIHdpdGggY29kZXNcclxudmFyIEludmFsaWRVcmxFcnJvciA9IGNyZWF0ZUVycm9yVHlwZShcclxuICBcIkVSUl9JTlZBTElEX1VSTFwiLFxyXG4gIFwiSW52YWxpZCBVUkxcIixcclxuICBUeXBlRXJyb3JcclxuKTtcclxudmFyIFJlZGlyZWN0aW9uRXJyb3IgPSBjcmVhdGVFcnJvclR5cGUoXHJcbiAgXCJFUlJfRlJfUkVESVJFQ1RJT05fRkFJTFVSRVwiLFxyXG4gIFwiUmVkaXJlY3RlZCByZXF1ZXN0IGZhaWxlZFwiXHJcbik7XHJcbnZhciBUb29NYW55UmVkaXJlY3RzRXJyb3IgPSBjcmVhdGVFcnJvclR5cGUoXHJcbiAgXCJFUlJfRlJfVE9PX01BTllfUkVESVJFQ1RTXCIsXHJcbiAgXCJNYXhpbXVtIG51bWJlciBvZiByZWRpcmVjdHMgZXhjZWVkZWRcIixcclxuICBSZWRpcmVjdGlvbkVycm9yXHJcbik7XHJcbnZhciBNYXhCb2R5TGVuZ3RoRXhjZWVkZWRFcnJvciA9IGNyZWF0ZUVycm9yVHlwZShcclxuICBcIkVSUl9GUl9NQVhfQk9EWV9MRU5HVEhfRVhDRUVERURcIixcclxuICBcIlJlcXVlc3QgYm9keSBsYXJnZXIgdGhhbiBtYXhCb2R5TGVuZ3RoIGxpbWl0XCJcclxuKTtcclxudmFyIFdyaXRlQWZ0ZXJFbmRFcnJvciA9IGNyZWF0ZUVycm9yVHlwZShcclxuICBcIkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EXCIsXHJcbiAgXCJ3cml0ZSBhZnRlciBlbmRcIlxyXG4pO1xyXG5cclxuLy8gaXN0YW5idWwgaWdub3JlIG5leHRcclxudmFyIGRlc3Ryb3kgPSBXcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSB8fCBub29wO1xyXG5cclxuLy8gQW4gSFRUUChTKSByZXF1ZXN0IHRoYXQgY2FuIGJlIHJlZGlyZWN0ZWRcclxuZnVuY3Rpb24gUmVkaXJlY3RhYmxlUmVxdWVzdChvcHRpb25zLCByZXNwb25zZUNhbGxiYWNrKSB7XHJcbiAgLy8gSW5pdGlhbGl6ZSB0aGUgcmVxdWVzdFxyXG4gIFdyaXRhYmxlLmNhbGwodGhpcyk7XHJcbiAgdGhpcy5fc2FuaXRpemVPcHRpb25zKG9wdGlvbnMpO1xyXG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xyXG4gIHRoaXMuX2VuZGVkID0gZmFsc2U7XHJcbiAgdGhpcy5fZW5kaW5nID0gZmFsc2U7XHJcbiAgdGhpcy5fcmVkaXJlY3RDb3VudCA9IDA7XHJcbiAgdGhpcy5fcmVkaXJlY3RzID0gW107XHJcbiAgdGhpcy5fcmVxdWVzdEJvZHlMZW5ndGggPSAwO1xyXG4gIHRoaXMuX3JlcXVlc3RCb2R5QnVmZmVycyA9IFtdO1xyXG5cclxuICAvLyBBdHRhY2ggYSBjYWxsYmFjayBpZiBwYXNzZWRcclxuICBpZiAocmVzcG9uc2VDYWxsYmFjaykge1xyXG4gICAgdGhpcy5vbihcInJlc3BvbnNlXCIsIHJlc3BvbnNlQ2FsbGJhY2spO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVhY3QgdG8gcmVzcG9uc2VzIG9mIG5hdGl2ZSByZXF1ZXN0c1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuICB0aGlzLl9vbk5hdGl2ZVJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBzZWxmLl9wcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGNhdXNlKSB7XHJcbiAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGNhdXNlIGluc3RhbmNlb2YgUmVkaXJlY3Rpb25FcnJvciA/XHJcbiAgICAgICAgY2F1c2UgOiBuZXcgUmVkaXJlY3Rpb25FcnJvcih7IGNhdXNlOiBjYXVzZSB9KSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gUGVyZm9ybSB0aGUgZmlyc3QgcmVxdWVzdFxyXG4gIHRoaXMuX3BlcmZvcm1SZXF1ZXN0KCk7XHJcbn1cclxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdyaXRhYmxlLnByb3RvdHlwZSk7XHJcblxyXG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcclxuICBkZXN0cm95UmVxdWVzdCh0aGlzLl9jdXJyZW50UmVxdWVzdCk7XHJcbiAgdGhpcy5fY3VycmVudFJlcXVlc3QuYWJvcnQoKTtcclxuICB0aGlzLmVtaXQoXCJhYm9ydFwiKTtcclxufTtcclxuXHJcblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICBkZXN0cm95UmVxdWVzdCh0aGlzLl9jdXJyZW50UmVxdWVzdCwgZXJyb3IpO1xyXG4gIGRlc3Ryb3kuY2FsbCh0aGlzLCBlcnJvcik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vLyBXcml0ZXMgYnVmZmVyZWQgZGF0YSB0byB0aGUgY3VycmVudCBuYXRpdmUgcmVxdWVzdFxyXG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spIHtcclxuICAvLyBXcml0aW5nIGlzIG5vdCBhbGxvd2VkIGlmIGVuZCBoYXMgYmVlbiBjYWxsZWRcclxuICBpZiAodGhpcy5fZW5kaW5nKSB7XHJcbiAgICB0aHJvdyBuZXcgV3JpdGVBZnRlckVuZEVycm9yKCk7XHJcbiAgfVxyXG5cclxuICAvLyBWYWxpZGF0ZSBpbnB1dCBhbmQgc2hpZnQgcGFyYW1ldGVycyBpZiBuZWNlc3NhcnlcclxuICBpZiAoIWlzU3RyaW5nKGRhdGEpICYmICFpc0J1ZmZlcihkYXRhKSkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImRhdGEgc2hvdWxkIGJlIGEgc3RyaW5nLCBCdWZmZXIgb3IgVWludDhBcnJheVwiKTtcclxuICB9XHJcbiAgaWYgKGlzRnVuY3Rpb24oZW5jb2RpbmcpKSB7XHJcbiAgICBjYWxsYmFjayA9IGVuY29kaW5nO1xyXG4gICAgZW5jb2RpbmcgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLy8gSWdub3JlIGVtcHR5IGJ1ZmZlcnMsIHNpbmNlIHdyaXRpbmcgdGhlbSBkb2Vzbid0IGludm9rZSB0aGUgY2FsbGJhY2tcclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzIyMDY2XHJcbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XHJcbiAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgY2FsbGJhY2soKTtcclxuICAgIH1cclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgLy8gT25seSB3cml0ZSB3aGVuIHdlIGRvbid0IGV4Y2VlZCB0aGUgbWF4aW11bSBib2R5IGxlbmd0aFxyXG4gIGlmICh0aGlzLl9yZXF1ZXN0Qm9keUxlbmd0aCArIGRhdGEubGVuZ3RoIDw9IHRoaXMuX29wdGlvbnMubWF4Qm9keUxlbmd0aCkge1xyXG4gICAgdGhpcy5fcmVxdWVzdEJvZHlMZW5ndGggKz0gZGF0YS5sZW5ndGg7XHJcbiAgICB0aGlzLl9yZXF1ZXN0Qm9keUJ1ZmZlcnMucHVzaCh7IGRhdGE6IGRhdGEsIGVuY29kaW5nOiBlbmNvZGluZyB9KTtcclxuICAgIHRoaXMuX2N1cnJlbnRSZXF1ZXN0LndyaXRlKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjayk7XHJcbiAgfVxyXG4gIC8vIEVycm9yIHdoZW4gd2UgZXhjZWVkIHRoZSBtYXhpbXVtIGJvZHkgbGVuZ3RoXHJcbiAgZWxzZSB7XHJcbiAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBuZXcgTWF4Qm9keUxlbmd0aEV4Y2VlZGVkRXJyb3IoKSk7XHJcbiAgICB0aGlzLmFib3J0KCk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gRW5kcyB0aGUgY3VycmVudCBuYXRpdmUgcmVxdWVzdFxyXG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XHJcbiAgLy8gU2hpZnQgcGFyYW1ldGVycyBpZiBuZWNlc3NhcnlcclxuICBpZiAoaXNGdW5jdGlvbihkYXRhKSkge1xyXG4gICAgY2FsbGJhY2sgPSBkYXRhO1xyXG4gICAgZGF0YSA9IGVuY29kaW5nID0gbnVsbDtcclxuICB9XHJcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbihlbmNvZGluZykpIHtcclxuICAgIGNhbGxiYWNrID0gZW5jb2Rpbmc7XHJcbiAgICBlbmNvZGluZyA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvLyBXcml0ZSBkYXRhIGlmIG5lZWRlZCBhbmQgZW5kXHJcbiAgaWYgKCFkYXRhKSB7XHJcbiAgICB0aGlzLl9lbmRlZCA9IHRoaXMuX2VuZGluZyA9IHRydWU7XHJcbiAgICB0aGlzLl9jdXJyZW50UmVxdWVzdC5lbmQobnVsbCwgbnVsbCwgY2FsbGJhY2spO1xyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIHZhciBjdXJyZW50UmVxdWVzdCA9IHRoaXMuX2N1cnJlbnRSZXF1ZXN0O1xyXG4gICAgdGhpcy53cml0ZShkYXRhLCBlbmNvZGluZywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBzZWxmLl9lbmRlZCA9IHRydWU7XHJcbiAgICAgIGN1cnJlbnRSZXF1ZXN0LmVuZChudWxsLCBudWxsLCBjYWxsYmFjayk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuX2VuZGluZyA9IHRydWU7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gU2V0cyBhIGhlYWRlciB2YWx1ZSBvbiB0aGUgY3VycmVudCBuYXRpdmUgcmVxdWVzdFxyXG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5zZXRIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcclxuICB0aGlzLl9vcHRpb25zLmhlYWRlcnNbbmFtZV0gPSB2YWx1ZTtcclxuICB0aGlzLl9jdXJyZW50UmVxdWVzdC5zZXRIZWFkZXIobmFtZSwgdmFsdWUpO1xyXG59O1xyXG5cclxuLy8gQ2xlYXJzIGEgaGVhZGVyIHZhbHVlIG9uIHRoZSBjdXJyZW50IG5hdGl2ZSByZXF1ZXN0XHJcblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLnJlbW92ZUhlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgZGVsZXRlIHRoaXMuX29wdGlvbnMuaGVhZGVyc1tuYW1lXTtcclxuICB0aGlzLl9jdXJyZW50UmVxdWVzdC5yZW1vdmVIZWFkZXIobmFtZSk7XHJcbn07XHJcblxyXG4vLyBHbG9iYWwgdGltZW91dCBmb3IgYWxsIHVuZGVybHlpbmcgcmVxdWVzdHNcclxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuc2V0VGltZW91dCA9IGZ1bmN0aW9uIChtc2VjcywgY2FsbGJhY2spIHtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gIC8vIERlc3Ryb3lzIHRoZSBzb2NrZXQgb24gdGltZW91dFxyXG4gIGZ1bmN0aW9uIGRlc3Ryb3lPblRpbWVvdXQoc29ja2V0KSB7XHJcbiAgICBzb2NrZXQuc2V0VGltZW91dChtc2Vjcyk7XHJcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoXCJ0aW1lb3V0XCIsIHNvY2tldC5kZXN0cm95KTtcclxuICAgIHNvY2tldC5hZGRMaXN0ZW5lcihcInRpbWVvdXRcIiwgc29ja2V0LmRlc3Ryb3kpO1xyXG4gIH1cclxuXHJcbiAgLy8gU2V0cyB1cCBhIHRpbWVyIHRvIHRyaWdnZXIgYSB0aW1lb3V0IGV2ZW50XHJcbiAgZnVuY3Rpb24gc3RhcnRUaW1lcihzb2NrZXQpIHtcclxuICAgIGlmIChzZWxmLl90aW1lb3V0KSB7XHJcbiAgICAgIGNsZWFyVGltZW91dChzZWxmLl90aW1lb3V0KTtcclxuICAgIH1cclxuICAgIHNlbGYuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgc2VsZi5lbWl0KFwidGltZW91dFwiKTtcclxuICAgICAgY2xlYXJUaW1lcigpO1xyXG4gICAgfSwgbXNlY3MpO1xyXG4gICAgZGVzdHJveU9uVGltZW91dChzb2NrZXQpO1xyXG4gIH1cclxuXHJcbiAgLy8gU3RvcHMgYSB0aW1lb3V0IGZyb20gdHJpZ2dlcmluZ1xyXG4gIGZ1bmN0aW9uIGNsZWFyVGltZXIoKSB7XHJcbiAgICAvLyBDbGVhciB0aGUgdGltZW91dFxyXG4gICAgaWYgKHNlbGYuX3RpbWVvdXQpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3RpbWVvdXQpO1xyXG4gICAgICBzZWxmLl90aW1lb3V0ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDbGVhbiB1cCBhbGwgYXR0YWNoZWQgbGlzdGVuZXJzXHJcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKFwiYWJvcnRcIiwgY2xlYXJUaW1lcik7XHJcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgY2xlYXJUaW1lcik7XHJcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKFwicmVzcG9uc2VcIiwgY2xlYXJUaW1lcik7XHJcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgY2xlYXJUaW1lcik7XHJcbiAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcihcInRpbWVvdXRcIiwgY2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgaWYgKCFzZWxmLnNvY2tldCkge1xyXG4gICAgICBzZWxmLl9jdXJyZW50UmVxdWVzdC5yZW1vdmVMaXN0ZW5lcihcInNvY2tldFwiLCBzdGFydFRpbWVyKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEF0dGFjaCBjYWxsYmFjayBpZiBwYXNzZWRcclxuICBpZiAoY2FsbGJhY2spIHtcclxuICAgIHRoaXMub24oXCJ0aW1lb3V0XCIsIGNhbGxiYWNrKTtcclxuICB9XHJcblxyXG4gIC8vIFN0YXJ0IHRoZSB0aW1lciBpZiBvciB3aGVuIHRoZSBzb2NrZXQgaXMgb3BlbmVkXHJcbiAgaWYgKHRoaXMuc29ja2V0KSB7XHJcbiAgICBzdGFydFRpbWVyKHRoaXMuc29ja2V0KTtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICB0aGlzLl9jdXJyZW50UmVxdWVzdC5vbmNlKFwic29ja2V0XCIsIHN0YXJ0VGltZXIpO1xyXG4gIH1cclxuXHJcbiAgLy8gQ2xlYW4gdXAgb24gZXZlbnRzXHJcbiAgdGhpcy5vbihcInNvY2tldFwiLCBkZXN0cm95T25UaW1lb3V0KTtcclxuICB0aGlzLm9uKFwiYWJvcnRcIiwgY2xlYXJUaW1lcik7XHJcbiAgdGhpcy5vbihcImVycm9yXCIsIGNsZWFyVGltZXIpO1xyXG4gIHRoaXMub24oXCJyZXNwb25zZVwiLCBjbGVhclRpbWVyKTtcclxuICB0aGlzLm9uKFwiY2xvc2VcIiwgY2xlYXJUaW1lcik7XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gUHJveHkgYWxsIG90aGVyIHB1YmxpYyBDbGllbnRSZXF1ZXN0IG1ldGhvZHNcclxuW1xyXG4gIFwiZmx1c2hIZWFkZXJzXCIsIFwiZ2V0SGVhZGVyXCIsXHJcbiAgXCJzZXROb0RlbGF5XCIsIFwic2V0U29ja2V0S2VlcEFsaXZlXCIsXHJcbl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XHJcbiAgUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFJlcXVlc3RbbWV0aG9kXShhLCBiKTtcclxuICB9O1xyXG59KTtcclxuXHJcbi8vIFByb3h5IGFsbCBwdWJsaWMgQ2xpZW50UmVxdWVzdCBwcm9wZXJ0aWVzXHJcbltcImFib3J0ZWRcIiwgXCJjb25uZWN0aW9uXCIsIFwic29ja2V0XCJdLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLCBwcm9wZXJ0eSwge1xyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jdXJyZW50UmVxdWVzdFtwcm9wZXJ0eV07IH0sXHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuX3Nhbml0aXplT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgLy8gRW5zdXJlIGhlYWRlcnMgYXJlIGFsd2F5cyBwcmVzZW50XHJcbiAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcclxuICAgIG9wdGlvbnMuaGVhZGVycyA9IHt9O1xyXG4gIH1cclxuXHJcbiAgLy8gU2luY2UgaHR0cC5yZXF1ZXN0IHRyZWF0cyBob3N0IGFzIGFuIGFsaWFzIG9mIGhvc3RuYW1lLFxyXG4gIC8vIGJ1dCB0aGUgdXJsIG1vZHVsZSBpbnRlcnByZXRzIGhvc3QgYXMgaG9zdG5hbWUgcGx1cyBwb3J0LFxyXG4gIC8vIGVsaW1pbmF0ZSB0aGUgaG9zdCBwcm9wZXJ0eSB0byBhdm9pZCBjb25mdXNpb24uXHJcbiAgaWYgKG9wdGlvbnMuaG9zdCkge1xyXG4gICAgLy8gVXNlIGhvc3RuYW1lIGlmIHNldCwgYmVjYXVzZSBpdCBoYXMgcHJlY2VkZW5jZVxyXG4gICAgaWYgKCFvcHRpb25zLmhvc3RuYW1lKSB7XHJcbiAgICAgIG9wdGlvbnMuaG9zdG5hbWUgPSBvcHRpb25zLmhvc3Q7XHJcbiAgICB9XHJcbiAgICBkZWxldGUgb3B0aW9ucy5ob3N0O1xyXG4gIH1cclxuXHJcbiAgLy8gQ29tcGxldGUgdGhlIFVSTCBvYmplY3Qgd2hlbiBuZWNlc3NhcnlcclxuICBpZiAoIW9wdGlvbnMucGF0aG5hbWUgJiYgb3B0aW9ucy5wYXRoKSB7XHJcbiAgICB2YXIgc2VhcmNoUG9zID0gb3B0aW9ucy5wYXRoLmluZGV4T2YoXCI/XCIpO1xyXG4gICAgaWYgKHNlYXJjaFBvcyA8IDApIHtcclxuICAgICAgb3B0aW9ucy5wYXRobmFtZSA9IG9wdGlvbnMucGF0aDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBvcHRpb25zLnBhdGhuYW1lID0gb3B0aW9ucy5wYXRoLnN1YnN0cmluZygwLCBzZWFyY2hQb3MpO1xyXG4gICAgICBvcHRpb25zLnNlYXJjaCA9IG9wdGlvbnMucGF0aC5zdWJzdHJpbmcoc2VhcmNoUG9zKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5cclxuLy8gRXhlY3V0ZXMgdGhlIG5leHQgbmF0aXZlIHJlcXVlc3QgKGluaXRpYWwgb3IgcmVkaXJlY3QpXHJcblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLl9wZXJmb3JtUmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAvLyBMb2FkIHRoZSBuYXRpdmUgcHJvdG9jb2xcclxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLl9vcHRpb25zLnByb3RvY29sO1xyXG4gIHZhciBuYXRpdmVQcm90b2NvbCA9IHRoaXMuX29wdGlvbnMubmF0aXZlUHJvdG9jb2xzW3Byb3RvY29sXTtcclxuICBpZiAoIW5hdGl2ZVByb3RvY29sKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5zdXBwb3J0ZWQgcHJvdG9jb2wgXCIgKyBwcm90b2NvbCk7XHJcbiAgfVxyXG5cclxuICAvLyBJZiBzcGVjaWZpZWQsIHVzZSB0aGUgYWdlbnQgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvdG9jb2xcclxuICAvLyAoSFRUUCBhbmQgSFRUUFMgdXNlIGRpZmZlcmVudCB0eXBlcyBvZiBhZ2VudHMpXHJcbiAgaWYgKHRoaXMuX29wdGlvbnMuYWdlbnRzKSB7XHJcbiAgICB2YXIgc2NoZW1lID0gcHJvdG9jb2wuc2xpY2UoMCwgLTEpO1xyXG4gICAgdGhpcy5fb3B0aW9ucy5hZ2VudCA9IHRoaXMuX29wdGlvbnMuYWdlbnRzW3NjaGVtZV07XHJcbiAgfVxyXG5cclxuICAvLyBDcmVhdGUgdGhlIG5hdGl2ZSByZXF1ZXN0IGFuZCBzZXQgdXAgaXRzIGV2ZW50IGhhbmRsZXJzXHJcbiAgdmFyIHJlcXVlc3QgPSB0aGlzLl9jdXJyZW50UmVxdWVzdCA9XHJcbiAgICAgICAgbmF0aXZlUHJvdG9jb2wucmVxdWVzdCh0aGlzLl9vcHRpb25zLCB0aGlzLl9vbk5hdGl2ZVJlc3BvbnNlKTtcclxuICByZXF1ZXN0Ll9yZWRpcmVjdGFibGUgPSB0aGlzO1xyXG4gIGZvciAodmFyIGV2ZW50IG9mIGV2ZW50cykge1xyXG4gICAgcmVxdWVzdC5vbihldmVudCwgZXZlbnRIYW5kbGVyc1tldmVudF0pO1xyXG4gIH1cclxuXHJcbiAgLy8gUkZDNzIzMMKnNS4zLjE6IFdoZW4gbWFraW5nIGEgcmVxdWVzdCBkaXJlY3RseSB0byBhbiBvcmlnaW4gc2VydmVyLCBb4oCmXVxyXG4gIC8vIGEgY2xpZW50IE1VU1Qgc2VuZCBvbmx5IHRoZSBhYnNvbHV0ZSBwYXRoIFvigKZdIGFzIHRoZSByZXF1ZXN0LXRhcmdldC5cclxuICB0aGlzLl9jdXJyZW50VXJsID0gL15cXC8vLnRlc3QodGhpcy5fb3B0aW9ucy5wYXRoKSA/XHJcbiAgICB1cmwuZm9ybWF0KHRoaXMuX29wdGlvbnMpIDpcclxuICAgIC8vIFdoZW4gbWFraW5nIGEgcmVxdWVzdCB0byBhIHByb3h5LCBb4oCmXVxyXG4gICAgLy8gYSBjbGllbnQgTVVTVCBzZW5kIHRoZSB0YXJnZXQgVVJJIGluIGFic29sdXRlLWZvcm0gW+KApl0uXHJcbiAgICB0aGlzLl9vcHRpb25zLnBhdGg7XHJcblxyXG4gIC8vIEVuZCBhIHJlZGlyZWN0ZWQgcmVxdWVzdFxyXG4gIC8vIChUaGUgZmlyc3QgcmVxdWVzdCBtdXN0IGJlIGVuZGVkIGV4cGxpY2l0bHkgd2l0aCBSZWRpcmVjdGFibGVSZXF1ZXN0I2VuZClcclxuICBpZiAodGhpcy5faXNSZWRpcmVjdCkge1xyXG4gICAgLy8gV3JpdGUgdGhlIHJlcXVlc3QgZW50aXR5IGFuZCBlbmRcclxuICAgIHZhciBpID0gMDtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIHZhciBidWZmZXJzID0gdGhpcy5fcmVxdWVzdEJvZHlCdWZmZXJzO1xyXG4gICAgKGZ1bmN0aW9uIHdyaXRlTmV4dChlcnJvcikge1xyXG4gICAgICAvLyBPbmx5IHdyaXRlIGlmIHRoaXMgcmVxdWVzdCBoYXMgbm90IGJlZW4gcmVkaXJlY3RlZCB5ZXRcclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgICAgaWYgKHJlcXVlc3QgPT09IHNlbGYuX2N1cnJlbnRSZXF1ZXN0KSB7XHJcbiAgICAgICAgLy8gUmVwb3J0IGFueSB3cml0ZSBlcnJvcnNcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV3JpdGUgdGhlIG5leHQgYnVmZmVyIGlmIHRoZXJlIGFyZSBzdGlsbCBsZWZ0XHJcbiAgICAgICAgZWxzZSBpZiAoaSA8IGJ1ZmZlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICB2YXIgYnVmZmVyID0gYnVmZmVyc1tpKytdO1xyXG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgICAgICAgIGlmICghcmVxdWVzdC5maW5pc2hlZCkge1xyXG4gICAgICAgICAgICByZXF1ZXN0LndyaXRlKGJ1ZmZlci5kYXRhLCBidWZmZXIuZW5jb2RpbmcsIHdyaXRlTmV4dCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEVuZCB0aGUgcmVxdWVzdCBpZiBgZW5kYCBoYXMgYmVlbiBjYWxsZWQgb24gdXNcclxuICAgICAgICBlbHNlIGlmIChzZWxmLl9lbmRlZCkge1xyXG4gICAgICAgICAgcmVxdWVzdC5lbmQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0oKSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gUHJvY2Vzc2VzIGEgcmVzcG9uc2UgZnJvbSB0aGUgY3VycmVudCBuYXRpdmUgcmVxdWVzdFxyXG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5fcHJvY2Vzc1Jlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgLy8gU3RvcmUgdGhlIHJlZGlyZWN0ZWQgcmVzcG9uc2VcclxuICB2YXIgc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1c0NvZGU7XHJcbiAgaWYgKHRoaXMuX29wdGlvbnMudHJhY2tSZWRpcmVjdHMpIHtcclxuICAgIHRoaXMuX3JlZGlyZWN0cy5wdXNoKHtcclxuICAgICAgdXJsOiB0aGlzLl9jdXJyZW50VXJsLFxyXG4gICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxyXG4gICAgICBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlLFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBSRkM3MjMxwqc2LjQ6IFRoZSAzeHggKFJlZGlyZWN0aW9uKSBjbGFzcyBvZiBzdGF0dXMgY29kZSBpbmRpY2F0ZXNcclxuICAvLyB0aGF0IGZ1cnRoZXIgYWN0aW9uIG5lZWRzIHRvIGJlIHRha2VuIGJ5IHRoZSB1c2VyIGFnZW50IGluIG9yZGVyIHRvXHJcbiAgLy8gZnVsZmlsbCB0aGUgcmVxdWVzdC4gSWYgYSBMb2NhdGlvbiBoZWFkZXIgZmllbGQgaXMgcHJvdmlkZWQsXHJcbiAgLy8gdGhlIHVzZXIgYWdlbnQgTUFZIGF1dG9tYXRpY2FsbHkgcmVkaXJlY3QgaXRzIHJlcXVlc3QgdG8gdGhlIFVSSVxyXG4gIC8vIHJlZmVyZW5jZWQgYnkgdGhlIExvY2F0aW9uIGZpZWxkIHZhbHVlLFxyXG4gIC8vIGV2ZW4gaWYgdGhlIHNwZWNpZmljIHN0YXR1cyBjb2RlIGlzIG5vdCB1bmRlcnN0b29kLlxyXG5cclxuICAvLyBJZiB0aGUgcmVzcG9uc2UgaXMgbm90IGEgcmVkaXJlY3Q7IHJldHVybiBpdCBhcy1pc1xyXG4gIHZhciBsb2NhdGlvbiA9IHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb247XHJcbiAgaWYgKCFsb2NhdGlvbiB8fCB0aGlzLl9vcHRpb25zLmZvbGxvd1JlZGlyZWN0cyA9PT0gZmFsc2UgfHxcclxuICAgICAgc3RhdHVzQ29kZSA8IDMwMCB8fCBzdGF0dXNDb2RlID49IDQwMCkge1xyXG4gICAgcmVzcG9uc2UucmVzcG9uc2VVcmwgPSB0aGlzLl9jdXJyZW50VXJsO1xyXG4gICAgcmVzcG9uc2UucmVkaXJlY3RzID0gdGhpcy5fcmVkaXJlY3RzO1xyXG4gICAgdGhpcy5lbWl0KFwicmVzcG9uc2VcIiwgcmVzcG9uc2UpO1xyXG5cclxuICAgIC8vIENsZWFuIHVwXHJcbiAgICB0aGlzLl9yZXF1ZXN0Qm9keUJ1ZmZlcnMgPSBbXTtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIFRoZSByZXNwb25zZSBpcyBhIHJlZGlyZWN0LCBzbyBhYm9ydCB0aGUgY3VycmVudCByZXF1ZXN0XHJcbiAgZGVzdHJveVJlcXVlc3QodGhpcy5fY3VycmVudFJlcXVlc3QpO1xyXG4gIC8vIERpc2NhcmQgdGhlIHJlbWFpbmRlciBvZiB0aGUgcmVzcG9uc2UgdG8gYXZvaWQgd2FpdGluZyBmb3IgZGF0YVxyXG4gIHJlc3BvbnNlLmRlc3Ryb3koKTtcclxuXHJcbiAgLy8gUkZDNzIzMcKnNi40OiBBIGNsaWVudCBTSE9VTEQgZGV0ZWN0IGFuZCBpbnRlcnZlbmVcclxuICAvLyBpbiBjeWNsaWNhbCByZWRpcmVjdGlvbnMgKGkuZS4sIFwiaW5maW5pdGVcIiByZWRpcmVjdGlvbiBsb29wcykuXHJcbiAgaWYgKCsrdGhpcy5fcmVkaXJlY3RDb3VudCA+IHRoaXMuX29wdGlvbnMubWF4UmVkaXJlY3RzKSB7XHJcbiAgICB0aHJvdyBuZXcgVG9vTWFueVJlZGlyZWN0c0Vycm9yKCk7XHJcbiAgfVxyXG5cclxuICAvLyBTdG9yZSB0aGUgcmVxdWVzdCBoZWFkZXJzIGlmIGFwcGxpY2FibGVcclxuICB2YXIgcmVxdWVzdEhlYWRlcnM7XHJcbiAgdmFyIGJlZm9yZVJlZGlyZWN0ID0gdGhpcy5fb3B0aW9ucy5iZWZvcmVSZWRpcmVjdDtcclxuICBpZiAoYmVmb3JlUmVkaXJlY3QpIHtcclxuICAgIHJlcXVlc3RIZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgIC8vIFRoZSBIb3N0IGhlYWRlciB3YXMgc2V0IGJ5IG5hdGl2ZVByb3RvY29sLnJlcXVlc3RcclxuICAgICAgSG9zdDogcmVzcG9uc2UucmVxLmdldEhlYWRlcihcImhvc3RcIiksXHJcbiAgICB9LCB0aGlzLl9vcHRpb25zLmhlYWRlcnMpO1xyXG4gIH1cclxuXHJcbiAgLy8gUkZDNzIzMcKnNi40OiBBdXRvbWF0aWMgcmVkaXJlY3Rpb24gbmVlZHMgdG8gZG9uZSB3aXRoXHJcbiAgLy8gY2FyZSBmb3IgbWV0aG9kcyBub3Qga25vd24gdG8gYmUgc2FmZSwgW+KApl1cclxuICAvLyBSRkM3MjMxwqc2LjQuMuKAkzM6IEZvciBoaXN0b3JpY2FsIHJlYXNvbnMsIGEgdXNlciBhZ2VudCBNQVkgY2hhbmdlXHJcbiAgLy8gdGhlIHJlcXVlc3QgbWV0aG9kIGZyb20gUE9TVCB0byBHRVQgZm9yIHRoZSBzdWJzZXF1ZW50IHJlcXVlc3QuXHJcbiAgdmFyIG1ldGhvZCA9IHRoaXMuX29wdGlvbnMubWV0aG9kO1xyXG4gIGlmICgoc3RhdHVzQ29kZSA9PT0gMzAxIHx8IHN0YXR1c0NvZGUgPT09IDMwMikgJiYgdGhpcy5fb3B0aW9ucy5tZXRob2QgPT09IFwiUE9TVFwiIHx8XHJcbiAgICAgIC8vIFJGQzcyMzHCpzYuNC40OiBUaGUgMzAzIChTZWUgT3RoZXIpIHN0YXR1cyBjb2RlIGluZGljYXRlcyB0aGF0XHJcbiAgICAgIC8vIHRoZSBzZXJ2ZXIgaXMgcmVkaXJlY3RpbmcgdGhlIHVzZXIgYWdlbnQgdG8gYSBkaWZmZXJlbnQgcmVzb3VyY2UgW+KApl1cclxuICAgICAgLy8gQSB1c2VyIGFnZW50IGNhbiBwZXJmb3JtIGEgcmV0cmlldmFsIHJlcXVlc3QgdGFyZ2V0aW5nIHRoYXQgVVJJXHJcbiAgICAgIC8vIChhIEdFVCBvciBIRUFEIHJlcXVlc3QgaWYgdXNpbmcgSFRUUCkgW+KApl1cclxuICAgICAgKHN0YXR1c0NvZGUgPT09IDMwMykgJiYgIS9eKD86R0VUfEhFQUQpJC8udGVzdCh0aGlzLl9vcHRpb25zLm1ldGhvZCkpIHtcclxuICAgIHRoaXMuX29wdGlvbnMubWV0aG9kID0gXCJHRVRcIjtcclxuICAgIC8vIERyb3AgYSBwb3NzaWJsZSBlbnRpdHkgYW5kIGhlYWRlcnMgcmVsYXRlZCB0byBpdFxyXG4gICAgdGhpcy5fcmVxdWVzdEJvZHlCdWZmZXJzID0gW107XHJcbiAgICByZW1vdmVNYXRjaGluZ0hlYWRlcnMoL15jb250ZW50LS9pLCB0aGlzLl9vcHRpb25zLmhlYWRlcnMpO1xyXG4gIH1cclxuXHJcbiAgLy8gRHJvcCB0aGUgSG9zdCBoZWFkZXIsIGFzIHRoZSByZWRpcmVjdCBtaWdodCBsZWFkIHRvIGEgZGlmZmVyZW50IGhvc3RcclxuICB2YXIgY3VycmVudEhvc3RIZWFkZXIgPSByZW1vdmVNYXRjaGluZ0hlYWRlcnMoL15ob3N0JC9pLCB0aGlzLl9vcHRpb25zLmhlYWRlcnMpO1xyXG5cclxuICAvLyBJZiB0aGUgcmVkaXJlY3QgaXMgcmVsYXRpdmUsIGNhcnJ5IG92ZXIgdGhlIGhvc3Qgb2YgdGhlIGxhc3QgcmVxdWVzdFxyXG4gIHZhciBjdXJyZW50VXJsUGFydHMgPSBwYXJzZVVybCh0aGlzLl9jdXJyZW50VXJsKTtcclxuICB2YXIgY3VycmVudEhvc3QgPSBjdXJyZW50SG9zdEhlYWRlciB8fCBjdXJyZW50VXJsUGFydHMuaG9zdDtcclxuICB2YXIgY3VycmVudFVybCA9IC9eXFx3KzovLnRlc3QobG9jYXRpb24pID8gdGhpcy5fY3VycmVudFVybCA6XHJcbiAgICB1cmwuZm9ybWF0KE9iamVjdC5hc3NpZ24oY3VycmVudFVybFBhcnRzLCB7IGhvc3Q6IGN1cnJlbnRIb3N0IH0pKTtcclxuXHJcbiAgLy8gQ3JlYXRlIHRoZSByZWRpcmVjdGVkIHJlcXVlc3RcclxuICB2YXIgcmVkaXJlY3RVcmwgPSByZXNvbHZlVXJsKGxvY2F0aW9uLCBjdXJyZW50VXJsKTtcclxuICBkZWJ1ZyhcInJlZGlyZWN0aW5nIHRvXCIsIHJlZGlyZWN0VXJsLmhyZWYpO1xyXG4gIHRoaXMuX2lzUmVkaXJlY3QgPSB0cnVlO1xyXG4gIHNwcmVhZFVybE9iamVjdChyZWRpcmVjdFVybCwgdGhpcy5fb3B0aW9ucyk7XHJcblxyXG4gIC8vIERyb3AgY29uZmlkZW50aWFsIGhlYWRlcnMgd2hlbiByZWRpcmVjdGluZyB0byBhIGxlc3Mgc2VjdXJlIHByb3RvY29sXHJcbiAgLy8gb3IgdG8gYSBkaWZmZXJlbnQgZG9tYWluIHRoYXQgaXMgbm90IGEgc3VwZXJkb21haW5cclxuICBpZiAocmVkaXJlY3RVcmwucHJvdG9jb2wgIT09IGN1cnJlbnRVcmxQYXJ0cy5wcm90b2NvbCAmJlxyXG4gICAgIHJlZGlyZWN0VXJsLnByb3RvY29sICE9PSBcImh0dHBzOlwiIHx8XHJcbiAgICAgcmVkaXJlY3RVcmwuaG9zdCAhPT0gY3VycmVudEhvc3QgJiZcclxuICAgICAhaXNTdWJkb21haW4ocmVkaXJlY3RVcmwuaG9zdCwgY3VycmVudEhvc3QpKSB7XHJcbiAgICByZW1vdmVNYXRjaGluZ0hlYWRlcnMoL14oPzooPzpwcm94eS0pP2F1dGhvcml6YXRpb258Y29va2llKSQvaSwgdGhpcy5fb3B0aW9ucy5oZWFkZXJzKTtcclxuICB9XHJcblxyXG4gIC8vIEV2YWx1YXRlIHRoZSBiZWZvcmVSZWRpcmVjdCBjYWxsYmFja1xyXG4gIGlmIChpc0Z1bmN0aW9uKGJlZm9yZVJlZGlyZWN0KSkge1xyXG4gICAgdmFyIHJlc3BvbnNlRGV0YWlscyA9IHtcclxuICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVycyxcclxuICAgICAgc3RhdHVzQ29kZTogc3RhdHVzQ29kZSxcclxuICAgIH07XHJcbiAgICB2YXIgcmVxdWVzdERldGFpbHMgPSB7XHJcbiAgICAgIHVybDogY3VycmVudFVybCxcclxuICAgICAgbWV0aG9kOiBtZXRob2QsXHJcbiAgICAgIGhlYWRlcnM6IHJlcXVlc3RIZWFkZXJzLFxyXG4gICAgfTtcclxuICAgIGJlZm9yZVJlZGlyZWN0KHRoaXMuX29wdGlvbnMsIHJlc3BvbnNlRGV0YWlscywgcmVxdWVzdERldGFpbHMpO1xyXG4gICAgdGhpcy5fc2FuaXRpemVPcHRpb25zKHRoaXMuX29wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLy8gUGVyZm9ybSB0aGUgcmVkaXJlY3RlZCByZXF1ZXN0XHJcbiAgdGhpcy5fcGVyZm9ybVJlcXVlc3QoKTtcclxufTtcclxuXHJcbi8vIFdyYXBzIHRoZSBrZXkvdmFsdWUgb2JqZWN0IG9mIHByb3RvY29scyB3aXRoIHJlZGlyZWN0IGZ1bmN0aW9uYWxpdHlcclxuZnVuY3Rpb24gd3JhcChwcm90b2NvbHMpIHtcclxuICAvLyBEZWZhdWx0IHNldHRpbmdzXHJcbiAgdmFyIGV4cG9ydHMgPSB7XHJcbiAgICBtYXhSZWRpcmVjdHM6IDIxLFxyXG4gICAgbWF4Qm9keUxlbmd0aDogMTAgKiAxMDI0ICogMTAyNCxcclxuICB9O1xyXG5cclxuICAvLyBXcmFwIGVhY2ggcHJvdG9jb2xcclxuICB2YXIgbmF0aXZlUHJvdG9jb2xzID0ge307XHJcbiAgT2JqZWN0LmtleXMocHJvdG9jb2xzKS5mb3JFYWNoKGZ1bmN0aW9uIChzY2hlbWUpIHtcclxuICAgIHZhciBwcm90b2NvbCA9IHNjaGVtZSArIFwiOlwiO1xyXG4gICAgdmFyIG5hdGl2ZVByb3RvY29sID0gbmF0aXZlUHJvdG9jb2xzW3Byb3RvY29sXSA9IHByb3RvY29sc1tzY2hlbWVdO1xyXG4gICAgdmFyIHdyYXBwZWRQcm90b2NvbCA9IGV4cG9ydHNbc2NoZW1lXSA9IE9iamVjdC5jcmVhdGUobmF0aXZlUHJvdG9jb2wpO1xyXG5cclxuICAgIC8vIEV4ZWN1dGVzIGEgcmVxdWVzdCwgZm9sbG93aW5nIHJlZGlyZWN0c1xyXG4gICAgZnVuY3Rpb24gcmVxdWVzdChpbnB1dCwgb3B0aW9ucywgY2FsbGJhY2spIHtcclxuICAgICAgLy8gUGFyc2UgcGFyYW1ldGVycywgZW5zdXJpbmcgdGhhdCBpbnB1dCBpcyBhbiBvYmplY3RcclxuICAgICAgaWYgKGlzVVJMKGlucHV0KSkge1xyXG4gICAgICAgIGlucHV0ID0gc3ByZWFkVXJsT2JqZWN0KGlucHV0KTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmIChpc1N0cmluZyhpbnB1dCkpIHtcclxuICAgICAgICBpbnB1dCA9IHNwcmVhZFVybE9iamVjdChwYXJzZVVybChpbnB1dCkpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcclxuICAgICAgICBvcHRpb25zID0gdmFsaWRhdGVVcmwoaW5wdXQpO1xyXG4gICAgICAgIGlucHV0ID0geyBwcm90b2NvbDogcHJvdG9jb2wgfTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zKSkge1xyXG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcclxuICAgICAgICBvcHRpb25zID0gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2V0IGRlZmF1bHRzXHJcbiAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcclxuICAgICAgICBtYXhSZWRpcmVjdHM6IGV4cG9ydHMubWF4UmVkaXJlY3RzLFxyXG4gICAgICAgIG1heEJvZHlMZW5ndGg6IGV4cG9ydHMubWF4Qm9keUxlbmd0aCxcclxuICAgICAgfSwgaW5wdXQsIG9wdGlvbnMpO1xyXG4gICAgICBvcHRpb25zLm5hdGl2ZVByb3RvY29scyA9IG5hdGl2ZVByb3RvY29scztcclxuICAgICAgaWYgKCFpc1N0cmluZyhvcHRpb25zLmhvc3QpICYmICFpc1N0cmluZyhvcHRpb25zLmhvc3RuYW1lKSkge1xyXG4gICAgICAgIG9wdGlvbnMuaG9zdG5hbWUgPSBcIjo6MVwiO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhc3NlcnQuZXF1YWwob3B0aW9ucy5wcm90b2NvbCwgcHJvdG9jb2wsIFwicHJvdG9jb2wgbWlzbWF0Y2hcIik7XHJcbiAgICAgIGRlYnVnKFwib3B0aW9uc1wiLCBvcHRpb25zKTtcclxuICAgICAgcmV0dXJuIG5ldyBSZWRpcmVjdGFibGVSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFeGVjdXRlcyBhIEdFVCByZXF1ZXN0LCBmb2xsb3dpbmcgcmVkaXJlY3RzXHJcbiAgICBmdW5jdGlvbiBnZXQoaW5wdXQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcbiAgICAgIHZhciB3cmFwcGVkUmVxdWVzdCA9IHdyYXBwZWRQcm90b2NvbC5yZXF1ZXN0KGlucHV0LCBvcHRpb25zLCBjYWxsYmFjayk7XHJcbiAgICAgIHdyYXBwZWRSZXF1ZXN0LmVuZCgpO1xyXG4gICAgICByZXR1cm4gd3JhcHBlZFJlcXVlc3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRXhwb3NlIHRoZSBwcm9wZXJ0aWVzIG9uIHRoZSB3cmFwcGVkIHByb3RvY29sXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh3cmFwcGVkUHJvdG9jb2wsIHtcclxuICAgICAgcmVxdWVzdDogeyB2YWx1ZTogcmVxdWVzdCwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9LFxyXG4gICAgICBnZXQ6IHsgdmFsdWU6IGdldCwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9LFxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIGV4cG9ydHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vb3AoKSB7IC8qIGVtcHR5ICovIH1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlVXJsKGlucHV0KSB7XHJcbiAgdmFyIHBhcnNlZDtcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gIGlmICh1c2VOYXRpdmVVUkwpIHtcclxuICAgIHBhcnNlZCA9IG5ldyBVUkwoaW5wdXQpO1xyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIC8vIEVuc3VyZSB0aGUgVVJMIGlzIHZhbGlkIGFuZCBhYnNvbHV0ZVxyXG4gICAgcGFyc2VkID0gdmFsaWRhdGVVcmwodXJsLnBhcnNlKGlucHV0KSk7XHJcbiAgICBpZiAoIWlzU3RyaW5nKHBhcnNlZC5wcm90b2NvbCkpIHtcclxuICAgICAgdGhyb3cgbmV3IEludmFsaWRVcmxFcnJvcih7IGlucHV0IH0pO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcGFyc2VkO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlVXJsKHJlbGF0aXZlLCBiYXNlKSB7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICByZXR1cm4gdXNlTmF0aXZlVVJMID8gbmV3IFVSTChyZWxhdGl2ZSwgYmFzZSkgOiBwYXJzZVVybCh1cmwucmVzb2x2ZShiYXNlLCByZWxhdGl2ZSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZVVybChpbnB1dCkge1xyXG4gIGlmICgvXlxcWy8udGVzdChpbnB1dC5ob3N0bmFtZSkgJiYgIS9eXFxbWzowLTlhLWZdK1xcXSQvaS50ZXN0KGlucHV0Lmhvc3RuYW1lKSkge1xyXG4gICAgdGhyb3cgbmV3IEludmFsaWRVcmxFcnJvcih7IGlucHV0OiBpbnB1dC5ocmVmIHx8IGlucHV0IH0pO1xyXG4gIH1cclxuICBpZiAoL15cXFsvLnRlc3QoaW5wdXQuaG9zdCkgJiYgIS9eXFxbWzowLTlhLWZdK1xcXSg6XFxkKyk/JC9pLnRlc3QoaW5wdXQuaG9zdCkpIHtcclxuICAgIHRocm93IG5ldyBJbnZhbGlkVXJsRXJyb3IoeyBpbnB1dDogaW5wdXQuaHJlZiB8fCBpbnB1dCB9KTtcclxuICB9XHJcbiAgcmV0dXJuIGlucHV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzcHJlYWRVcmxPYmplY3QodXJsT2JqZWN0LCB0YXJnZXQpIHtcclxuICB2YXIgc3ByZWFkID0gdGFyZ2V0IHx8IHt9O1xyXG4gIGZvciAodmFyIGtleSBvZiBwcmVzZXJ2ZWRVcmxGaWVsZHMpIHtcclxuICAgIHNwcmVhZFtrZXldID0gdXJsT2JqZWN0W2tleV07XHJcbiAgfVxyXG5cclxuICAvLyBGaXggSVB2NiBob3N0bmFtZVxyXG4gIGlmIChzcHJlYWQuaG9zdG5hbWUuc3RhcnRzV2l0aChcIltcIikpIHtcclxuICAgIHNwcmVhZC5ob3N0bmFtZSA9IHNwcmVhZC5ob3N0bmFtZS5zbGljZSgxLCAtMSk7XHJcbiAgfVxyXG4gIC8vIEVuc3VyZSBwb3J0IGlzIGEgbnVtYmVyXHJcbiAgaWYgKHNwcmVhZC5wb3J0ICE9PSBcIlwiKSB7XHJcbiAgICBzcHJlYWQucG9ydCA9IE51bWJlcihzcHJlYWQucG9ydCk7XHJcbiAgfVxyXG4gIC8vIENvbmNhdGVuYXRlIHBhdGhcclxuICBzcHJlYWQucGF0aCA9IHNwcmVhZC5zZWFyY2ggPyBzcHJlYWQucGF0aG5hbWUgKyBzcHJlYWQuc2VhcmNoIDogc3ByZWFkLnBhdGhuYW1lO1xyXG5cclxuICByZXR1cm4gc3ByZWFkO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVNYXRjaGluZ0hlYWRlcnMocmVnZXgsIGhlYWRlcnMpIHtcclxuICB2YXIgbGFzdFZhbHVlO1xyXG4gIGZvciAodmFyIGhlYWRlciBpbiBoZWFkZXJzKSB7XHJcbiAgICBpZiAocmVnZXgudGVzdChoZWFkZXIpKSB7XHJcbiAgICAgIGxhc3RWYWx1ZSA9IGhlYWRlcnNbaGVhZGVyXTtcclxuICAgICAgZGVsZXRlIGhlYWRlcnNbaGVhZGVyXTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIChsYXN0VmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIGxhc3RWYWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikgP1xyXG4gICAgdW5kZWZpbmVkIDogU3RyaW5nKGxhc3RWYWx1ZSkudHJpbSgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVFcnJvclR5cGUoY29kZSwgbWVzc2FnZSwgYmFzZUNsYXNzKSB7XHJcbiAgLy8gQ3JlYXRlIGNvbnN0cnVjdG9yXHJcbiAgZnVuY3Rpb24gQ3VzdG9tRXJyb3IocHJvcGVydGllcykge1xyXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BlcnRpZXMgfHwge30pO1xyXG4gICAgdGhpcy5jb2RlID0gY29kZTtcclxuICAgIHRoaXMubWVzc2FnZSA9IHRoaXMuY2F1c2UgPyBtZXNzYWdlICsgXCI6IFwiICsgdGhpcy5jYXVzZS5tZXNzYWdlIDogbWVzc2FnZTtcclxuICB9XHJcblxyXG4gIC8vIEF0dGFjaCBjb25zdHJ1Y3RvciBhbmQgc2V0IGRlZmF1bHQgcHJvcGVydGllc1xyXG4gIEN1c3RvbUVycm9yLnByb3RvdHlwZSA9IG5ldyAoYmFzZUNsYXNzIHx8IEVycm9yKSgpO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEN1c3RvbUVycm9yLnByb3RvdHlwZSwge1xyXG4gICAgY29uc3RydWN0b3I6IHtcclxuICAgICAgdmFsdWU6IEN1c3RvbUVycm9yLFxyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgIH0sXHJcbiAgICBuYW1lOiB7XHJcbiAgICAgIHZhbHVlOiBcIkVycm9yIFtcIiArIGNvZGUgKyBcIl1cIixcclxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICB9LFxyXG4gIH0pO1xyXG4gIHJldHVybiBDdXN0b21FcnJvcjtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVzdHJveVJlcXVlc3QocmVxdWVzdCwgZXJyb3IpIHtcclxuICBmb3IgKHZhciBldmVudCBvZiBldmVudHMpIHtcclxuICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGV2ZW50SGFuZGxlcnNbZXZlbnRdKTtcclxuICB9XHJcbiAgcmVxdWVzdC5vbihcImVycm9yXCIsIG5vb3ApO1xyXG4gIHJlcXVlc3QuZGVzdHJveShlcnJvcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzU3ViZG9tYWluKHN1YmRvbWFpbiwgZG9tYWluKSB7XHJcbiAgYXNzZXJ0KGlzU3RyaW5nKHN1YmRvbWFpbikgJiYgaXNTdHJpbmcoZG9tYWluKSk7XHJcbiAgdmFyIGRvdCA9IHN1YmRvbWFpbi5sZW5ndGggLSBkb21haW4ubGVuZ3RoIC0gMTtcclxuICByZXR1cm4gZG90ID4gMCAmJiBzdWJkb21haW5bZG90XSA9PT0gXCIuXCIgJiYgc3ViZG9tYWluLmVuZHNXaXRoKGRvbWFpbik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcclxufVxyXG5cclxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xyXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNCdWZmZXIodmFsdWUpIHtcclxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIChcImxlbmd0aFwiIGluIHZhbHVlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNVUkwodmFsdWUpIHtcclxuICByZXR1cm4gVVJMICYmIHZhbHVlIGluc3RhbmNlb2YgVVJMO1xyXG59XHJcblxyXG4vLyBFeHBvcnRzXHJcbm1vZHVsZS5leHBvcnRzID0gd3JhcCh7IGh0dHA6IGh0dHAsIGh0dHBzOiBodHRwcyB9KTtcclxubW9kdWxlLmV4cG9ydHMud3JhcCA9IHdyYXA7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/follow-redirects/index.js\n");

/***/ })

};
;