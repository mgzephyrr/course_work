"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tanstack";
exports.ids = ["vendor-chunks/@tanstack"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tanstack/react-table/build/lib/index.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@tanstack/react-table/build/lib/index.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnFaceting: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnFaceting),\n/* harmony export */   ColumnFiltering: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnFiltering),\n/* harmony export */   ColumnGrouping: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnGrouping),\n/* harmony export */   ColumnOrdering: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnOrdering),\n/* harmony export */   ColumnPinning: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnPinning),\n/* harmony export */   ColumnSizing: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnSizing),\n/* harmony export */   ColumnVisibility: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnVisibility),\n/* harmony export */   GlobalFaceting: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.GlobalFaceting),\n/* harmony export */   GlobalFiltering: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.GlobalFiltering),\n/* harmony export */   Headers: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Headers),\n/* harmony export */   RowExpanding: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowExpanding),\n/* harmony export */   RowPagination: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowPagination),\n/* harmony export */   RowPinning: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowPinning),\n/* harmony export */   RowSelection: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowSelection),\n/* harmony export */   RowSorting: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowSorting),\n/* harmony export */   _getVisibleLeafColumns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__._getVisibleLeafColumns),\n/* harmony export */   aggregationFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.aggregationFns),\n/* harmony export */   buildHeaderGroups: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.buildHeaderGroups),\n/* harmony export */   createCell: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createCell),\n/* harmony export */   createColumn: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createColumn),\n/* harmony export */   createColumnHelper: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createColumnHelper),\n/* harmony export */   createRow: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createRow),\n/* harmony export */   createTable: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createTable),\n/* harmony export */   defaultColumnSizing: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.defaultColumnSizing),\n/* harmony export */   expandRows: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.expandRows),\n/* harmony export */   filterFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.filterFns),\n/* harmony export */   flattenBy: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.flattenBy),\n/* harmony export */   flexRender: () => (/* binding */ flexRender),\n/* harmony export */   functionalUpdate: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.functionalUpdate),\n/* harmony export */   getCoreRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getCoreRowModel),\n/* harmony export */   getExpandedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getExpandedRowModel),\n/* harmony export */   getFacetedMinMaxValues: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedMinMaxValues),\n/* harmony export */   getFacetedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedRowModel),\n/* harmony export */   getFacetedUniqueValues: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedUniqueValues),\n/* harmony export */   getFilteredRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFilteredRowModel),\n/* harmony export */   getGroupedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getGroupedRowModel),\n/* harmony export */   getMemoOptions: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getMemoOptions),\n/* harmony export */   getPaginationRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getPaginationRowModel),\n/* harmony export */   getSortedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getSortedRowModel),\n/* harmony export */   isFunction: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isFunction),\n/* harmony export */   isNumberArray: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isNumberArray),\n/* harmony export */   isRowSelected: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isRowSelected),\n/* harmony export */   isSubRowSelected: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isSubRowSelected),\n/* harmony export */   makeStateUpdater: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.makeStateUpdater),\n/* harmony export */   memo: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.memo),\n/* harmony export */   noop: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.noop),\n/* harmony export */   orderColumns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.orderColumns),\n/* harmony export */   passiveEventSupported: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.passiveEventSupported),\n/* harmony export */   reSplitAlphaNumeric: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.reSplitAlphaNumeric),\n/* harmony export */   selectRowsFn: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.selectRowsFn),\n/* harmony export */   shouldAutoRemoveFilter: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.shouldAutoRemoveFilter),\n/* harmony export */   sortingFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.sortingFns),\n/* harmony export */   useReactTable: () => (/* binding */ useReactTable)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tanstack/table-core */ \"(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs\");\n/**\r\n   * react-table\r\n   *\r\n   * Copyright (c) TanStack\r\n   *\r\n   * This source code is licensed under the MIT license found in the\r\n   * LICENSE.md file in the root directory of this source tree.\r\n   *\r\n   * @license MIT\r\n   */\r\n\r\n\r\n\r\n\r\n//\r\n\r\n/**\r\n * If rendering headers, cells, or footers with custom markup, use flexRender instead of `cell.getValue()` or `cell.renderValue()`.\r\n */\r\nfunction flexRender(Comp, props) {\r\n  return !Comp ? null : isReactComponent(Comp) ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Comp, props) : Comp;\r\n}\r\nfunction isReactComponent(component) {\r\n  return isClassComponent(component) || typeof component === 'function' || isExoticComponent(component);\r\n}\r\nfunction isClassComponent(component) {\r\n  return typeof component === 'function' && (() => {\r\n    const proto = Object.getPrototypeOf(component);\r\n    return proto.prototype && proto.prototype.isReactComponent;\r\n  })();\r\n}\r\nfunction isExoticComponent(component) {\r\n  return typeof component === 'object' && typeof component.$$typeof === 'symbol' && ['react.memo', 'react.forward_ref'].includes(component.$$typeof.description);\r\n}\r\nfunction useReactTable(options) {\r\n  // Compose in the generic options to the user options\r\n  const resolvedOptions = {\r\n    state: {},\r\n    // Dummy state\r\n    onStateChange: () => {},\r\n    // noop\r\n    renderFallbackValue: null,\r\n    ...options\r\n  };\r\n\r\n  // Create a new table and store it in state\r\n  const [tableRef] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => ({\r\n    current: (0,_tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createTable)(resolvedOptions)\r\n  }));\r\n\r\n  // By default, manage table state here using the table's initial state\r\n  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => tableRef.current.initialState);\r\n\r\n  // Compose the default state above with any user state. This will allow the user\r\n  // to only control a subset of the state if desired.\r\n  tableRef.current.setOptions(prev => ({\r\n    ...prev,\r\n    ...options,\r\n    state: {\r\n      ...state,\r\n      ...options.state\r\n    },\r\n    // Similarly, we'll maintain both our internal state and any user-provided\r\n    // state.\r\n    onStateChange: updater => {\r\n      setState(updater);\r\n      options.onStateChange == null || options.onStateChange(updater);\r\n    }\r\n  }));\r\n  return tableRef.current;\r\n}\r\n\r\n\r\n//# sourceMappingURL=index.mjs.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXRhYmxlL2J1aWxkL2xpYi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQytCO0FBQ29CO0FBQ2Q7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsZ0RBQW1CO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJDQUFjO0FBQ25DLGFBQWEsaUVBQVc7QUFDeEIsR0FBRztBQUNIO0FBQ0E7QUFDQSw0QkFBNEIsMkNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDcUM7QUFDckMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXN0X2NvdXJzZS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtdGFibGUvYnVpbGQvbGliL2luZGV4Lm1qcz83MzIyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gICAqIHJlYWN0LXRhYmxlXHJcbiAgICpcclxuICAgKiBDb3B5cmlnaHQgKGMpIFRhblN0YWNrXHJcbiAgICpcclxuICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICAgKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAgICpcclxuICAgKiBAbGljZW5zZSBNSVRcclxuICAgKi9cclxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBjcmVhdGVUYWJsZSB9IGZyb20gJ0B0YW5zdGFjay90YWJsZS1jb3JlJztcclxuZXhwb3J0ICogZnJvbSAnQHRhbnN0YWNrL3RhYmxlLWNvcmUnO1xyXG5cclxuLy9cclxuXHJcbi8qKlxyXG4gKiBJZiByZW5kZXJpbmcgaGVhZGVycywgY2VsbHMsIG9yIGZvb3RlcnMgd2l0aCBjdXN0b20gbWFya3VwLCB1c2UgZmxleFJlbmRlciBpbnN0ZWFkIG9mIGBjZWxsLmdldFZhbHVlKClgIG9yIGBjZWxsLnJlbmRlclZhbHVlKClgLlxyXG4gKi9cclxuZnVuY3Rpb24gZmxleFJlbmRlcihDb21wLCBwcm9wcykge1xyXG4gIHJldHVybiAhQ29tcCA/IG51bGwgOiBpc1JlYWN0Q29tcG9uZW50KENvbXApID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcCwgcHJvcHMpIDogQ29tcDtcclxufVxyXG5mdW5jdGlvbiBpc1JlYWN0Q29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gIHJldHVybiBpc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkgfHwgdHlwZW9mIGNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyB8fCBpc0V4b3RpY0NvbXBvbmVudChjb21wb25lbnQpO1xyXG59XHJcbmZ1bmN0aW9uIGlzQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBjb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgKCgpID0+IHtcclxuICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGNvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gcHJvdG8ucHJvdG90eXBlICYmIHByb3RvLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50O1xyXG4gIH0pKCk7XHJcbn1cclxuZnVuY3Rpb24gaXNFeG90aWNDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb21wb25lbnQuJCR0eXBlb2YgPT09ICdzeW1ib2wnICYmIFsncmVhY3QubWVtbycsICdyZWFjdC5mb3J3YXJkX3JlZiddLmluY2x1ZGVzKGNvbXBvbmVudC4kJHR5cGVvZi5kZXNjcmlwdGlvbik7XHJcbn1cclxuZnVuY3Rpb24gdXNlUmVhY3RUYWJsZShvcHRpb25zKSB7XHJcbiAgLy8gQ29tcG9zZSBpbiB0aGUgZ2VuZXJpYyBvcHRpb25zIHRvIHRoZSB1c2VyIG9wdGlvbnNcclxuICBjb25zdCByZXNvbHZlZE9wdGlvbnMgPSB7XHJcbiAgICBzdGF0ZToge30sXHJcbiAgICAvLyBEdW1teSBzdGF0ZVxyXG4gICAgb25TdGF0ZUNoYW5nZTogKCkgPT4ge30sXHJcbiAgICAvLyBub29wXHJcbiAgICByZW5kZXJGYWxsYmFja1ZhbHVlOiBudWxsLFxyXG4gICAgLi4ub3B0aW9uc1xyXG4gIH07XHJcblxyXG4gIC8vIENyZWF0ZSBhIG5ldyB0YWJsZSBhbmQgc3RvcmUgaXQgaW4gc3RhdGVcclxuICBjb25zdCBbdGFibGVSZWZdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gKHtcclxuICAgIGN1cnJlbnQ6IGNyZWF0ZVRhYmxlKHJlc29sdmVkT3B0aW9ucylcclxuICB9KSk7XHJcblxyXG4gIC8vIEJ5IGRlZmF1bHQsIG1hbmFnZSB0YWJsZSBzdGF0ZSBoZXJlIHVzaW5nIHRoZSB0YWJsZSdzIGluaXRpYWwgc3RhdGVcclxuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IHRhYmxlUmVmLmN1cnJlbnQuaW5pdGlhbFN0YXRlKTtcclxuXHJcbiAgLy8gQ29tcG9zZSB0aGUgZGVmYXVsdCBzdGF0ZSBhYm92ZSB3aXRoIGFueSB1c2VyIHN0YXRlLiBUaGlzIHdpbGwgYWxsb3cgdGhlIHVzZXJcclxuICAvLyB0byBvbmx5IGNvbnRyb2wgYSBzdWJzZXQgb2YgdGhlIHN0YXRlIGlmIGRlc2lyZWQuXHJcbiAgdGFibGVSZWYuY3VycmVudC5zZXRPcHRpb25zKHByZXYgPT4gKHtcclxuICAgIC4uLnByZXYsXHJcbiAgICAuLi5vcHRpb25zLFxyXG4gICAgc3RhdGU6IHtcclxuICAgICAgLi4uc3RhdGUsXHJcbiAgICAgIC4uLm9wdGlvbnMuc3RhdGVcclxuICAgIH0sXHJcbiAgICAvLyBTaW1pbGFybHksIHdlJ2xsIG1haW50YWluIGJvdGggb3VyIGludGVybmFsIHN0YXRlIGFuZCBhbnkgdXNlci1wcm92aWRlZFxyXG4gICAgLy8gc3RhdGUuXHJcbiAgICBvblN0YXRlQ2hhbmdlOiB1cGRhdGVyID0+IHtcclxuICAgICAgc2V0U3RhdGUodXBkYXRlcik7XHJcbiAgICAgIG9wdGlvbnMub25TdGF0ZUNoYW5nZSA9PSBudWxsIHx8IG9wdGlvbnMub25TdGF0ZUNoYW5nZSh1cGRhdGVyKTtcclxuICAgIH1cclxuICB9KSk7XHJcbiAgcmV0dXJuIHRhYmxlUmVmLmN1cnJlbnQ7XHJcbn1cclxuXHJcbmV4cG9ydCB7IGZsZXhSZW5kZXIsIHVzZVJlYWN0VGFibGUgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/react-table/build/lib/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/table-core/build/lib/index.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnFaceting: () => (/* binding */ ColumnFaceting),\n/* harmony export */   ColumnFiltering: () => (/* binding */ ColumnFiltering),\n/* harmony export */   ColumnGrouping: () => (/* binding */ ColumnGrouping),\n/* harmony export */   ColumnOrdering: () => (/* binding */ ColumnOrdering),\n/* harmony export */   ColumnPinning: () => (/* binding */ ColumnPinning),\n/* harmony export */   ColumnSizing: () => (/* binding */ ColumnSizing),\n/* harmony export */   ColumnVisibility: () => (/* binding */ ColumnVisibility),\n/* harmony export */   GlobalFaceting: () => (/* binding */ GlobalFaceting),\n/* harmony export */   GlobalFiltering: () => (/* binding */ GlobalFiltering),\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   RowExpanding: () => (/* binding */ RowExpanding),\n/* harmony export */   RowPagination: () => (/* binding */ RowPagination),\n/* harmony export */   RowPinning: () => (/* binding */ RowPinning),\n/* harmony export */   RowSelection: () => (/* binding */ RowSelection),\n/* harmony export */   RowSorting: () => (/* binding */ RowSorting),\n/* harmony export */   _getVisibleLeafColumns: () => (/* binding */ _getVisibleLeafColumns),\n/* harmony export */   aggregationFns: () => (/* binding */ aggregationFns),\n/* harmony export */   buildHeaderGroups: () => (/* binding */ buildHeaderGroups),\n/* harmony export */   createCell: () => (/* binding */ createCell),\n/* harmony export */   createColumn: () => (/* binding */ createColumn),\n/* harmony export */   createColumnHelper: () => (/* binding */ createColumnHelper),\n/* harmony export */   createRow: () => (/* binding */ createRow),\n/* harmony export */   createTable: () => (/* binding */ createTable),\n/* harmony export */   defaultColumnSizing: () => (/* binding */ defaultColumnSizing),\n/* harmony export */   expandRows: () => (/* binding */ expandRows),\n/* harmony export */   filterFns: () => (/* binding */ filterFns),\n/* harmony export */   flattenBy: () => (/* binding */ flattenBy),\n/* harmony export */   functionalUpdate: () => (/* binding */ functionalUpdate),\n/* harmony export */   getCoreRowModel: () => (/* binding */ getCoreRowModel),\n/* harmony export */   getExpandedRowModel: () => (/* binding */ getExpandedRowModel),\n/* harmony export */   getFacetedMinMaxValues: () => (/* binding */ getFacetedMinMaxValues),\n/* harmony export */   getFacetedRowModel: () => (/* binding */ getFacetedRowModel),\n/* harmony export */   getFacetedUniqueValues: () => (/* binding */ getFacetedUniqueValues),\n/* harmony export */   getFilteredRowModel: () => (/* binding */ getFilteredRowModel),\n/* harmony export */   getGroupedRowModel: () => (/* binding */ getGroupedRowModel),\n/* harmony export */   getMemoOptions: () => (/* binding */ getMemoOptions),\n/* harmony export */   getPaginationRowModel: () => (/* binding */ getPaginationRowModel),\n/* harmony export */   getSortedRowModel: () => (/* binding */ getSortedRowModel),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isNumberArray: () => (/* binding */ isNumberArray),\n/* harmony export */   isRowSelected: () => (/* binding */ isRowSelected),\n/* harmony export */   isSubRowSelected: () => (/* binding */ isSubRowSelected),\n/* harmony export */   makeStateUpdater: () => (/* binding */ makeStateUpdater),\n/* harmony export */   memo: () => (/* binding */ memo),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   orderColumns: () => (/* binding */ orderColumns),\n/* harmony export */   passiveEventSupported: () => (/* binding */ passiveEventSupported),\n/* harmony export */   reSplitAlphaNumeric: () => (/* binding */ reSplitAlphaNumeric),\n/* harmony export */   selectRowsFn: () => (/* binding */ selectRowsFn),\n/* harmony export */   shouldAutoRemoveFilter: () => (/* binding */ shouldAutoRemoveFilter),\n/* harmony export */   sortingFns: () => (/* binding */ sortingFns)\n/* harmony export */ });\n/**\r\n   * table-core\r\n   *\r\n   * Copyright (c) TanStack\r\n   *\r\n   * This source code is licensed under the MIT license found in the\r\n   * LICENSE.md file in the root directory of this source tree.\r\n   *\r\n   * @license MIT\r\n   */\r\n// type Person = {\r\n//   firstName: string\r\n//   lastName: string\r\n//   age: number\r\n//   visits: number\r\n//   status: string\r\n//   progress: number\r\n//   createdAt: Date\r\n//   nested: {\r\n//     foo: [\r\n//       {\r\n//         bar: 'bar'\r\n//       }\r\n//     ]\r\n//     bar: { subBar: boolean }[]\r\n//     baz: {\r\n//       foo: 'foo'\r\n//       bar: {\r\n//         baz: 'baz'\r\n//       }\r\n//     }\r\n//   }\r\n// }\r\n\r\n// const test: DeepKeys<Person> = 'nested.foo.0.bar'\r\n// const test2: DeepKeys<Person> = 'nested.bar'\r\n\r\n// const helper = createColumnHelper<Person>()\r\n\r\n// helper.accessor('nested.foo', {\r\n//   cell: info => info.getValue(),\r\n// })\r\n\r\n// helper.accessor('nested.foo.0.bar', {\r\n//   cell: info => info.getValue(),\r\n// })\r\n\r\n// helper.accessor('nested.bar', {\r\n//   cell: info => info.getValue(),\r\n// })\r\n\r\nfunction createColumnHelper() {\r\n  return {\r\n    accessor: (accessor, column) => {\r\n      return typeof accessor === 'function' ? {\r\n        ...column,\r\n        accessorFn: accessor\r\n      } : {\r\n        ...column,\r\n        accessorKey: accessor\r\n      };\r\n    },\r\n    display: column => column,\r\n    group: column => column\r\n  };\r\n}\r\n\r\n// Is this type a tuple?\r\n\r\n// If this type is a tuple, what indices are allowed?\r\n\r\n///\r\n\r\nfunction functionalUpdate(updater, input) {\r\n  return typeof updater === 'function' ? updater(input) : updater;\r\n}\r\nfunction noop() {\r\n  //\r\n}\r\nfunction makeStateUpdater(key, instance) {\r\n  return updater => {\r\n    instance.setState(old => {\r\n      return {\r\n        ...old,\r\n        [key]: functionalUpdate(updater, old[key])\r\n      };\r\n    });\r\n  };\r\n}\r\nfunction isFunction(d) {\r\n  return d instanceof Function;\r\n}\r\nfunction isNumberArray(d) {\r\n  return Array.isArray(d) && d.every(val => typeof val === 'number');\r\n}\r\nfunction flattenBy(arr, getChildren) {\r\n  const flat = [];\r\n  const recurse = subArr => {\r\n    subArr.forEach(item => {\r\n      flat.push(item);\r\n      const children = getChildren(item);\r\n      if (children != null && children.length) {\r\n        recurse(children);\r\n      }\r\n    });\r\n  };\r\n  recurse(arr);\r\n  return flat;\r\n}\r\nfunction memo(getDeps, fn, opts) {\r\n  let deps = [];\r\n  let result;\r\n  return depArgs => {\r\n    let depTime;\r\n    if (opts.key && opts.debug) depTime = Date.now();\r\n    const newDeps = getDeps(depArgs);\r\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);\r\n    if (!depsChanged) {\r\n      return result;\r\n    }\r\n    deps = newDeps;\r\n    let resultTime;\r\n    if (opts.key && opts.debug) resultTime = Date.now();\r\n    result = fn(...newDeps);\r\n    opts == null || opts.onChange == null || opts.onChange(result);\r\n    if (opts.key && opts.debug) {\r\n      if (opts != null && opts.debug()) {\r\n        const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\r\n        const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\r\n        const resultFpsPercentage = resultEndTime / 16;\r\n        const pad = (str, num) => {\r\n          str = String(str);\r\n          while (str.length < num) {\r\n            str = ' ' + str;\r\n          }\r\n          return str;\r\n        };\r\n        console.info(`%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `\r\n            font-size: .6rem;\r\n            font-weight: bold;\r\n            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);\r\n      }\r\n    }\r\n    return result;\r\n  };\r\n}\r\nfunction getMemoOptions(tableOptions, debugLevel, key, onChange) {\r\n  return {\r\n    debug: () => {\r\n      var _tableOptions$debugAl;\r\n      return (_tableOptions$debugAl = tableOptions == null ? void 0 : tableOptions.debugAll) != null ? _tableOptions$debugAl : tableOptions[debugLevel];\r\n    },\r\n    key:  true && key,\r\n    onChange\r\n  };\r\n}\r\n\r\nfunction createCell(table, row, column, columnId) {\r\n  const getRenderValue = () => {\r\n    var _cell$getValue;\r\n    return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;\r\n  };\r\n  const cell = {\r\n    id: `${row.id}_${column.id}`,\r\n    row,\r\n    column,\r\n    getValue: () => row.getValue(columnId),\r\n    renderValue: getRenderValue,\r\n    getContext: memo(() => [table, column, row, cell], (table, column, row, cell) => ({\r\n      table,\r\n      column,\r\n      row,\r\n      cell: cell,\r\n      getValue: cell.getValue,\r\n      renderValue: cell.renderValue\r\n    }), getMemoOptions(table.options, 'debugCells', 'cell.getContext'))\r\n  };\r\n  table._features.forEach(feature => {\r\n    feature.createCell == null || feature.createCell(cell, column, row, table);\r\n  }, {});\r\n  return cell;\r\n}\r\n\r\nfunction createColumn(table, columnDef, depth, parent) {\r\n  var _ref, _resolvedColumnDef$id;\r\n  const defaultColumn = table._getDefaultColumnDef();\r\n  const resolvedColumnDef = {\r\n    ...defaultColumn,\r\n    ...columnDef\r\n  };\r\n  const accessorKey = resolvedColumnDef.accessorKey;\r\n  let id = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? accessorKey.replace('.', '_') : undefined) != null ? _ref : typeof resolvedColumnDef.header === 'string' ? resolvedColumnDef.header : undefined;\r\n  let accessorFn;\r\n  if (resolvedColumnDef.accessorFn) {\r\n    accessorFn = resolvedColumnDef.accessorFn;\r\n  } else if (accessorKey) {\r\n    // Support deep accessor keys\r\n    if (accessorKey.includes('.')) {\r\n      accessorFn = originalRow => {\r\n        let result = originalRow;\r\n        for (const key of accessorKey.split('.')) {\r\n          var _result;\r\n          result = (_result = result) == null ? void 0 : _result[key];\r\n          if ( true && result === undefined) {\r\n            console.warn(`\"${key}\" in deeply nested key \"${accessorKey}\" returned undefined.`);\r\n          }\r\n        }\r\n        return result;\r\n      };\r\n    } else {\r\n      accessorFn = originalRow => originalRow[resolvedColumnDef.accessorKey];\r\n    }\r\n  }\r\n  if (!id) {\r\n    if (true) {\r\n      throw new Error(resolvedColumnDef.accessorFn ? `Columns require an id when using an accessorFn` : `Columns require an id when using a non-string header`);\r\n    }\r\n    throw new Error();\r\n  }\r\n  let column = {\r\n    id: `${String(id)}`,\r\n    accessorFn,\r\n    parent: parent,\r\n    depth,\r\n    columnDef: resolvedColumnDef,\r\n    columns: [],\r\n    getFlatColumns: memo(() => [true], () => {\r\n      var _column$columns;\r\n      return [column, ...((_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap(d => d.getFlatColumns()))];\r\n    }, getMemoOptions(table.options, 'debugColumns', 'column.getFlatColumns')),\r\n    getLeafColumns: memo(() => [table._getOrderColumnsFn()], orderColumns => {\r\n      var _column$columns2;\r\n      if ((_column$columns2 = column.columns) != null && _column$columns2.length) {\r\n        let leafColumns = column.columns.flatMap(column => column.getLeafColumns());\r\n        return orderColumns(leafColumns);\r\n      }\r\n      return [column];\r\n    }, getMemoOptions(table.options, 'debugColumns', 'column.getLeafColumns'))\r\n  };\r\n  for (const feature of table._features) {\r\n    feature.createColumn == null || feature.createColumn(column, table);\r\n  }\r\n\r\n  // Yes, we have to convert table to unknown, because we know more than the compiler here.\r\n  return column;\r\n}\r\n\r\nconst debug = 'debugHeaders';\r\n//\r\n\r\nfunction createHeader(table, column, options) {\r\n  var _options$id;\r\n  const id = (_options$id = options.id) != null ? _options$id : column.id;\r\n  let header = {\r\n    id,\r\n    column,\r\n    index: options.index,\r\n    isPlaceholder: !!options.isPlaceholder,\r\n    placeholderId: options.placeholderId,\r\n    depth: options.depth,\r\n    subHeaders: [],\r\n    colSpan: 0,\r\n    rowSpan: 0,\r\n    headerGroup: null,\r\n    getLeafHeaders: () => {\r\n      const leafHeaders = [];\r\n      const recurseHeader = h => {\r\n        if (h.subHeaders && h.subHeaders.length) {\r\n          h.subHeaders.map(recurseHeader);\r\n        }\r\n        leafHeaders.push(h);\r\n      };\r\n      recurseHeader(header);\r\n      return leafHeaders;\r\n    },\r\n    getContext: () => ({\r\n      table,\r\n      header: header,\r\n      column\r\n    })\r\n  };\r\n  table._features.forEach(feature => {\r\n    feature.createHeader == null || feature.createHeader(header, table);\r\n  });\r\n  return header;\r\n}\r\nconst Headers = {\r\n  createTable: table => {\r\n    // Header Groups\r\n\r\n    table.getHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {\r\n      var _left$map$filter, _right$map$filter;\r\n      const leftColumns = (_left$map$filter = left == null ? void 0 : left.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];\r\n      const rightColumns = (_right$map$filter = right == null ? void 0 : right.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];\r\n      const centerColumns = leafColumns.filter(column => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\r\n      const headerGroups = buildHeaderGroups(allColumns, [...leftColumns, ...centerColumns, ...rightColumns], table);\r\n      return headerGroups;\r\n    }, getMemoOptions(table.options, debug, 'getHeaderGroups'));\r\n    table.getCenterHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {\r\n      leafColumns = leafColumns.filter(column => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\r\n      return buildHeaderGroups(allColumns, leafColumns, table, 'center');\r\n    }, getMemoOptions(table.options, debug, 'getCenterHeaderGroups'));\r\n    table.getLeftHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left], (allColumns, leafColumns, left) => {\r\n      var _left$map$filter2;\r\n      const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];\r\n      return buildHeaderGroups(allColumns, orderedLeafColumns, table, 'left');\r\n    }, getMemoOptions(table.options, debug, 'getLeftHeaderGroups'));\r\n    table.getRightHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.right], (allColumns, leafColumns, right) => {\r\n      var _right$map$filter2;\r\n      const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];\r\n      return buildHeaderGroups(allColumns, orderedLeafColumns, table, 'right');\r\n    }, getMemoOptions(table.options, debug, 'getRightHeaderGroups'));\r\n\r\n    // Footer Groups\r\n\r\n    table.getFooterGroups = memo(() => [table.getHeaderGroups()], headerGroups => {\r\n      return [...headerGroups].reverse();\r\n    }, getMemoOptions(table.options, debug, 'getFooterGroups'));\r\n    table.getLeftFooterGroups = memo(() => [table.getLeftHeaderGroups()], headerGroups => {\r\n      return [...headerGroups].reverse();\r\n    }, getMemoOptions(table.options, debug, 'getLeftFooterGroups'));\r\n    table.getCenterFooterGroups = memo(() => [table.getCenterHeaderGroups()], headerGroups => {\r\n      return [...headerGroups].reverse();\r\n    }, getMemoOptions(table.options, debug, 'getCenterFooterGroups'));\r\n    table.getRightFooterGroups = memo(() => [table.getRightHeaderGroups()], headerGroups => {\r\n      return [...headerGroups].reverse();\r\n    }, getMemoOptions(table.options, debug, 'getRightFooterGroups'));\r\n\r\n    // Flat Headers\r\n\r\n    table.getFlatHeaders = memo(() => [table.getHeaderGroups()], headerGroups => {\r\n      return headerGroups.map(headerGroup => {\r\n        return headerGroup.headers;\r\n      }).flat();\r\n    }, getMemoOptions(table.options, debug, 'getFlatHeaders'));\r\n    table.getLeftFlatHeaders = memo(() => [table.getLeftHeaderGroups()], left => {\r\n      return left.map(headerGroup => {\r\n        return headerGroup.headers;\r\n      }).flat();\r\n    }, getMemoOptions(table.options, debug, 'getLeftFlatHeaders'));\r\n    table.getCenterFlatHeaders = memo(() => [table.getCenterHeaderGroups()], left => {\r\n      return left.map(headerGroup => {\r\n        return headerGroup.headers;\r\n      }).flat();\r\n    }, getMemoOptions(table.options, debug, 'getCenterFlatHeaders'));\r\n    table.getRightFlatHeaders = memo(() => [table.getRightHeaderGroups()], left => {\r\n      return left.map(headerGroup => {\r\n        return headerGroup.headers;\r\n      }).flat();\r\n    }, getMemoOptions(table.options, debug, 'getRightFlatHeaders'));\r\n\r\n    // Leaf Headers\r\n\r\n    table.getCenterLeafHeaders = memo(() => [table.getCenterFlatHeaders()], flatHeaders => {\r\n      return flatHeaders.filter(header => {\r\n        var _header$subHeaders;\r\n        return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);\r\n      });\r\n    }, getMemoOptions(table.options, debug, 'getCenterLeafHeaders'));\r\n    table.getLeftLeafHeaders = memo(() => [table.getLeftFlatHeaders()], flatHeaders => {\r\n      return flatHeaders.filter(header => {\r\n        var _header$subHeaders2;\r\n        return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);\r\n      });\r\n    }, getMemoOptions(table.options, debug, 'getLeftLeafHeaders'));\r\n    table.getRightLeafHeaders = memo(() => [table.getRightFlatHeaders()], flatHeaders => {\r\n      return flatHeaders.filter(header => {\r\n        var _header$subHeaders3;\r\n        return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);\r\n      });\r\n    }, getMemoOptions(table.options, debug, 'getRightLeafHeaders'));\r\n    table.getLeafHeaders = memo(() => [table.getLeftHeaderGroups(), table.getCenterHeaderGroups(), table.getRightHeaderGroups()], (left, center, right) => {\r\n      var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;\r\n      return [...((_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : []), ...((_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : []), ...((_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : [])].map(header => {\r\n        return header.getLeafHeaders();\r\n      }).flat();\r\n    }, getMemoOptions(table.options, debug, 'getLeafHeaders'));\r\n  }\r\n};\r\nfunction buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {\r\n  var _headerGroups$0$heade, _headerGroups$;\r\n  // Find the max depth of the columns:\r\n  // build the leaf column row\r\n  // build each buffer row going up\r\n  //    placeholder for non-existent level\r\n  //    real column for existing level\r\n\r\n  let maxDepth = 0;\r\n  const findMaxDepth = function (columns, depth) {\r\n    if (depth === void 0) {\r\n      depth = 1;\r\n    }\r\n    maxDepth = Math.max(maxDepth, depth);\r\n    columns.filter(column => column.getIsVisible()).forEach(column => {\r\n      var _column$columns;\r\n      if ((_column$columns = column.columns) != null && _column$columns.length) {\r\n        findMaxDepth(column.columns, depth + 1);\r\n      }\r\n    }, 0);\r\n  };\r\n  findMaxDepth(allColumns);\r\n  let headerGroups = [];\r\n  const createHeaderGroup = (headersToGroup, depth) => {\r\n    // The header group we are creating\r\n    const headerGroup = {\r\n      depth,\r\n      id: [headerFamily, `${depth}`].filter(Boolean).join('_'),\r\n      headers: []\r\n    };\r\n\r\n    // The parent columns we're going to scan next\r\n    const pendingParentHeaders = [];\r\n\r\n    // Scan each column for parents\r\n    headersToGroup.forEach(headerToGroup => {\r\n      // What is the latest (last) parent column?\r\n\r\n      const latestPendingParentHeader = [...pendingParentHeaders].reverse()[0];\r\n      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;\r\n      let column;\r\n      let isPlaceholder = false;\r\n      if (isLeafHeader && headerToGroup.column.parent) {\r\n        // The parent header is new\r\n        column = headerToGroup.column.parent;\r\n      } else {\r\n        // The parent header is repeated\r\n        column = headerToGroup.column;\r\n        isPlaceholder = true;\r\n      }\r\n      if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {\r\n        // This column is repeated. Add it as a sub header to the next batch\r\n        latestPendingParentHeader.subHeaders.push(headerToGroup);\r\n      } else {\r\n        // This is a new header. Let's create it\r\n        const header = createHeader(table, column, {\r\n          id: [headerFamily, depth, column.id, headerToGroup == null ? void 0 : headerToGroup.id].filter(Boolean).join('_'),\r\n          isPlaceholder,\r\n          placeholderId: isPlaceholder ? `${pendingParentHeaders.filter(d => d.column === column).length}` : undefined,\r\n          depth,\r\n          index: pendingParentHeaders.length\r\n        });\r\n\r\n        // Add the headerToGroup as a subHeader of the new header\r\n        header.subHeaders.push(headerToGroup);\r\n        // Add the new header to the pendingParentHeaders to get grouped\r\n        // in the next batch\r\n        pendingParentHeaders.push(header);\r\n      }\r\n      headerGroup.headers.push(headerToGroup);\r\n      headerToGroup.headerGroup = headerGroup;\r\n    });\r\n    headerGroups.push(headerGroup);\r\n    if (depth > 0) {\r\n      createHeaderGroup(pendingParentHeaders, depth - 1);\r\n    }\r\n  };\r\n  const bottomHeaders = columnsToGroup.map((column, index) => createHeader(table, column, {\r\n    depth: maxDepth,\r\n    index\r\n  }));\r\n  createHeaderGroup(bottomHeaders, maxDepth - 1);\r\n  headerGroups.reverse();\r\n\r\n  // headerGroups = headerGroups.filter(headerGroup => {\r\n  //   return !headerGroup.headers.every(header => header.isPlaceholder)\r\n  // })\r\n\r\n  const recurseHeadersForSpans = headers => {\r\n    const filteredHeaders = headers.filter(header => header.column.getIsVisible());\r\n    return filteredHeaders.map(header => {\r\n      let colSpan = 0;\r\n      let rowSpan = 0;\r\n      let childRowSpans = [0];\r\n      if (header.subHeaders && header.subHeaders.length) {\r\n        childRowSpans = [];\r\n        recurseHeadersForSpans(header.subHeaders).forEach(_ref => {\r\n          let {\r\n            colSpan: childColSpan,\r\n            rowSpan: childRowSpan\r\n          } = _ref;\r\n          colSpan += childColSpan;\r\n          childRowSpans.push(childRowSpan);\r\n        });\r\n      } else {\r\n        colSpan = 1;\r\n      }\r\n      const minChildRowSpan = Math.min(...childRowSpans);\r\n      rowSpan = rowSpan + minChildRowSpan;\r\n      header.colSpan = colSpan;\r\n      header.rowSpan = rowSpan;\r\n      return {\r\n        colSpan,\r\n        rowSpan\r\n      };\r\n    });\r\n  };\r\n  recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);\r\n  return headerGroups;\r\n}\r\n\r\nconst createRow = (table, id, original, rowIndex, depth, subRows, parentId) => {\r\n  let row = {\r\n    id,\r\n    index: rowIndex,\r\n    original,\r\n    depth,\r\n    parentId,\r\n    _valuesCache: {},\r\n    _uniqueValuesCache: {},\r\n    getValue: columnId => {\r\n      if (row._valuesCache.hasOwnProperty(columnId)) {\r\n        return row._valuesCache[columnId];\r\n      }\r\n      const column = table.getColumn(columnId);\r\n      if (!(column != null && column.accessorFn)) {\r\n        return undefined;\r\n      }\r\n      row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);\r\n      return row._valuesCache[columnId];\r\n    },\r\n    getUniqueValues: columnId => {\r\n      if (row._uniqueValuesCache.hasOwnProperty(columnId)) {\r\n        return row._uniqueValuesCache[columnId];\r\n      }\r\n      const column = table.getColumn(columnId);\r\n      if (!(column != null && column.accessorFn)) {\r\n        return undefined;\r\n      }\r\n      if (!column.columnDef.getUniqueValues) {\r\n        row._uniqueValuesCache[columnId] = [row.getValue(columnId)];\r\n        return row._uniqueValuesCache[columnId];\r\n      }\r\n      row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);\r\n      return row._uniqueValuesCache[columnId];\r\n    },\r\n    renderValue: columnId => {\r\n      var _row$getValue;\r\n      return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;\r\n    },\r\n    subRows: subRows != null ? subRows : [],\r\n    getLeafRows: () => flattenBy(row.subRows, d => d.subRows),\r\n    getParentRow: () => row.parentId ? table.getRow(row.parentId, true) : undefined,\r\n    getParentRows: () => {\r\n      let parentRows = [];\r\n      let currentRow = row;\r\n      while (true) {\r\n        const parentRow = currentRow.getParentRow();\r\n        if (!parentRow) break;\r\n        parentRows.push(parentRow);\r\n        currentRow = parentRow;\r\n      }\r\n      return parentRows.reverse();\r\n    },\r\n    getAllCells: memo(() => [table.getAllLeafColumns()], leafColumns => {\r\n      return leafColumns.map(column => {\r\n        return createCell(table, row, column, column.id);\r\n      });\r\n    }, getMemoOptions(table.options, 'debugRows', 'getAllCells')),\r\n    _getAllCellsByColumnId: memo(() => [row.getAllCells()], allCells => {\r\n      return allCells.reduce((acc, cell) => {\r\n        acc[cell.column.id] = cell;\r\n        return acc;\r\n      }, {});\r\n    }, getMemoOptions(table.options, 'debugRows', 'getAllCellsByColumnId'))\r\n  };\r\n  for (let i = 0; i < table._features.length; i++) {\r\n    const feature = table._features[i];\r\n    feature == null || feature.createRow == null || feature.createRow(row, table);\r\n  }\r\n  return row;\r\n};\r\n\r\n//\r\n\r\nconst ColumnFaceting = {\r\n  createColumn: (column, table) => {\r\n    column._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id);\r\n    column.getFacetedRowModel = () => {\r\n      if (!column._getFacetedRowModel) {\r\n        return table.getPreFilteredRowModel();\r\n      }\r\n      return column._getFacetedRowModel();\r\n    };\r\n    column._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id);\r\n    column.getFacetedUniqueValues = () => {\r\n      if (!column._getFacetedUniqueValues) {\r\n        return new Map();\r\n      }\r\n      return column._getFacetedUniqueValues();\r\n    };\r\n    column._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id);\r\n    column.getFacetedMinMaxValues = () => {\r\n      if (!column._getFacetedMinMaxValues) {\r\n        return undefined;\r\n      }\r\n      return column._getFacetedMinMaxValues();\r\n    };\r\n  }\r\n};\r\n\r\nconst includesString = (row, columnId, filterValue) => {\r\n  var _row$getValue;\r\n  const search = filterValue.toLowerCase();\r\n  return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search));\r\n};\r\nincludesString.autoRemove = val => testFalsey(val);\r\nconst includesStringSensitive = (row, columnId, filterValue) => {\r\n  var _row$getValue2;\r\n  return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));\r\n};\r\nincludesStringSensitive.autoRemove = val => testFalsey(val);\r\nconst equalsString = (row, columnId, filterValue) => {\r\n  var _row$getValue3;\r\n  return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());\r\n};\r\nequalsString.autoRemove = val => testFalsey(val);\r\nconst arrIncludes = (row, columnId, filterValue) => {\r\n  var _row$getValue4;\r\n  return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);\r\n};\r\narrIncludes.autoRemove = val => testFalsey(val) || !(val != null && val.length);\r\nconst arrIncludesAll = (row, columnId, filterValue) => {\r\n  return !filterValue.some(val => {\r\n    var _row$getValue5;\r\n    return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));\r\n  });\r\n};\r\narrIncludesAll.autoRemove = val => testFalsey(val) || !(val != null && val.length);\r\nconst arrIncludesSome = (row, columnId, filterValue) => {\r\n  return filterValue.some(val => {\r\n    var _row$getValue6;\r\n    return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);\r\n  });\r\n};\r\narrIncludesSome.autoRemove = val => testFalsey(val) || !(val != null && val.length);\r\nconst equals = (row, columnId, filterValue) => {\r\n  return row.getValue(columnId) === filterValue;\r\n};\r\nequals.autoRemove = val => testFalsey(val);\r\nconst weakEquals = (row, columnId, filterValue) => {\r\n  return row.getValue(columnId) == filterValue;\r\n};\r\nweakEquals.autoRemove = val => testFalsey(val);\r\nconst inNumberRange = (row, columnId, filterValue) => {\r\n  let [min, max] = filterValue;\r\n  const rowValue = row.getValue(columnId);\r\n  return rowValue >= min && rowValue <= max;\r\n};\r\ninNumberRange.resolveFilterValue = val => {\r\n  let [unsafeMin, unsafeMax] = val;\r\n  let parsedMin = typeof unsafeMin !== 'number' ? parseFloat(unsafeMin) : unsafeMin;\r\n  let parsedMax = typeof unsafeMax !== 'number' ? parseFloat(unsafeMax) : unsafeMax;\r\n  let min = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;\r\n  let max = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;\r\n  if (min > max) {\r\n    const temp = min;\r\n    min = max;\r\n    max = temp;\r\n  }\r\n  return [min, max];\r\n};\r\ninNumberRange.autoRemove = val => testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);\r\n\r\n// Export\r\n\r\nconst filterFns = {\r\n  includesString,\r\n  includesStringSensitive,\r\n  equalsString,\r\n  arrIncludes,\r\n  arrIncludesAll,\r\n  arrIncludesSome,\r\n  equals,\r\n  weakEquals,\r\n  inNumberRange\r\n};\r\n// Utils\r\n\r\nfunction testFalsey(val) {\r\n  return val === undefined || val === null || val === '';\r\n}\r\n\r\n//\r\n\r\nconst ColumnFiltering = {\r\n  getDefaultColumnDef: () => {\r\n    return {\r\n      filterFn: 'auto'\r\n    };\r\n  },\r\n  getInitialState: state => {\r\n    return {\r\n      columnFilters: [],\r\n      ...state\r\n    };\r\n  },\r\n  getDefaultOptions: table => {\r\n    return {\r\n      onColumnFiltersChange: makeStateUpdater('columnFilters', table),\r\n      filterFromLeafRows: false,\r\n      maxLeafRowFilterDepth: 100\r\n    };\r\n  },\r\n  createColumn: (column, table) => {\r\n    column.getAutoFilterFn = () => {\r\n      const firstRow = table.getCoreRowModel().flatRows[0];\r\n      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\r\n      if (typeof value === 'string') {\r\n        return filterFns.includesString;\r\n      }\r\n      if (typeof value === 'number') {\r\n        return filterFns.inNumberRange;\r\n      }\r\n      if (typeof value === 'boolean') {\r\n        return filterFns.equals;\r\n      }\r\n      if (value !== null && typeof value === 'object') {\r\n        return filterFns.equals;\r\n      }\r\n      if (Array.isArray(value)) {\r\n        return filterFns.arrIncludes;\r\n      }\r\n      return filterFns.weakEquals;\r\n    };\r\n    column.getFilterFn = () => {\r\n      var _table$options$filter, _table$options$filter2;\r\n      return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === 'auto' ? column.getAutoFilterFn() : // @ts-ignore\r\n      (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column.columnDef.filterFn];\r\n    };\r\n    column.getCanFilter = () => {\r\n      var _column$columnDef$ena, _table$options$enable, _table$options$enable2;\r\n      return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column.accessorFn;\r\n    };\r\n    column.getIsFiltered = () => column.getFilterIndex() > -1;\r\n    column.getFilterValue = () => {\r\n      var _table$getState$colum;\r\n      return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find(d => d.id === column.id)) == null ? void 0 : _table$getState$colum.value;\r\n    };\r\n    column.getFilterIndex = () => {\r\n      var _table$getState$colum2, _table$getState$colum3;\r\n      return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex(d => d.id === column.id)) != null ? _table$getState$colum2 : -1;\r\n    };\r\n    column.setFilterValue = value => {\r\n      table.setColumnFilters(old => {\r\n        const filterFn = column.getFilterFn();\r\n        const previousFilter = old == null ? void 0 : old.find(d => d.id === column.id);\r\n        const newFilter = functionalUpdate(value, previousFilter ? previousFilter.value : undefined);\r\n\r\n        //\r\n        if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {\r\n          var _old$filter;\r\n          return (_old$filter = old == null ? void 0 : old.filter(d => d.id !== column.id)) != null ? _old$filter : [];\r\n        }\r\n        const newFilterObj = {\r\n          id: column.id,\r\n          value: newFilter\r\n        };\r\n        if (previousFilter) {\r\n          var _old$map;\r\n          return (_old$map = old == null ? void 0 : old.map(d => {\r\n            if (d.id === column.id) {\r\n              return newFilterObj;\r\n            }\r\n            return d;\r\n          })) != null ? _old$map : [];\r\n        }\r\n        if (old != null && old.length) {\r\n          return [...old, newFilterObj];\r\n        }\r\n        return [newFilterObj];\r\n      });\r\n    };\r\n  },\r\n  createRow: (row, _table) => {\r\n    row.columnFilters = {};\r\n    row.columnFiltersMeta = {};\r\n  },\r\n  createTable: table => {\r\n    table.setColumnFilters = updater => {\r\n      const leafColumns = table.getAllLeafColumns();\r\n      const updateFn = old => {\r\n        var _functionalUpdate;\r\n        return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter(filter => {\r\n          const column = leafColumns.find(d => d.id === filter.id);\r\n          if (column) {\r\n            const filterFn = column.getFilterFn();\r\n            if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {\r\n              return false;\r\n            }\r\n          }\r\n          return true;\r\n        });\r\n      };\r\n      table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);\r\n    };\r\n    table.resetColumnFilters = defaultState => {\r\n      var _table$initialState$c, _table$initialState;\r\n      table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);\r\n    };\r\n    table.getPreFilteredRowModel = () => table.getCoreRowModel();\r\n    table.getFilteredRowModel = () => {\r\n      if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {\r\n        table._getFilteredRowModel = table.options.getFilteredRowModel(table);\r\n      }\r\n      if (table.options.manualFiltering || !table._getFilteredRowModel) {\r\n        return table.getPreFilteredRowModel();\r\n      }\r\n      return table._getFilteredRowModel();\r\n    };\r\n  }\r\n};\r\nfunction shouldAutoRemoveFilter(filterFn, value, column) {\r\n  return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === 'undefined' || typeof value === 'string' && !value;\r\n}\r\n\r\nconst sum = (columnId, _leafRows, childRows) => {\r\n  // It's faster to just add the aggregations together instead of\r\n  // process leaf nodes individually\r\n  return childRows.reduce((sum, next) => {\r\n    const nextValue = next.getValue(columnId);\r\n    return sum + (typeof nextValue === 'number' ? nextValue : 0);\r\n  }, 0);\r\n};\r\nconst min = (columnId, _leafRows, childRows) => {\r\n  let min;\r\n  childRows.forEach(row => {\r\n    const value = row.getValue(columnId);\r\n    if (value != null && (min > value || min === undefined && value >= value)) {\r\n      min = value;\r\n    }\r\n  });\r\n  return min;\r\n};\r\nconst max = (columnId, _leafRows, childRows) => {\r\n  let max;\r\n  childRows.forEach(row => {\r\n    const value = row.getValue(columnId);\r\n    if (value != null && (max < value || max === undefined && value >= value)) {\r\n      max = value;\r\n    }\r\n  });\r\n  return max;\r\n};\r\nconst extent = (columnId, _leafRows, childRows) => {\r\n  let min;\r\n  let max;\r\n  childRows.forEach(row => {\r\n    const value = row.getValue(columnId);\r\n    if (value != null) {\r\n      if (min === undefined) {\r\n        if (value >= value) min = max = value;\r\n      } else {\r\n        if (min > value) min = value;\r\n        if (max < value) max = value;\r\n      }\r\n    }\r\n  });\r\n  return [min, max];\r\n};\r\nconst mean = (columnId, leafRows) => {\r\n  let count = 0;\r\n  let sum = 0;\r\n  leafRows.forEach(row => {\r\n    let value = row.getValue(columnId);\r\n    if (value != null && (value = +value) >= value) {\r\n      ++count, sum += value;\r\n    }\r\n  });\r\n  if (count) return sum / count;\r\n  return;\r\n};\r\nconst median = (columnId, leafRows) => {\r\n  if (!leafRows.length) {\r\n    return;\r\n  }\r\n  const values = leafRows.map(row => row.getValue(columnId));\r\n  if (!isNumberArray(values)) {\r\n    return;\r\n  }\r\n  if (values.length === 1) {\r\n    return values[0];\r\n  }\r\n  const mid = Math.floor(values.length / 2);\r\n  const nums = values.sort((a, b) => a - b);\r\n  return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;\r\n};\r\nconst unique = (columnId, leafRows) => {\r\n  return Array.from(new Set(leafRows.map(d => d.getValue(columnId))).values());\r\n};\r\nconst uniqueCount = (columnId, leafRows) => {\r\n  return new Set(leafRows.map(d => d.getValue(columnId))).size;\r\n};\r\nconst count = (_columnId, leafRows) => {\r\n  return leafRows.length;\r\n};\r\nconst aggregationFns = {\r\n  sum,\r\n  min,\r\n  max,\r\n  extent,\r\n  mean,\r\n  median,\r\n  unique,\r\n  uniqueCount,\r\n  count\r\n};\r\n\r\n//\r\n\r\nconst ColumnGrouping = {\r\n  getDefaultColumnDef: () => {\r\n    return {\r\n      aggregatedCell: props => {\r\n        var _toString, _props$getValue;\r\n        return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;\r\n      },\r\n      aggregationFn: 'auto'\r\n    };\r\n  },\r\n  getInitialState: state => {\r\n    return {\r\n      grouping: [],\r\n      ...state\r\n    };\r\n  },\r\n  getDefaultOptions: table => {\r\n    return {\r\n      onGroupingChange: makeStateUpdater('grouping', table),\r\n      groupedColumnMode: 'reorder'\r\n    };\r\n  },\r\n  createColumn: (column, table) => {\r\n    column.toggleGrouping = () => {\r\n      table.setGrouping(old => {\r\n        // Find any existing grouping for this column\r\n        if (old != null && old.includes(column.id)) {\r\n          return old.filter(d => d !== column.id);\r\n        }\r\n        return [...(old != null ? old : []), column.id];\r\n      });\r\n    };\r\n    column.getCanGroup = () => {\r\n      var _column$columnDef$ena, _table$options$enable;\r\n      return ((_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGrouping) != null ? _table$options$enable : true) && (!!column.accessorFn || !!column.columnDef.getGroupingValue);\r\n    };\r\n    column.getIsGrouped = () => {\r\n      var _table$getState$group;\r\n      return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);\r\n    };\r\n    column.getGroupedIndex = () => {\r\n      var _table$getState$group2;\r\n      return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);\r\n    };\r\n    column.getToggleGroupingHandler = () => {\r\n      const canGroup = column.getCanGroup();\r\n      return () => {\r\n        if (!canGroup) return;\r\n        column.toggleGrouping();\r\n      };\r\n    };\r\n    column.getAutoAggregationFn = () => {\r\n      const firstRow = table.getCoreRowModel().flatRows[0];\r\n      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\r\n      if (typeof value === 'number') {\r\n        return aggregationFns.sum;\r\n      }\r\n      if (Object.prototype.toString.call(value) === '[object Date]') {\r\n        return aggregationFns.extent;\r\n      }\r\n    };\r\n    column.getAggregationFn = () => {\r\n      var _table$options$aggreg, _table$options$aggreg2;\r\n      if (!column) {\r\n        throw new Error();\r\n      }\r\n      return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === 'auto' ? column.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column.columnDef.aggregationFn];\r\n    };\r\n  },\r\n  createTable: table => {\r\n    table.setGrouping = updater => table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater);\r\n    table.resetGrouping = defaultState => {\r\n      var _table$initialState$g, _table$initialState;\r\n      table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);\r\n    };\r\n    table.getPreGroupedRowModel = () => table.getFilteredRowModel();\r\n    table.getGroupedRowModel = () => {\r\n      if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {\r\n        table._getGroupedRowModel = table.options.getGroupedRowModel(table);\r\n      }\r\n      if (table.options.manualGrouping || !table._getGroupedRowModel) {\r\n        return table.getPreGroupedRowModel();\r\n      }\r\n      return table._getGroupedRowModel();\r\n    };\r\n  },\r\n  createRow: (row, table) => {\r\n    row.getIsGrouped = () => !!row.groupingColumnId;\r\n    row.getGroupingValue = columnId => {\r\n      if (row._groupingValuesCache.hasOwnProperty(columnId)) {\r\n        return row._groupingValuesCache[columnId];\r\n      }\r\n      const column = table.getColumn(columnId);\r\n      if (!(column != null && column.columnDef.getGroupingValue)) {\r\n        return row.getValue(columnId);\r\n      }\r\n      row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(row.original);\r\n      return row._groupingValuesCache[columnId];\r\n    };\r\n    row._groupingValuesCache = {};\r\n  },\r\n  createCell: (cell, column, row, table) => {\r\n    cell.getIsGrouped = () => column.getIsGrouped() && column.id === row.groupingColumnId;\r\n    cell.getIsPlaceholder = () => !cell.getIsGrouped() && column.getIsGrouped();\r\n    cell.getIsAggregated = () => {\r\n      var _row$subRows;\r\n      return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\r\n    };\r\n  }\r\n};\r\nfunction orderColumns(leafColumns, grouping, groupedColumnMode) {\r\n  if (!(grouping != null && grouping.length) || !groupedColumnMode) {\r\n    return leafColumns;\r\n  }\r\n  const nonGroupingColumns = leafColumns.filter(col => !grouping.includes(col.id));\r\n  if (groupedColumnMode === 'remove') {\r\n    return nonGroupingColumns;\r\n  }\r\n  const groupingColumns = grouping.map(g => leafColumns.find(col => col.id === g)).filter(Boolean);\r\n  return [...groupingColumns, ...nonGroupingColumns];\r\n}\r\n\r\n//\r\n\r\nconst ColumnOrdering = {\r\n  getInitialState: state => {\r\n    return {\r\n      columnOrder: [],\r\n      ...state\r\n    };\r\n  },\r\n  getDefaultOptions: table => {\r\n    return {\r\n      onColumnOrderChange: makeStateUpdater('columnOrder', table)\r\n    };\r\n  },\r\n  createColumn: (column, table) => {\r\n    column.getIndex = memo(position => [_getVisibleLeafColumns(table, position)], columns => columns.findIndex(d => d.id === column.id), getMemoOptions(table.options, 'debugColumns', 'getIndex'));\r\n    column.getIsFirstColumn = position => {\r\n      var _columns$;\r\n      const columns = _getVisibleLeafColumns(table, position);\r\n      return ((_columns$ = columns[0]) == null ? void 0 : _columns$.id) === column.id;\r\n    };\r\n    column.getIsLastColumn = position => {\r\n      var _columns;\r\n      const columns = _getVisibleLeafColumns(table, position);\r\n      return ((_columns = columns[columns.length - 1]) == null ? void 0 : _columns.id) === column.id;\r\n    };\r\n  },\r\n  createTable: table => {\r\n    table.setColumnOrder = updater => table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater);\r\n    table.resetColumnOrder = defaultState => {\r\n      var _table$initialState$c;\r\n      table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);\r\n    };\r\n    table._getOrderColumnsFn = memo(() => [table.getState().columnOrder, table.getState().grouping, table.options.groupedColumnMode], (columnOrder, grouping, groupedColumnMode) => columns => {\r\n      // Sort grouped columns to the start of the column list\r\n      // before the headers are built\r\n      let orderedColumns = [];\r\n\r\n      // If there is no order, return the normal columns\r\n      if (!(columnOrder != null && columnOrder.length)) {\r\n        orderedColumns = columns;\r\n      } else {\r\n        const columnOrderCopy = [...columnOrder];\r\n\r\n        // If there is an order, make a copy of the columns\r\n        const columnsCopy = [...columns];\r\n\r\n        // And make a new ordered array of the columns\r\n\r\n        // Loop over the columns and place them in order into the new array\r\n        while (columnsCopy.length && columnOrderCopy.length) {\r\n          const targetColumnId = columnOrderCopy.shift();\r\n          const foundIndex = columnsCopy.findIndex(d => d.id === targetColumnId);\r\n          if (foundIndex > -1) {\r\n            orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);\r\n          }\r\n        }\r\n\r\n        // If there are any columns left, add them to the end\r\n        orderedColumns = [...orderedColumns, ...columnsCopy];\r\n      }\r\n      return orderColumns(orderedColumns, grouping, groupedColumnMode);\r\n    }, getMemoOptions(table.options, 'debugTable', '_getOrderColumnsFn'));\r\n  }\r\n};\r\n\r\n//\r\n\r\nconst getDefaultColumnPinningState = () => ({\r\n  left: [],\r\n  right: []\r\n});\r\nconst ColumnPinning = {\r\n  getInitialState: state => {\r\n    return {\r\n      columnPinning: getDefaultColumnPinningState(),\r\n      ...state\r\n    };\r\n  },\r\n  getDefaultOptions: table => {\r\n    return {\r\n      onColumnPinningChange: makeStateUpdater('columnPinning', table)\r\n    };\r\n  },\r\n  createColumn: (column, table) => {\r\n    column.pin = position => {\r\n      const columnIds = column.getLeafColumns().map(d => d.id).filter(Boolean);\r\n      table.setColumnPinning(old => {\r\n        var _old$left3, _old$right3;\r\n        if (position === 'right') {\r\n          var _old$left, _old$right;\r\n          return {\r\n            left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter(d => !(columnIds != null && columnIds.includes(d))),\r\n            right: [...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter(d => !(columnIds != null && columnIds.includes(d))), ...columnIds]\r\n          };\r\n        }\r\n        if (position === 'left') {\r\n          var _old$left2, _old$right2;\r\n          return {\r\n            left: [...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter(d => !(columnIds != null && columnIds.includes(d))), ...columnIds],\r\n            right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter(d => !(columnIds != null && columnIds.includes(d)))\r\n          };\r\n        }\r\n        return {\r\n          left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter(d => !(columnIds != null && columnIds.includes(d))),\r\n          right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter(d => !(columnIds != null && columnIds.includes(d)))\r\n        };\r\n      });\r\n    };\r\n    column.getCanPin = () => {\r\n      const leafColumns = column.getLeafColumns();\r\n      return leafColumns.some(d => {\r\n        var _d$columnDef$enablePi, _ref, _table$options$enable;\r\n        return ((_d$columnDef$enablePi = d.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);\r\n      });\r\n    };\r\n    column.getIsPinned = () => {\r\n      const leafColumnIds = column.getLeafColumns().map(d => d.id);\r\n      const {\r\n        left,\r\n        right\r\n      } = table.getState().columnPinning;\r\n      const isLeft = leafColumnIds.some(d => left == null ? void 0 : left.includes(d));\r\n      const isRight = leafColumnIds.some(d => right == null ? void 0 : right.includes(d));\r\n      return isLeft ? 'left' : isRight ? 'right' : false;\r\n    };\r\n    column.getPinnedIndex = () => {\r\n      var _table$getState$colum, _table$getState$colum2;\r\n      const position = column.getIsPinned();\r\n      return position ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position]) == null ? void 0 : _table$getState$colum2.indexOf(column.id)) != null ? _table$getState$colum : -1 : 0;\r\n    };\r\n  },\r\n  createRow: (row, table) => {\r\n    row.getCenterVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allCells, left, right) => {\r\n      const leftAndRight = [...(left != null ? left : []), ...(right != null ? right : [])];\r\n      return allCells.filter(d => !leftAndRight.includes(d.column.id));\r\n    }, getMemoOptions(table.options, 'debugRows', 'getCenterVisibleCells'));\r\n    row.getLeftVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left], (allCells, left) => {\r\n      const cells = (left != null ? left : []).map(columnId => allCells.find(cell => cell.column.id === columnId)).filter(Boolean).map(d => ({\r\n        ...d,\r\n        position: 'left'\r\n      }));\r\n      return cells;\r\n    }, getMemoOptions(table.options, 'debugRows', 'getLeftVisibleCells'));\r\n    row.getRightVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.right], (allCells, right) => {\r\n      const cells = (right != null ? right : []).map(columnId => allCells.find(cell => cell.column.id === columnId)).filter(Boolean).map(d => ({\r\n        ...d,\r\n        position: 'right'\r\n      }));\r\n      return cells;\r\n    }, getMemoOptions(table.options, 'debugRows', 'getRightVisibleCells'));\r\n  },\r\n  createTable: table => {\r\n    table.setColumnPinning = updater => table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater);\r\n    table.resetColumnPinning = defaultState => {\r\n      var _table$initialState$c, _table$initialState;\r\n      return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());\r\n    };\r\n    table.getIsSomeColumnsPinned = position => {\r\n      var _pinningState$positio;\r\n      const pinningState = table.getState().columnPinning;\r\n      if (!position) {\r\n        var _pinningState$left, _pinningState$right;\r\n        return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));\r\n      }\r\n      return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);\r\n    };\r\n    table.getLeftLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left], (allColumns, left) => {\r\n      return (left != null ? left : []).map(columnId => allColumns.find(column => column.id === columnId)).filter(Boolean);\r\n    }, getMemoOptions(table.options, 'debugColumns', 'getLeftLeafColumns'));\r\n    table.getRightLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.right], (allColumns, right) => {\r\n      return (right != null ? right : []).map(columnId => allColumns.find(column => column.id === columnId)).filter(Boolean);\r\n    }, getMemoOptions(table.options, 'debugColumns', 'getRightLeafColumns'));\r\n    table.getCenterLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, left, right) => {\r\n      const leftAndRight = [...(left != null ? left : []), ...(right != null ? right : [])];\r\n      return allColumns.filter(d => !leftAndRight.includes(d.id));\r\n    }, getMemoOptions(table.options, 'debugColumns', 'getCenterLeafColumns'));\r\n  }\r\n};\r\n\r\n//\r\n\r\n//\r\n\r\nconst defaultColumnSizing = {\r\n  size: 150,\r\n  minSize: 20,\r\n  maxSize: Number.MAX_SAFE_INTEGER\r\n};\r\nconst getDefaultColumnSizingInfoState = () => ({\r\n  startOffset: null,\r\n  startSize: null,\r\n  deltaOffset: null,\r\n  deltaPercentage: null,\r\n  isResizingColumn: false,\r\n  columnSizingStart: []\r\n});\r\nconst ColumnSizing = {\r\n  getDefaultColumnDef: () => {\r\n    return defaultColumnSizing;\r\n  },\r\n  getInitialState: state => {\r\n    return {\r\n      columnSizing: {},\r\n      columnSizingInfo: getDefaultColumnSizingInfoState(),\r\n      ...state\r\n    };\r\n  },\r\n  getDefaultOptions: table => {\r\n    return {\r\n      columnResizeMode: 'onEnd',\r\n      columnResizeDirection: 'ltr',\r\n      onColumnSizingChange: makeStateUpdater('columnSizing', table),\r\n      onColumnSizingInfoChange: makeStateUpdater('columnSizingInfo', table)\r\n    };\r\n  },\r\n  createColumn: (column, table) => {\r\n    column.getSize = () => {\r\n      var _column$columnDef$min, _ref, _column$columnDef$max;\r\n      const columnSize = table.getState().columnSizing[column.id];\r\n      return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);\r\n    };\r\n    column.getStart = memo(position => [position, _getVisibleLeafColumns(table, position), table.getState().columnSizing], (position, columns) => columns.slice(0, column.getIndex(position)).reduce((sum, column) => sum + column.getSize(), 0), getMemoOptions(table.options, 'debugColumns', 'getStart'));\r\n    column.getAfter = memo(position => [position, _getVisibleLeafColumns(table, position), table.getState().columnSizing], (position, columns) => columns.slice(column.getIndex(position) + 1).reduce((sum, column) => sum + column.getSize(), 0), getMemoOptions(table.options, 'debugColumns', 'getAfter'));\r\n    column.resetSize = () => {\r\n      table.setColumnSizing(_ref2 => {\r\n        let {\r\n          [column.id]: _,\r\n          ...rest\r\n        } = _ref2;\r\n        return rest;\r\n      });\r\n    };\r\n    column.getCanResize = () => {\r\n      var _column$columnDef$ena, _table$options$enable;\r\n      return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);\r\n    };\r\n    column.getIsResizing = () => {\r\n      return table.getState().columnSizingInfo.isResizingColumn === column.id;\r\n    };\r\n  },\r\n  createHeader: (header, table) => {\r\n    header.getSize = () => {\r\n      let sum = 0;\r\n      const recurse = header => {\r\n        if (header.subHeaders.length) {\r\n          header.subHeaders.forEach(recurse);\r\n        } else {\r\n          var _header$column$getSiz;\r\n          sum += (_header$column$getSiz = header.column.getSize()) != null ? _header$column$getSiz : 0;\r\n        }\r\n      };\r\n      recurse(header);\r\n      return sum;\r\n    };\r\n    header.getStart = () => {\r\n      if (header.index > 0) {\r\n        const prevSiblingHeader = header.headerGroup.headers[header.index - 1];\r\n        return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();\r\n      }\r\n      return 0;\r\n    };\r\n    header.getResizeHandler = _contextDocument => {\r\n      const column = table.getColumn(header.column.id);\r\n      const canResize = column == null ? void 0 : column.getCanResize();\r\n      return e => {\r\n        if (!column || !canResize) {\r\n          return;\r\n        }\r\n        e.persist == null || e.persist();\r\n        if (isTouchStartEvent(e)) {\r\n          // lets not respond to multiple touches (e.g. 2 or 3 fingers)\r\n          if (e.touches && e.touches.length > 1) {\r\n            return;\r\n          }\r\n        }\r\n        const startSize = header.getSize();\r\n        const columnSizingStart = header ? header.getLeafHeaders().map(d => [d.column.id, d.column.getSize()]) : [[column.id, column.getSize()]];\r\n        const clientX = isTouchStartEvent(e) ? Math.round(e.touches[0].clientX) : e.clientX;\r\n        const newColumnSizing = {};\r\n        const updateOffset = (eventType, clientXPos) => {\r\n          if (typeof clientXPos !== 'number') {\r\n            return;\r\n          }\r\n          table.setColumnSizingInfo(old => {\r\n            var _old$startOffset, _old$startSize;\r\n            const deltaDirection = table.options.columnResizeDirection === 'rtl' ? -1 : 1;\r\n            const deltaOffset = (clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0)) * deltaDirection;\r\n            const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);\r\n            old.columnSizingStart.forEach(_ref3 => {\r\n              let [columnId, headerSize] = _ref3;\r\n              newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;\r\n            });\r\n            return {\r\n              ...old,\r\n              deltaOffset,\r\n              deltaPercentage\r\n            };\r\n          });\r\n          if (table.options.columnResizeMode === 'onChange' || eventType === 'end') {\r\n            table.setColumnSizing(old => ({\r\n              ...old,\r\n              ...newColumnSizing\r\n            }));\r\n          }\r\n        };\r\n        const onMove = clientXPos => updateOffset('move', clientXPos);\r\n        const onEnd = clientXPos => {\r\n          updateOffset('end', clientXPos);\r\n          table.setColumnSizingInfo(old => ({\r\n            ...old,\r\n            isResizingColumn: false,\r\n            startOffset: null,\r\n            startSize: null,\r\n            deltaOffset: null,\r\n            deltaPercentage: null,\r\n            columnSizingStart: []\r\n          }));\r\n        };\r\n        const contextDocument = _contextDocument || typeof document !== 'undefined' ? document : null;\r\n        const mouseEvents = {\r\n          moveHandler: e => onMove(e.clientX),\r\n          upHandler: e => {\r\n            contextDocument == null || contextDocument.removeEventListener('mousemove', mouseEvents.moveHandler);\r\n            contextDocument == null || contextDocument.removeEventListener('mouseup', mouseEvents.upHandler);\r\n            onEnd(e.clientX);\r\n          }\r\n        };\r\n        const touchEvents = {\r\n          moveHandler: e => {\r\n            if (e.cancelable) {\r\n              e.preventDefault();\r\n              e.stopPropagation();\r\n            }\r\n            onMove(e.touches[0].clientX);\r\n            return false;\r\n          },\r\n          upHandler: e => {\r\n            var _e$touches$;\r\n            contextDocument == null || contextDocument.removeEventListener('touchmove', touchEvents.moveHandler);\r\n            contextDocument == null || contextDocument.removeEventListener('touchend', touchEvents.upHandler);\r\n            if (e.cancelable) {\r\n              e.preventDefault();\r\n              e.stopPropagation();\r\n            }\r\n            onEnd((_e$touches$ = e.touches[0]) == null ? void 0 : _e$touches$.clientX);\r\n          }\r\n        };\r\n        const passiveIfSupported = passiveEventSupported() ? {\r\n          passive: false\r\n        } : false;\r\n        if (isTouchStartEvent(e)) {\r\n          contextDocument == null || contextDocument.addEventListener('touchmove', touchEvents.moveHandler, passiveIfSupported);\r\n          contextDocument == null || contextDocument.addEventListener('touchend', touchEvents.upHandler, passiveIfSupported);\r\n        } else {\r\n          contextDocument == null || contextDocument.addEventListener('mousemove', mouseEvents.moveHandler, passiveIfSupported);\r\n          contextDocument == null || contextDocument.addEventListener('mouseup', mouseEvents.upHandler, passiveIfSupported);\r\n        }\r\n        table.setColumnSizingInfo(old => ({\r\n          ...old,\r\n          startOffset: clientX,\r\n          startSize,\r\n          deltaOffset: 0,\r\n          deltaPercentage: 0,\r\n          columnSizingStart,\r\n          isResizingColumn: column.id\r\n        }));\r\n      };\r\n    };\r\n  },\r\n  createTable: table => {\r\n    table.setColumnSizing = updater => table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater);\r\n    table.setColumnSizingInfo = updater => table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater);\r\n    table.resetColumnSizing = defaultState => {\r\n      var _table$initialState$c;\r\n      table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});\r\n    };\r\n    table.resetHeaderSizeInfo = defaultState => {\r\n      var _table$initialState$c2;\r\n      table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());\r\n    };\r\n    table.getTotalSize = () => {\r\n      var _table$getHeaderGroup, _table$getHeaderGroup2;\r\n      return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum, header) => {\r\n        return sum + header.getSize();\r\n      }, 0)) != null ? _table$getHeaderGroup : 0;\r\n    };\r\n    table.getLeftTotalSize = () => {\r\n      var _table$getLeftHeaderG, _table$getLeftHeaderG2;\r\n      return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum, header) => {\r\n        return sum + header.getSize();\r\n      }, 0)) != null ? _table$getLeftHeaderG : 0;\r\n    };\r\n    table.getCenterTotalSize = () => {\r\n      var _table$getCenterHeade, _table$getCenterHeade2;\r\n      return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum, header) => {\r\n        return sum + header.getSize();\r\n      }, 0)) != null ? _table$getCenterHeade : 0;\r\n    };\r\n    table.getRightTotalSize = () => {\r\n      var _table$getRightHeader, _table$getRightHeader2;\r\n      return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum, header) => {\r\n        return sum + header.getSize();\r\n      }, 0)) != null ? _table$getRightHeader : 0;\r\n    };\r\n  }\r\n};\r\nlet passiveSupported = null;\r\nfunction passiveEventSupported() {\r\n  if (typeof passiveSupported === 'boolean') return passiveSupported;\r\n  let supported = false;\r\n  try {\r\n    const options = {\r\n      get passive() {\r\n        supported = true;\r\n        return false;\r\n      }\r\n    };\r\n    const noop = () => {};\r\n    window.addEventListener('test', noop, options);\r\n    window.removeEventListener('test', noop);\r\n  } catch (err) {\r\n    supported = false;\r\n  }\r\n  passiveSupported = supported;\r\n  return passiveSupported;\r\n}\r\nfunction isTouchStartEvent(e) {\r\n  return e.type === 'touchstart';\r\n}\r\n\r\n//\r\n\r\nconst ColumnVisibility = {\r\n  getInitialState: state => {\r\n    return {\r\n      columnVisibility: {},\r\n      ...state\r\n    };\r\n  },\r\n  getDefaultOptions: table => {\r\n    return {\r\n      onColumnVisibilityChange: makeStateUpdater('columnVisibility', table)\r\n    };\r\n  },\r\n  createColumn: (column, table) => {\r\n    column.toggleVisibility = value => {\r\n      if (column.getCanHide()) {\r\n        table.setColumnVisibility(old => ({\r\n          ...old,\r\n          [column.id]: value != null ? value : !column.getIsVisible()\r\n        }));\r\n      }\r\n    };\r\n    column.getIsVisible = () => {\r\n      var _ref, _table$getState$colum;\r\n      const childColumns = column.columns;\r\n      return (_ref = childColumns.length ? childColumns.some(c => c.getIsVisible()) : (_table$getState$colum = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum[column.id]) != null ? _ref : true;\r\n    };\r\n    column.getCanHide = () => {\r\n      var _column$columnDef$ena, _table$options$enable;\r\n      return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);\r\n    };\r\n    column.getToggleVisibilityHandler = () => {\r\n      return e => {\r\n        column.toggleVisibility == null || column.toggleVisibility(e.target.checked);\r\n      };\r\n    };\r\n  },\r\n  createRow: (row, table) => {\r\n    row._getAllVisibleCells = memo(() => [row.getAllCells(), table.getState().columnVisibility], cells => {\r\n      return cells.filter(cell => cell.column.getIsVisible());\r\n    }, getMemoOptions(table.options, 'debugRows', '_getAllVisibleCells'));\r\n    row.getVisibleCells = memo(() => [row.getLeftVisibleCells(), row.getCenterVisibleCells(), row.getRightVisibleCells()], (left, center, right) => [...left, ...center, ...right], getMemoOptions(table.options, 'debugRows', 'getVisibleCells'));\r\n  },\r\n  createTable: table => {\r\n    const makeVisibleColumnsMethod = (key, getColumns) => {\r\n      return memo(() => [getColumns(), getColumns().filter(d => d.getIsVisible()).map(d => d.id).join('_')], columns => {\r\n        return columns.filter(d => d.getIsVisible == null ? void 0 : d.getIsVisible());\r\n      }, getMemoOptions(table.options, 'debugColumns', key));\r\n    };\r\n    table.getVisibleFlatColumns = makeVisibleColumnsMethod('getVisibleFlatColumns', () => table.getAllFlatColumns());\r\n    table.getVisibleLeafColumns = makeVisibleColumnsMethod('getVisibleLeafColumns', () => table.getAllLeafColumns());\r\n    table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod('getLeftVisibleLeafColumns', () => table.getLeftLeafColumns());\r\n    table.getRightVisibleLeafColumns = makeVisibleColumnsMethod('getRightVisibleLeafColumns', () => table.getRightLeafColumns());\r\n    table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod('getCenterVisibleLeafColumns', () => table.getCenterLeafColumns());\r\n    table.setColumnVisibility = updater => table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater);\r\n    table.resetColumnVisibility = defaultState => {\r\n      var _table$initialState$c;\r\n      table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});\r\n    };\r\n    table.toggleAllColumnsVisible = value => {\r\n      var _value;\r\n      value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();\r\n      table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column) => ({\r\n        ...obj,\r\n        [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value\r\n      }), {}));\r\n    };\r\n    table.getIsAllColumnsVisible = () => !table.getAllLeafColumns().some(column => !(column.getIsVisible != null && column.getIsVisible()));\r\n    table.getIsSomeColumnsVisible = () => table.getAllLeafColumns().some(column => column.getIsVisible == null ? void 0 : column.getIsVisible());\r\n    table.getToggleAllColumnsVisibilityHandler = () => {\r\n      return e => {\r\n        var _target;\r\n        table.toggleAllColumnsVisible((_target = e.target) == null ? void 0 : _target.checked);\r\n      };\r\n    };\r\n  }\r\n};\r\nfunction _getVisibleLeafColumns(table, position) {\r\n  return !position ? table.getVisibleLeafColumns() : position === 'center' ? table.getCenterVisibleLeafColumns() : position === 'left' ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();\r\n}\r\n\r\n//\r\n\r\nconst GlobalFaceting = {\r\n  createTable: table => {\r\n    table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, '__global__');\r\n    table.getGlobalFacetedRowModel = () => {\r\n      if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {\r\n        return table.getPreFilteredRowModel();\r\n      }\r\n      return table._getGlobalFacetedRowModel();\r\n    };\r\n    table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, '__global__');\r\n    table.getGlobalFacetedUniqueValues = () => {\r\n      if (!table._getGlobalFacetedUniqueValues) {\r\n        return new Map();\r\n      }\r\n      return table._getGlobalFacetedUniqueValues();\r\n    };\r\n    table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, '__global__');\r\n    table.getGlobalFacetedMinMaxValues = () => {\r\n      if (!table._getGlobalFacetedMinMaxValues) {\r\n        return;\r\n      }\r\n      return table._getGlobalFacetedMinMaxValues();\r\n    };\r\n  }\r\n};\r\n\r\n//\r\n\r\nconst GlobalFiltering = {\r\n  getInitialState: state => {\r\n    return {\r\n      globalFilter: undefined,\r\n      ...state\r\n    };\r\n  },\r\n  getDefaultOptions: table => {\r\n    return {\r\n      onGlobalFilterChange: makeStateUpdater('globalFilter', table),\r\n      globalFilterFn: 'auto',\r\n      getColumnCanGlobalFilter: column => {\r\n        var _table$getCoreRowMode;\r\n        const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode.getValue();\r\n        return typeof value === 'string' || typeof value === 'number';\r\n      }\r\n    };\r\n  },\r\n  createColumn: (column, table) => {\r\n    column.getCanGlobalFilter = () => {\r\n      var _column$columnDef$ena, _table$options$enable, _table$options$enable2, _table$options$getCol;\r\n      return ((_column$columnDef$ena = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGlobalFilter) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _table$options$getCol : true) && !!column.accessorFn;\r\n    };\r\n  },\r\n  createTable: table => {\r\n    table.getGlobalAutoFilterFn = () => {\r\n      return filterFns.includesString;\r\n    };\r\n    table.getGlobalFilterFn = () => {\r\n      var _table$options$filter, _table$options$filter2;\r\n      const {\r\n        globalFilterFn: globalFilterFn\r\n      } = table.options;\r\n      return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === 'auto' ? table.getGlobalAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[globalFilterFn]) != null ? _table$options$filter : filterFns[globalFilterFn];\r\n    };\r\n    table.setGlobalFilter = updater => {\r\n      table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);\r\n    };\r\n    table.resetGlobalFilter = defaultState => {\r\n      table.setGlobalFilter(defaultState ? undefined : table.initialState.globalFilter);\r\n    };\r\n  }\r\n};\r\n\r\n//\r\n\r\nconst RowExpanding = {\r\n  getInitialState: state => {\r\n    return {\r\n      expanded: {},\r\n      ...state\r\n    };\r\n  },\r\n  getDefaultOptions: table => {\r\n    return {\r\n      onExpandedChange: makeStateUpdater('expanded', table),\r\n      paginateExpandedRows: true\r\n    };\r\n  },\r\n  createTable: table => {\r\n    let registered = false;\r\n    let queued = false;\r\n    table._autoResetExpanded = () => {\r\n      var _ref, _table$options$autoRe;\r\n      if (!registered) {\r\n        table._queue(() => {\r\n          registered = true;\r\n        });\r\n        return;\r\n      }\r\n      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {\r\n        if (queued) return;\r\n        queued = true;\r\n        table._queue(() => {\r\n          table.resetExpanded();\r\n          queued = false;\r\n        });\r\n      }\r\n    };\r\n    table.setExpanded = updater => table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater);\r\n    table.toggleAllRowsExpanded = expanded => {\r\n      if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {\r\n        table.setExpanded(true);\r\n      } else {\r\n        table.setExpanded({});\r\n      }\r\n    };\r\n    table.resetExpanded = defaultState => {\r\n      var _table$initialState$e, _table$initialState;\r\n      table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});\r\n    };\r\n    table.getCanSomeRowsExpand = () => {\r\n      return table.getPrePaginationRowModel().flatRows.some(row => row.getCanExpand());\r\n    };\r\n    table.getToggleAllRowsExpandedHandler = () => {\r\n      return e => {\r\n        e.persist == null || e.persist();\r\n        table.toggleAllRowsExpanded();\r\n      };\r\n    };\r\n    table.getIsSomeRowsExpanded = () => {\r\n      const expanded = table.getState().expanded;\r\n      return expanded === true || Object.values(expanded).some(Boolean);\r\n    };\r\n    table.getIsAllRowsExpanded = () => {\r\n      const expanded = table.getState().expanded;\r\n\r\n      // If expanded is true, save some cycles and return true\r\n      if (typeof expanded === 'boolean') {\r\n        return expanded === true;\r\n      }\r\n      if (!Object.keys(expanded).length) {\r\n        return false;\r\n      }\r\n\r\n      // If any row is not expanded, return false\r\n      if (table.getRowModel().flatRows.some(row => !row.getIsExpanded())) {\r\n        return false;\r\n      }\r\n\r\n      // They must all be expanded :shrug:\r\n      return true;\r\n    };\r\n    table.getExpandedDepth = () => {\r\n      let maxDepth = 0;\r\n      const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);\r\n      rowIds.forEach(id => {\r\n        const splitId = id.split('.');\r\n        maxDepth = Math.max(maxDepth, splitId.length);\r\n      });\r\n      return maxDepth;\r\n    };\r\n    table.getPreExpandedRowModel = () => table.getSortedRowModel();\r\n    table.getExpandedRowModel = () => {\r\n      if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {\r\n        table._getExpandedRowModel = table.options.getExpandedRowModel(table);\r\n      }\r\n      if (table.options.manualExpanding || !table._getExpandedRowModel) {\r\n        return table.getPreExpandedRowModel();\r\n      }\r\n      return table._getExpandedRowModel();\r\n    };\r\n  },\r\n  createRow: (row, table) => {\r\n    row.toggleExpanded = expanded => {\r\n      table.setExpanded(old => {\r\n        var _expanded;\r\n        const exists = old === true ? true : !!(old != null && old[row.id]);\r\n        let oldExpanded = {};\r\n        if (old === true) {\r\n          Object.keys(table.getRowModel().rowsById).forEach(rowId => {\r\n            oldExpanded[rowId] = true;\r\n          });\r\n        } else {\r\n          oldExpanded = old;\r\n        }\r\n        expanded = (_expanded = expanded) != null ? _expanded : !exists;\r\n        if (!exists && expanded) {\r\n          return {\r\n            ...oldExpanded,\r\n            [row.id]: true\r\n          };\r\n        }\r\n        if (exists && !expanded) {\r\n          const {\r\n            [row.id]: _,\r\n            ...rest\r\n          } = oldExpanded;\r\n          return rest;\r\n        }\r\n        return old;\r\n      });\r\n    };\r\n    row.getIsExpanded = () => {\r\n      var _table$options$getIsR;\r\n      const expanded = table.getState().expanded;\r\n      return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? void 0 : expanded[row.id]));\r\n    };\r\n    row.getCanExpand = () => {\r\n      var _table$options$getRow, _table$options$enable, _row$subRows;\r\n      return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\r\n    };\r\n    row.getIsAllParentsExpanded = () => {\r\n      let isFullyExpanded = true;\r\n      let currentRow = row;\r\n      while (isFullyExpanded && currentRow.parentId) {\r\n        currentRow = table.getRow(currentRow.parentId, true);\r\n        isFullyExpanded = currentRow.getIsExpanded();\r\n      }\r\n      return isFullyExpanded;\r\n    };\r\n    row.getToggleExpandedHandler = () => {\r\n      const canExpand = row.getCanExpand();\r\n      return () => {\r\n        if (!canExpand) return;\r\n        row.toggleExpanded();\r\n      };\r\n    };\r\n  }\r\n};\r\n\r\n//\r\n\r\nconst defaultPageIndex = 0;\r\nconst defaultPageSize = 10;\r\nconst getDefaultPaginationState = () => ({\r\n  pageIndex: defaultPageIndex,\r\n  pageSize: defaultPageSize\r\n});\r\nconst RowPagination = {\r\n  getInitialState: state => {\r\n    return {\r\n      ...state,\r\n      pagination: {\r\n        ...getDefaultPaginationState(),\r\n        ...(state == null ? void 0 : state.pagination)\r\n      }\r\n    };\r\n  },\r\n  getDefaultOptions: table => {\r\n    return {\r\n      onPaginationChange: makeStateUpdater('pagination', table)\r\n    };\r\n  },\r\n  createTable: table => {\r\n    let registered = false;\r\n    let queued = false;\r\n    table._autoResetPageIndex = () => {\r\n      var _ref, _table$options$autoRe;\r\n      if (!registered) {\r\n        table._queue(() => {\r\n          registered = true;\r\n        });\r\n        return;\r\n      }\r\n      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {\r\n        if (queued) return;\r\n        queued = true;\r\n        table._queue(() => {\r\n          table.resetPageIndex();\r\n          queued = false;\r\n        });\r\n      }\r\n    };\r\n    table.setPagination = updater => {\r\n      const safeUpdater = old => {\r\n        let newState = functionalUpdate(updater, old);\r\n        return newState;\r\n      };\r\n      return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);\r\n    };\r\n    table.resetPagination = defaultState => {\r\n      var _table$initialState$p;\r\n      table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());\r\n    };\r\n    table.setPageIndex = updater => {\r\n      table.setPagination(old => {\r\n        let pageIndex = functionalUpdate(updater, old.pageIndex);\r\n        const maxPageIndex = typeof table.options.pageCount === 'undefined' || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;\r\n        pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));\r\n        return {\r\n          ...old,\r\n          pageIndex\r\n        };\r\n      });\r\n    };\r\n    table.resetPageIndex = defaultState => {\r\n      var _table$initialState$p2, _table$initialState;\r\n      table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? void 0 : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);\r\n    };\r\n    table.resetPageSize = defaultState => {\r\n      var _table$initialState$p3, _table$initialState2;\r\n      table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? void 0 : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);\r\n    };\r\n    table.setPageSize = updater => {\r\n      table.setPagination(old => {\r\n        const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));\r\n        const topRowIndex = old.pageSize * old.pageIndex;\r\n        const pageIndex = Math.floor(topRowIndex / pageSize);\r\n        return {\r\n          ...old,\r\n          pageIndex,\r\n          pageSize\r\n        };\r\n      });\r\n    };\r\n    //deprecated\r\n    table.setPageCount = updater => table.setPagination(old => {\r\n      var _table$options$pageCo;\r\n      let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);\r\n      if (typeof newPageCount === 'number') {\r\n        newPageCount = Math.max(-1, newPageCount);\r\n      }\r\n      return {\r\n        ...old,\r\n        pageCount: newPageCount\r\n      };\r\n    });\r\n    table.getPageOptions = memo(() => [table.getPageCount()], pageCount => {\r\n      let pageOptions = [];\r\n      if (pageCount && pageCount > 0) {\r\n        pageOptions = [...new Array(pageCount)].fill(null).map((_, i) => i);\r\n      }\r\n      return pageOptions;\r\n    }, getMemoOptions(table.options, 'debugTable', 'getPageOptions'));\r\n    table.getCanPreviousPage = () => table.getState().pagination.pageIndex > 0;\r\n    table.getCanNextPage = () => {\r\n      const {\r\n        pageIndex\r\n      } = table.getState().pagination;\r\n      const pageCount = table.getPageCount();\r\n      if (pageCount === -1) {\r\n        return true;\r\n      }\r\n      if (pageCount === 0) {\r\n        return false;\r\n      }\r\n      return pageIndex < pageCount - 1;\r\n    };\r\n    table.previousPage = () => {\r\n      return table.setPageIndex(old => old - 1);\r\n    };\r\n    table.nextPage = () => {\r\n      return table.setPageIndex(old => {\r\n        return old + 1;\r\n      });\r\n    };\r\n    table.firstPage = () => {\r\n      return table.setPageIndex(0);\r\n    };\r\n    table.lastPage = () => {\r\n      return table.setPageIndex(table.getPageCount() - 1);\r\n    };\r\n    table.getPrePaginationRowModel = () => table.getExpandedRowModel();\r\n    table.getPaginationRowModel = () => {\r\n      if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {\r\n        table._getPaginationRowModel = table.options.getPaginationRowModel(table);\r\n      }\r\n      if (table.options.manualPagination || !table._getPaginationRowModel) {\r\n        return table.getPrePaginationRowModel();\r\n      }\r\n      return table._getPaginationRowModel();\r\n    };\r\n    table.getPageCount = () => {\r\n      var _table$options$pageCo2;\r\n      return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getRowCount() / table.getState().pagination.pageSize);\r\n    };\r\n    table.getRowCount = () => {\r\n      var _table$options$rowCou;\r\n      return (_table$options$rowCou = table.options.rowCount) != null ? _table$options$rowCou : table.getPrePaginationRowModel().rows.length;\r\n    };\r\n  }\r\n};\r\n\r\n//\r\n\r\nconst getDefaultRowPinningState = () => ({\r\n  top: [],\r\n  bottom: []\r\n});\r\nconst RowPinning = {\r\n  getInitialState: state => {\r\n    return {\r\n      rowPinning: getDefaultRowPinningState(),\r\n      ...state\r\n    };\r\n  },\r\n  getDefaultOptions: table => {\r\n    return {\r\n      onRowPinningChange: makeStateUpdater('rowPinning', table)\r\n    };\r\n  },\r\n  createRow: (row, table) => {\r\n    row.pin = (position, includeLeafRows, includeParentRows) => {\r\n      const leafRowIds = includeLeafRows ? row.getLeafRows().map(_ref => {\r\n        let {\r\n          id\r\n        } = _ref;\r\n        return id;\r\n      }) : [];\r\n      const parentRowIds = includeParentRows ? row.getParentRows().map(_ref2 => {\r\n        let {\r\n          id\r\n        } = _ref2;\r\n        return id;\r\n      }) : [];\r\n      const rowIds = new Set([...parentRowIds, row.id, ...leafRowIds]);\r\n      table.setRowPinning(old => {\r\n        var _old$top3, _old$bottom3;\r\n        if (position === 'bottom') {\r\n          var _old$top, _old$bottom;\r\n          return {\r\n            top: ((_old$top = old == null ? void 0 : old.top) != null ? _old$top : []).filter(d => !(rowIds != null && rowIds.has(d))),\r\n            bottom: [...((_old$bottom = old == null ? void 0 : old.bottom) != null ? _old$bottom : []).filter(d => !(rowIds != null && rowIds.has(d))), ...Array.from(rowIds)]\r\n          };\r\n        }\r\n        if (position === 'top') {\r\n          var _old$top2, _old$bottom2;\r\n          return {\r\n            top: [...((_old$top2 = old == null ? void 0 : old.top) != null ? _old$top2 : []).filter(d => !(rowIds != null && rowIds.has(d))), ...Array.from(rowIds)],\r\n            bottom: ((_old$bottom2 = old == null ? void 0 : old.bottom) != null ? _old$bottom2 : []).filter(d => !(rowIds != null && rowIds.has(d)))\r\n          };\r\n        }\r\n        return {\r\n          top: ((_old$top3 = old == null ? void 0 : old.top) != null ? _old$top3 : []).filter(d => !(rowIds != null && rowIds.has(d))),\r\n          bottom: ((_old$bottom3 = old == null ? void 0 : old.bottom) != null ? _old$bottom3 : []).filter(d => !(rowIds != null && rowIds.has(d)))\r\n        };\r\n      });\r\n    };\r\n    row.getCanPin = () => {\r\n      var _ref3;\r\n      const {\r\n        enableRowPinning,\r\n        enablePinning\r\n      } = table.options;\r\n      if (typeof enableRowPinning === 'function') {\r\n        return enableRowPinning(row);\r\n      }\r\n      return (_ref3 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref3 : true;\r\n    };\r\n    row.getIsPinned = () => {\r\n      const rowIds = [row.id];\r\n      const {\r\n        top,\r\n        bottom\r\n      } = table.getState().rowPinning;\r\n      const isTop = rowIds.some(d => top == null ? void 0 : top.includes(d));\r\n      const isBottom = rowIds.some(d => bottom == null ? void 0 : bottom.includes(d));\r\n      return isTop ? 'top' : isBottom ? 'bottom' : false;\r\n    };\r\n    row.getPinnedIndex = () => {\r\n      var _table$_getPinnedRows, _visiblePinnedRowIds$;\r\n      const position = row.getIsPinned();\r\n      if (!position) return -1;\r\n      const visiblePinnedRowIds = (_table$_getPinnedRows = table._getPinnedRows(position)) == null ? void 0 : _table$_getPinnedRows.map(_ref4 => {\r\n        let {\r\n          id\r\n        } = _ref4;\r\n        return id;\r\n      });\r\n      return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? void 0 : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;\r\n    };\r\n  },\r\n  createTable: table => {\r\n    table.setRowPinning = updater => table.options.onRowPinningChange == null ? void 0 : table.options.onRowPinningChange(updater);\r\n    table.resetRowPinning = defaultState => {\r\n      var _table$initialState$r, _table$initialState;\r\n      return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());\r\n    };\r\n    table.getIsSomeRowsPinned = position => {\r\n      var _pinningState$positio;\r\n      const pinningState = table.getState().rowPinning;\r\n      if (!position) {\r\n        var _pinningState$top, _pinningState$bottom;\r\n        return Boolean(((_pinningState$top = pinningState.top) == null ? void 0 : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? void 0 : _pinningState$bottom.length));\r\n      }\r\n      return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);\r\n    };\r\n    table._getPinnedRows = memo(position => [table.getRowModel().rows, table.getState().rowPinning[position], position], (visibleRows, pinnedRowIds, position) => {\r\n      var _table$options$keepPi;\r\n      const rows = ((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ?\r\n      //get all rows that are pinned even if they would not be otherwise visible\r\n      //account for expanded parent rows, but not pagination or filtering\r\n      (pinnedRowIds != null ? pinnedRowIds : []).map(rowId => {\r\n        const row = table.getRow(rowId, true);\r\n        return row.getIsAllParentsExpanded() ? row : null;\r\n      }) :\r\n      //else get only visible rows that are pinned\r\n      (pinnedRowIds != null ? pinnedRowIds : []).map(rowId => visibleRows.find(row => row.id === rowId));\r\n      return rows.filter(Boolean).map(d => ({\r\n        ...d,\r\n        position\r\n      }));\r\n    }, getMemoOptions(table.options, 'debugRows', '_getPinnedRows'));\r\n    table.getTopRows = () => table._getPinnedRows('top');\r\n    table.getBottomRows = () => table._getPinnedRows('bottom');\r\n    table.getCenterRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.top, table.getState().rowPinning.bottom], (allRows, top, bottom) => {\r\n      const topAndBottom = new Set([...(top != null ? top : []), ...(bottom != null ? bottom : [])]);\r\n      return allRows.filter(d => !topAndBottom.has(d.id));\r\n    }, getMemoOptions(table.options, 'debugRows', 'getCenterRows'));\r\n  }\r\n};\r\n\r\n//\r\n\r\nconst RowSelection = {\r\n  getInitialState: state => {\r\n    return {\r\n      rowSelection: {},\r\n      ...state\r\n    };\r\n  },\r\n  getDefaultOptions: table => {\r\n    return {\r\n      onRowSelectionChange: makeStateUpdater('rowSelection', table),\r\n      enableRowSelection: true,\r\n      enableMultiRowSelection: true,\r\n      enableSubRowSelection: true\r\n      // enableGroupingRowSelection: false,\r\n      // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,\r\n      // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,\r\n    };\r\n  },\r\n  createTable: table => {\r\n    table.setRowSelection = updater => table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater);\r\n    table.resetRowSelection = defaultState => {\r\n      var _table$initialState$r;\r\n      return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});\r\n    };\r\n    table.toggleAllRowsSelected = value => {\r\n      table.setRowSelection(old => {\r\n        value = typeof value !== 'undefined' ? value : !table.getIsAllRowsSelected();\r\n        const rowSelection = {\r\n          ...old\r\n        };\r\n        const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;\r\n\r\n        // We don't use `mutateRowIsSelected` here for performance reasons.\r\n        // All of the rows are flat already, so it wouldn't be worth it\r\n        if (value) {\r\n          preGroupedFlatRows.forEach(row => {\r\n            if (!row.getCanSelect()) {\r\n              return;\r\n            }\r\n            rowSelection[row.id] = true;\r\n          });\r\n        } else {\r\n          preGroupedFlatRows.forEach(row => {\r\n            delete rowSelection[row.id];\r\n          });\r\n        }\r\n        return rowSelection;\r\n      });\r\n    };\r\n    table.toggleAllPageRowsSelected = value => table.setRowSelection(old => {\r\n      const resolvedValue = typeof value !== 'undefined' ? value : !table.getIsAllPageRowsSelected();\r\n      const rowSelection = {\r\n        ...old\r\n      };\r\n      table.getRowModel().rows.forEach(row => {\r\n        mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);\r\n      });\r\n      return rowSelection;\r\n    });\r\n\r\n    // addRowSelectionRange: rowId => {\r\n    //   const {\r\n    //     rows,\r\n    //     rowsById,\r\n    //     options: { selectGroupingRows, selectSubRows },\r\n    //   } = table\r\n\r\n    //   const findSelectedRow = (rows: Row[]) => {\r\n    //     let found\r\n    //     rows.find(d => {\r\n    //       if (d.getIsSelected()) {\r\n    //         found = d\r\n    //         return true\r\n    //       }\r\n    //       const subFound = findSelectedRow(d.subRows || [])\r\n    //       if (subFound) {\r\n    //         found = subFound\r\n    //         return true\r\n    //       }\r\n    //       return false\r\n    //     })\r\n    //     return found\r\n    //   }\r\n\r\n    //   const firstRow = findSelectedRow(rows) || rows[0]\r\n    //   const lastRow = rowsById[rowId]\r\n\r\n    //   let include = false\r\n    //   const selectedRowIds = {}\r\n\r\n    //   const addRow = (row: Row) => {\r\n    //     mutateRowIsSelected(selectedRowIds, row.id, true, {\r\n    //       rowsById,\r\n    //       selectGroupingRows: selectGroupingRows!,\r\n    //       selectSubRows: selectSubRows!,\r\n    //     })\r\n    //   }\r\n\r\n    //   table.rows.forEach(row => {\r\n    //     const isFirstRow = row.id === firstRow.id\r\n    //     const isLastRow = row.id === lastRow.id\r\n\r\n    //     if (isFirstRow || isLastRow) {\r\n    //       if (!include) {\r\n    //         include = true\r\n    //       } else if (include) {\r\n    //         addRow(row)\r\n    //         include = false\r\n    //       }\r\n    //     }\r\n\r\n    //     if (include) {\r\n    //       addRow(row)\r\n    //     }\r\n    //   })\r\n\r\n    //   table.setRowSelection(selectedRowIds)\r\n    // },\r\n    table.getPreSelectedRowModel = () => table.getCoreRowModel();\r\n    table.getSelectedRowModel = memo(() => [table.getState().rowSelection, table.getCoreRowModel()], (rowSelection, rowModel) => {\r\n      if (!Object.keys(rowSelection).length) {\r\n        return {\r\n          rows: [],\r\n          flatRows: [],\r\n          rowsById: {}\r\n        };\r\n      }\r\n      return selectRowsFn(table, rowModel);\r\n    }, getMemoOptions(table.options, 'debugTable', 'getSelectedRowModel'));\r\n    table.getFilteredSelectedRowModel = memo(() => [table.getState().rowSelection, table.getFilteredRowModel()], (rowSelection, rowModel) => {\r\n      if (!Object.keys(rowSelection).length) {\r\n        return {\r\n          rows: [],\r\n          flatRows: [],\r\n          rowsById: {}\r\n        };\r\n      }\r\n      return selectRowsFn(table, rowModel);\r\n    }, getMemoOptions(table.options, 'debugTable', 'getFilteredSelectedRowModel'));\r\n    table.getGroupedSelectedRowModel = memo(() => [table.getState().rowSelection, table.getSortedRowModel()], (rowSelection, rowModel) => {\r\n      if (!Object.keys(rowSelection).length) {\r\n        return {\r\n          rows: [],\r\n          flatRows: [],\r\n          rowsById: {}\r\n        };\r\n      }\r\n      return selectRowsFn(table, rowModel);\r\n    }, getMemoOptions(table.options, 'debugTable', 'getGroupedSelectedRowModel'));\r\n\r\n    ///\r\n\r\n    // getGroupingRowCanSelect: rowId => {\r\n    //   const row = table.getRow(rowId)\r\n\r\n    //   if (!row) {\r\n    //     throw new Error()\r\n    //   }\r\n\r\n    //   if (typeof table.options.enableGroupingRowSelection === 'function') {\r\n    //     return table.options.enableGroupingRowSelection(row)\r\n    //   }\r\n\r\n    //   return table.options.enableGroupingRowSelection ?? false\r\n    // },\r\n\r\n    table.getIsAllRowsSelected = () => {\r\n      const preGroupedFlatRows = table.getFilteredRowModel().flatRows;\r\n      const {\r\n        rowSelection\r\n      } = table.getState();\r\n      let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);\r\n      if (isAllRowsSelected) {\r\n        if (preGroupedFlatRows.some(row => row.getCanSelect() && !rowSelection[row.id])) {\r\n          isAllRowsSelected = false;\r\n        }\r\n      }\r\n      return isAllRowsSelected;\r\n    };\r\n    table.getIsAllPageRowsSelected = () => {\r\n      const paginationFlatRows = table.getPaginationRowModel().flatRows.filter(row => row.getCanSelect());\r\n      const {\r\n        rowSelection\r\n      } = table.getState();\r\n      let isAllPageRowsSelected = !!paginationFlatRows.length;\r\n      if (isAllPageRowsSelected && paginationFlatRows.some(row => !rowSelection[row.id])) {\r\n        isAllPageRowsSelected = false;\r\n      }\r\n      return isAllPageRowsSelected;\r\n    };\r\n    table.getIsSomeRowsSelected = () => {\r\n      var _table$getState$rowSe;\r\n      const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;\r\n      return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;\r\n    };\r\n    table.getIsSomePageRowsSelected = () => {\r\n      const paginationFlatRows = table.getPaginationRowModel().flatRows;\r\n      return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter(row => row.getCanSelect()).some(d => d.getIsSelected() || d.getIsSomeSelected());\r\n    };\r\n    table.getToggleAllRowsSelectedHandler = () => {\r\n      return e => {\r\n        table.toggleAllRowsSelected(e.target.checked);\r\n      };\r\n    };\r\n    table.getToggleAllPageRowsSelectedHandler = () => {\r\n      return e => {\r\n        table.toggleAllPageRowsSelected(e.target.checked);\r\n      };\r\n    };\r\n  },\r\n  createRow: (row, table) => {\r\n    row.toggleSelected = (value, opts) => {\r\n      const isSelected = row.getIsSelected();\r\n      table.setRowSelection(old => {\r\n        var _opts$selectChildren;\r\n        value = typeof value !== 'undefined' ? value : !isSelected;\r\n        if (row.getCanSelect() && isSelected === value) {\r\n          return old;\r\n        }\r\n        const selectedRowIds = {\r\n          ...old\r\n        };\r\n        mutateRowIsSelected(selectedRowIds, row.id, value, (_opts$selectChildren = opts == null ? void 0 : opts.selectChildren) != null ? _opts$selectChildren : true, table);\r\n        return selectedRowIds;\r\n      });\r\n    };\r\n    row.getIsSelected = () => {\r\n      const {\r\n        rowSelection\r\n      } = table.getState();\r\n      return isRowSelected(row, rowSelection);\r\n    };\r\n    row.getIsSomeSelected = () => {\r\n      const {\r\n        rowSelection\r\n      } = table.getState();\r\n      return isSubRowSelected(row, rowSelection) === 'some';\r\n    };\r\n    row.getIsAllSubRowsSelected = () => {\r\n      const {\r\n        rowSelection\r\n      } = table.getState();\r\n      return isSubRowSelected(row, rowSelection) === 'all';\r\n    };\r\n    row.getCanSelect = () => {\r\n      var _table$options$enable;\r\n      if (typeof table.options.enableRowSelection === 'function') {\r\n        return table.options.enableRowSelection(row);\r\n      }\r\n      return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;\r\n    };\r\n    row.getCanSelectSubRows = () => {\r\n      var _table$options$enable2;\r\n      if (typeof table.options.enableSubRowSelection === 'function') {\r\n        return table.options.enableSubRowSelection(row);\r\n      }\r\n      return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;\r\n    };\r\n    row.getCanMultiSelect = () => {\r\n      var _table$options$enable3;\r\n      if (typeof table.options.enableMultiRowSelection === 'function') {\r\n        return table.options.enableMultiRowSelection(row);\r\n      }\r\n      return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;\r\n    };\r\n    row.getToggleSelectedHandler = () => {\r\n      const canSelect = row.getCanSelect();\r\n      return e => {\r\n        var _target;\r\n        if (!canSelect) return;\r\n        row.toggleSelected((_target = e.target) == null ? void 0 : _target.checked);\r\n      };\r\n    };\r\n  }\r\n};\r\nconst mutateRowIsSelected = (selectedRowIds, id, value, includeChildren, table) => {\r\n  var _row$subRows;\r\n  const row = table.getRow(id, true);\r\n\r\n  // const isGrouped = row.getIsGrouped()\r\n\r\n  // if ( // TODO: enforce grouping row selection rules\r\n  //   !isGrouped ||\r\n  //   (isGrouped && table.options.enableGroupingRowSelection)\r\n  // ) {\r\n  if (value) {\r\n    if (!row.getCanMultiSelect()) {\r\n      Object.keys(selectedRowIds).forEach(key => delete selectedRowIds[key]);\r\n    }\r\n    if (row.getCanSelect()) {\r\n      selectedRowIds[id] = true;\r\n    }\r\n  } else {\r\n    delete selectedRowIds[id];\r\n  }\r\n  // }\r\n\r\n  if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {\r\n    row.subRows.forEach(row => mutateRowIsSelected(selectedRowIds, row.id, value, includeChildren, table));\r\n  }\r\n};\r\nfunction selectRowsFn(table, rowModel) {\r\n  const rowSelection = table.getState().rowSelection;\r\n  const newSelectedFlatRows = [];\r\n  const newSelectedRowsById = {};\r\n\r\n  // Filters top level and nested rows\r\n  const recurseRows = function (rows, depth) {\r\n    return rows.map(row => {\r\n      var _row$subRows2;\r\n      const isSelected = isRowSelected(row, rowSelection);\r\n      if (isSelected) {\r\n        newSelectedFlatRows.push(row);\r\n        newSelectedRowsById[row.id] = row;\r\n      }\r\n      if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {\r\n        row = {\r\n          ...row,\r\n          subRows: recurseRows(row.subRows)\r\n        };\r\n      }\r\n      if (isSelected) {\r\n        return row;\r\n      }\r\n    }).filter(Boolean);\r\n  };\r\n  return {\r\n    rows: recurseRows(rowModel.rows),\r\n    flatRows: newSelectedFlatRows,\r\n    rowsById: newSelectedRowsById\r\n  };\r\n}\r\nfunction isRowSelected(row, selection) {\r\n  var _selection$row$id;\r\n  return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;\r\n}\r\nfunction isSubRowSelected(row, selection, table) {\r\n  var _row$subRows3;\r\n  if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length)) return false;\r\n  let allChildrenSelected = true;\r\n  let someSelected = false;\r\n  row.subRows.forEach(subRow => {\r\n    // Bail out early if we know both of these\r\n    if (someSelected && !allChildrenSelected) {\r\n      return;\r\n    }\r\n    if (subRow.getCanSelect()) {\r\n      if (isRowSelected(subRow, selection)) {\r\n        someSelected = true;\r\n      } else {\r\n        allChildrenSelected = false;\r\n      }\r\n    }\r\n\r\n    // Check row selection of nested subrows\r\n    if (subRow.subRows && subRow.subRows.length) {\r\n      const subRowChildrenSelected = isSubRowSelected(subRow, selection);\r\n      if (subRowChildrenSelected === 'all') {\r\n        someSelected = true;\r\n      } else if (subRowChildrenSelected === 'some') {\r\n        someSelected = true;\r\n        allChildrenSelected = false;\r\n      } else {\r\n        allChildrenSelected = false;\r\n      }\r\n    }\r\n  });\r\n  return allChildrenSelected ? 'all' : someSelected ? 'some' : false;\r\n}\r\n\r\nconst reSplitAlphaNumeric = /([0-9]+)/gm;\r\nconst alphanumeric = (rowA, rowB, columnId) => {\r\n  return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\r\n};\r\nconst alphanumericCaseSensitive = (rowA, rowB, columnId) => {\r\n  return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\r\n};\r\n\r\n// The text filter is more basic (less numeric support)\r\n// but is much faster\r\nconst text = (rowA, rowB, columnId) => {\r\n  return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\r\n};\r\n\r\n// The text filter is more basic (less numeric support)\r\n// but is much faster\r\nconst textCaseSensitive = (rowA, rowB, columnId) => {\r\n  return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\r\n};\r\nconst datetime = (rowA, rowB, columnId) => {\r\n  const a = rowA.getValue(columnId);\r\n  const b = rowB.getValue(columnId);\r\n\r\n  // Can handle nullish values\r\n  // Use > and < because == (and ===) doesn't work with\r\n  // Date objects (would require calling getTime()).\r\n  return a > b ? 1 : a < b ? -1 : 0;\r\n};\r\nconst basic = (rowA, rowB, columnId) => {\r\n  return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));\r\n};\r\n\r\n// Utils\r\n\r\nfunction compareBasic(a, b) {\r\n  return a === b ? 0 : a > b ? 1 : -1;\r\n}\r\nfunction toString(a) {\r\n  if (typeof a === 'number') {\r\n    if (isNaN(a) || a === Infinity || a === -Infinity) {\r\n      return '';\r\n    }\r\n    return String(a);\r\n  }\r\n  if (typeof a === 'string') {\r\n    return a;\r\n  }\r\n  return '';\r\n}\r\n\r\n// Mixed sorting is slow, but very inclusive of many edge cases.\r\n// It handles numbers, mixed alphanumeric combinations, and even\r\n// null, undefined, and Infinity\r\nfunction compareAlphanumeric(aStr, bStr) {\r\n  // Split on number groups, but keep the delimiter\r\n  // Then remove falsey split values\r\n  const a = aStr.split(reSplitAlphaNumeric).filter(Boolean);\r\n  const b = bStr.split(reSplitAlphaNumeric).filter(Boolean);\r\n\r\n  // While\r\n  while (a.length && b.length) {\r\n    const aa = a.shift();\r\n    const bb = b.shift();\r\n    const an = parseInt(aa, 10);\r\n    const bn = parseInt(bb, 10);\r\n    const combo = [an, bn].sort();\r\n\r\n    // Both are string\r\n    if (isNaN(combo[0])) {\r\n      if (aa > bb) {\r\n        return 1;\r\n      }\r\n      if (bb > aa) {\r\n        return -1;\r\n      }\r\n      continue;\r\n    }\r\n\r\n    // One is a string, one is a number\r\n    if (isNaN(combo[1])) {\r\n      return isNaN(an) ? -1 : 1;\r\n    }\r\n\r\n    // Both are numbers\r\n    if (an > bn) {\r\n      return 1;\r\n    }\r\n    if (bn > an) {\r\n      return -1;\r\n    }\r\n  }\r\n  return a.length - b.length;\r\n}\r\n\r\n// Exports\r\n\r\nconst sortingFns = {\r\n  alphanumeric,\r\n  alphanumericCaseSensitive,\r\n  text,\r\n  textCaseSensitive,\r\n  datetime,\r\n  basic\r\n};\r\n\r\n//\r\n\r\nconst RowSorting = {\r\n  getInitialState: state => {\r\n    return {\r\n      sorting: [],\r\n      ...state\r\n    };\r\n  },\r\n  getDefaultColumnDef: () => {\r\n    return {\r\n      sortingFn: 'auto',\r\n      sortUndefined: 1\r\n    };\r\n  },\r\n  getDefaultOptions: table => {\r\n    return {\r\n      onSortingChange: makeStateUpdater('sorting', table),\r\n      isMultiSortEvent: e => {\r\n        return e.shiftKey;\r\n      }\r\n    };\r\n  },\r\n  createColumn: (column, table) => {\r\n    column.getAutoSortingFn = () => {\r\n      const firstRows = table.getFilteredRowModel().flatRows.slice(10);\r\n      let isString = false;\r\n      for (const row of firstRows) {\r\n        const value = row == null ? void 0 : row.getValue(column.id);\r\n        if (Object.prototype.toString.call(value) === '[object Date]') {\r\n          return sortingFns.datetime;\r\n        }\r\n        if (typeof value === 'string') {\r\n          isString = true;\r\n          if (value.split(reSplitAlphaNumeric).length > 1) {\r\n            return sortingFns.alphanumeric;\r\n          }\r\n        }\r\n      }\r\n      if (isString) {\r\n        return sortingFns.text;\r\n      }\r\n      return sortingFns.basic;\r\n    };\r\n    column.getAutoSortDir = () => {\r\n      const firstRow = table.getFilteredRowModel().flatRows[0];\r\n      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\r\n      if (typeof value === 'string') {\r\n        return 'asc';\r\n      }\r\n      return 'desc';\r\n    };\r\n    column.getSortingFn = () => {\r\n      var _table$options$sortin, _table$options$sortin2;\r\n      if (!column) {\r\n        throw new Error();\r\n      }\r\n      return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === 'auto' ? column.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column.columnDef.sortingFn];\r\n    };\r\n    column.toggleSorting = (desc, multi) => {\r\n      // if (column.columns.length) {\r\n      //   column.columns.forEach((c, i) => {\r\n      //     if (c.id) {\r\n      //       table.toggleColumnSorting(c.id, undefined, multi || !!i)\r\n      //     }\r\n      //   })\r\n      //   return\r\n      // }\r\n\r\n      // this needs to be outside of table.setSorting to be in sync with rerender\r\n      const nextSortingOrder = column.getNextSortingOrder();\r\n      const hasManualValue = typeof desc !== 'undefined' && desc !== null;\r\n      table.setSorting(old => {\r\n        // Find any existing sorting for this column\r\n        const existingSorting = old == null ? void 0 : old.find(d => d.id === column.id);\r\n        const existingIndex = old == null ? void 0 : old.findIndex(d => d.id === column.id);\r\n        let newSorting = [];\r\n\r\n        // What should we do with this sort action?\r\n        let sortAction;\r\n        let nextDesc = hasManualValue ? desc : nextSortingOrder === 'desc';\r\n\r\n        // Multi-mode\r\n        if (old != null && old.length && column.getCanMultiSort() && multi) {\r\n          if (existingSorting) {\r\n            sortAction = 'toggle';\r\n          } else {\r\n            sortAction = 'add';\r\n          }\r\n        } else {\r\n          // Normal mode\r\n          if (old != null && old.length && existingIndex !== old.length - 1) {\r\n            sortAction = 'replace';\r\n          } else if (existingSorting) {\r\n            sortAction = 'toggle';\r\n          } else {\r\n            sortAction = 'replace';\r\n          }\r\n        }\r\n\r\n        // Handle toggle states that will remove the sorting\r\n        if (sortAction === 'toggle') {\r\n          // If we are \"actually\" toggling (not a manual set value), should we remove the sorting?\r\n          if (!hasManualValue) {\r\n            // Is our intention to remove?\r\n            if (!nextSortingOrder) {\r\n              sortAction = 'remove';\r\n            }\r\n          }\r\n        }\r\n        if (sortAction === 'add') {\r\n          var _table$options$maxMul;\r\n          newSorting = [...old, {\r\n            id: column.id,\r\n            desc: nextDesc\r\n          }];\r\n          // Take latest n columns\r\n          newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));\r\n        } else if (sortAction === 'toggle') {\r\n          // This flips (or sets) the\r\n          newSorting = old.map(d => {\r\n            if (d.id === column.id) {\r\n              return {\r\n                ...d,\r\n                desc: nextDesc\r\n              };\r\n            }\r\n            return d;\r\n          });\r\n        } else if (sortAction === 'remove') {\r\n          newSorting = old.filter(d => d.id !== column.id);\r\n        } else {\r\n          newSorting = [{\r\n            id: column.id,\r\n            desc: nextDesc\r\n          }];\r\n        }\r\n        return newSorting;\r\n      });\r\n    };\r\n    column.getFirstSortDir = () => {\r\n      var _ref, _column$columnDef$sor;\r\n      const sortDescFirst = (_ref = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column.getAutoSortDir() === 'desc';\r\n      return sortDescFirst ? 'desc' : 'asc';\r\n    };\r\n    column.getNextSortingOrder = multi => {\r\n      var _table$options$enable, _table$options$enable2;\r\n      const firstSortDirection = column.getFirstSortDir();\r\n      const isSorted = column.getIsSorted();\r\n      if (!isSorted) {\r\n        return firstSortDirection;\r\n      }\r\n      if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && (\r\n      // If enableSortRemove, enable in general\r\n      multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true) // If multi, don't allow if enableMultiRemove))\r\n      ) {\r\n        return false;\r\n      }\r\n      return isSorted === 'desc' ? 'asc' : 'desc';\r\n    };\r\n    column.getCanSort = () => {\r\n      var _column$columnDef$ena, _table$options$enable3;\r\n      return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column.accessorFn;\r\n    };\r\n    column.getCanMultiSort = () => {\r\n      var _ref2, _column$columnDef$ena2;\r\n      return (_ref2 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column.accessorFn;\r\n    };\r\n    column.getIsSorted = () => {\r\n      var _table$getState$sorti;\r\n      const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find(d => d.id === column.id);\r\n      return !columnSort ? false : columnSort.desc ? 'desc' : 'asc';\r\n    };\r\n    column.getSortIndex = () => {\r\n      var _table$getState$sorti2, _table$getState$sorti3;\r\n      return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex(d => d.id === column.id)) != null ? _table$getState$sorti2 : -1;\r\n    };\r\n    column.clearSorting = () => {\r\n      //clear sorting for just 1 column\r\n      table.setSorting(old => old != null && old.length ? old.filter(d => d.id !== column.id) : []);\r\n    };\r\n    column.getToggleSortingHandler = () => {\r\n      const canSort = column.getCanSort();\r\n      return e => {\r\n        if (!canSort) return;\r\n        e.persist == null || e.persist();\r\n        column.toggleSorting == null || column.toggleSorting(undefined, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e) : false);\r\n      };\r\n    };\r\n  },\r\n  createTable: table => {\r\n    table.setSorting = updater => table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater);\r\n    table.resetSorting = defaultState => {\r\n      var _table$initialState$s, _table$initialState;\r\n      table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);\r\n    };\r\n    table.getPreSortedRowModel = () => table.getGroupedRowModel();\r\n    table.getSortedRowModel = () => {\r\n      if (!table._getSortedRowModel && table.options.getSortedRowModel) {\r\n        table._getSortedRowModel = table.options.getSortedRowModel(table);\r\n      }\r\n      if (table.options.manualSorting || !table._getSortedRowModel) {\r\n        return table.getPreSortedRowModel();\r\n      }\r\n      return table._getSortedRowModel();\r\n    };\r\n  }\r\n};\r\n\r\nconst builtInFeatures = [Headers, ColumnVisibility, ColumnOrdering, ColumnPinning, ColumnFaceting, ColumnFiltering, GlobalFaceting,\r\n//depends on ColumnFaceting\r\nGlobalFiltering,\r\n//depends on ColumnFiltering\r\nRowSorting, ColumnGrouping,\r\n//depends on RowSorting\r\nRowExpanding, RowPagination, RowPinning, RowSelection, ColumnSizing];\r\n\r\n//\r\n\r\nfunction createTable(options) {\r\n  var _options$_features, _options$initialState;\r\n  if ( true && (options.debugAll || options.debugTable)) {\r\n    console.info('Creating Table Instance...');\r\n  }\r\n  const _features = [...builtInFeatures, ...((_options$_features = options._features) != null ? _options$_features : [])];\r\n  let table = {\r\n    _features\r\n  };\r\n  const defaultOptions = table._features.reduce((obj, feature) => {\r\n    return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));\r\n  }, {});\r\n  const mergeOptions = options => {\r\n    if (table.options.mergeOptions) {\r\n      return table.options.mergeOptions(defaultOptions, options);\r\n    }\r\n    return {\r\n      ...defaultOptions,\r\n      ...options\r\n    };\r\n  };\r\n  const coreInitialState = {};\r\n  let initialState = {\r\n    ...coreInitialState,\r\n    ...((_options$initialState = options.initialState) != null ? _options$initialState : {})\r\n  };\r\n  table._features.forEach(feature => {\r\n    var _feature$getInitialSt;\r\n    initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;\r\n  });\r\n  const queued = [];\r\n  let queuedTimeout = false;\r\n  const coreInstance = {\r\n    _features,\r\n    options: {\r\n      ...defaultOptions,\r\n      ...options\r\n    },\r\n    initialState,\r\n    _queue: cb => {\r\n      queued.push(cb);\r\n      if (!queuedTimeout) {\r\n        queuedTimeout = true;\r\n\r\n        // Schedule a microtask to run the queued callbacks after\r\n        // the current call stack (render, etc) has finished.\r\n        Promise.resolve().then(() => {\r\n          while (queued.length) {\r\n            queued.shift()();\r\n          }\r\n          queuedTimeout = false;\r\n        }).catch(error => setTimeout(() => {\r\n          throw error;\r\n        }));\r\n      }\r\n    },\r\n    reset: () => {\r\n      table.setState(table.initialState);\r\n    },\r\n    setOptions: updater => {\r\n      const newOptions = functionalUpdate(updater, table.options);\r\n      table.options = mergeOptions(newOptions);\r\n    },\r\n    getState: () => {\r\n      return table.options.state;\r\n    },\r\n    setState: updater => {\r\n      table.options.onStateChange == null || table.options.onStateChange(updater);\r\n    },\r\n    _getRowId: (row, index, parent) => {\r\n      var _table$options$getRow;\r\n      return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index, parent)) != null ? _table$options$getRow : `${parent ? [parent.id, index].join('.') : index}`;\r\n    },\r\n    getCoreRowModel: () => {\r\n      if (!table._getCoreRowModel) {\r\n        table._getCoreRowModel = table.options.getCoreRowModel(table);\r\n      }\r\n      return table._getCoreRowModel();\r\n    },\r\n    // The final calls start at the bottom of the model,\r\n    // expanded rows, which then work their way up\r\n\r\n    getRowModel: () => {\r\n      return table.getPaginationRowModel();\r\n    },\r\n    //in next version, we should just pass in the row model as the optional 2nd arg\r\n    getRow: (id, searchAll) => {\r\n      let row = (searchAll ? table.getPrePaginationRowModel() : table.getRowModel()).rowsById[id];\r\n      if (!row) {\r\n        row = table.getCoreRowModel().rowsById[id];\r\n        if (!row) {\r\n          if (true) {\r\n            throw new Error(`getRow could not find row with ID: ${id}`);\r\n          }\r\n          throw new Error();\r\n        }\r\n      }\r\n      return row;\r\n    },\r\n    _getDefaultColumnDef: memo(() => [table.options.defaultColumn], defaultColumn => {\r\n      var _defaultColumn;\r\n      defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};\r\n      return {\r\n        header: props => {\r\n          const resolvedColumnDef = props.header.column.columnDef;\r\n          if (resolvedColumnDef.accessorKey) {\r\n            return resolvedColumnDef.accessorKey;\r\n          }\r\n          if (resolvedColumnDef.accessorFn) {\r\n            return resolvedColumnDef.id;\r\n          }\r\n          return null;\r\n        },\r\n        // footer: props => props.header.column.id,\r\n        cell: props => {\r\n          var _props$renderValue$to, _props$renderValue;\r\n          return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;\r\n        },\r\n        ...table._features.reduce((obj, feature) => {\r\n          return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());\r\n        }, {}),\r\n        ...defaultColumn\r\n      };\r\n    }, getMemoOptions(options, 'debugColumns', '_getDefaultColumnDef')),\r\n    _getColumnDefs: () => table.options.columns,\r\n    getAllColumns: memo(() => [table._getColumnDefs()], columnDefs => {\r\n      const recurseColumns = function (columnDefs, parent, depth) {\r\n        if (depth === void 0) {\r\n          depth = 0;\r\n        }\r\n        return columnDefs.map(columnDef => {\r\n          const column = createColumn(table, columnDef, depth, parent);\r\n          const groupingColumnDef = columnDef;\r\n          column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];\r\n          return column;\r\n        });\r\n      };\r\n      return recurseColumns(columnDefs);\r\n    }, getMemoOptions(options, 'debugColumns', 'getAllColumns')),\r\n    getAllFlatColumns: memo(() => [table.getAllColumns()], allColumns => {\r\n      return allColumns.flatMap(column => {\r\n        return column.getFlatColumns();\r\n      });\r\n    }, getMemoOptions(options, 'debugColumns', 'getAllFlatColumns')),\r\n    _getAllFlatColumnsById: memo(() => [table.getAllFlatColumns()], flatColumns => {\r\n      return flatColumns.reduce((acc, column) => {\r\n        acc[column.id] = column;\r\n        return acc;\r\n      }, {});\r\n    }, getMemoOptions(options, 'debugColumns', 'getAllFlatColumnsById')),\r\n    getAllLeafColumns: memo(() => [table.getAllColumns(), table._getOrderColumnsFn()], (allColumns, orderColumns) => {\r\n      let leafColumns = allColumns.flatMap(column => column.getLeafColumns());\r\n      return orderColumns(leafColumns);\r\n    }, getMemoOptions(options, 'debugColumns', 'getAllLeafColumns')),\r\n    getColumn: columnId => {\r\n      const column = table._getAllFlatColumnsById()[columnId];\r\n      if ( true && !column) {\r\n        console.error(`[Table] Column with id '${columnId}' does not exist.`);\r\n      }\r\n      return column;\r\n    }\r\n  };\r\n  Object.assign(table, coreInstance);\r\n  for (let index = 0; index < table._features.length; index++) {\r\n    const feature = table._features[index];\r\n    feature == null || feature.createTable == null || feature.createTable(table);\r\n  }\r\n  return table;\r\n}\r\n\r\nfunction getCoreRowModel() {\r\n  return table => memo(() => [table.options.data], data => {\r\n    const rowModel = {\r\n      rows: [],\r\n      flatRows: [],\r\n      rowsById: {}\r\n    };\r\n    const accessRows = function (originalRows, depth, parentRow) {\r\n      if (depth === void 0) {\r\n        depth = 0;\r\n      }\r\n      const rows = [];\r\n      for (let i = 0; i < originalRows.length; i++) {\r\n        // This could be an expensive check at scale, so we should move it somewhere else, but where?\r\n        // if (!id) {\r\n        //   if (process.env.NODE_ENV !== 'production') {\r\n        //     throw new Error(`getRowId expected an ID, but got ${id}`)\r\n        //   }\r\n        // }\r\n\r\n        // Make the row\r\n        const row = createRow(table, table._getRowId(originalRows[i], i, parentRow), originalRows[i], i, depth, undefined, parentRow == null ? void 0 : parentRow.id);\r\n\r\n        // Keep track of every row in a flat array\r\n        rowModel.flatRows.push(row);\r\n        // Also keep track of every row by its ID\r\n        rowModel.rowsById[row.id] = row;\r\n        // Push table row into parent\r\n        rows.push(row);\r\n\r\n        // Get the original subrows\r\n        if (table.options.getSubRows) {\r\n          var _row$originalSubRows;\r\n          row.originalSubRows = table.options.getSubRows(originalRows[i], i);\r\n\r\n          // Then recursively access them\r\n          if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {\r\n            row.subRows = accessRows(row.originalSubRows, depth + 1, row);\r\n          }\r\n        }\r\n      }\r\n      return rows;\r\n    };\r\n    rowModel.rows = accessRows(data);\r\n    return rowModel;\r\n  }, getMemoOptions(table.options, 'debugTable', 'getRowModel', () => table._autoResetPageIndex()));\r\n}\r\n\r\nfunction getExpandedRowModel() {\r\n  return table => memo(() => [table.getState().expanded, table.getPreExpandedRowModel(), table.options.paginateExpandedRows], (expanded, rowModel, paginateExpandedRows) => {\r\n    if (!rowModel.rows.length || expanded !== true && !Object.keys(expanded != null ? expanded : {}).length) {\r\n      return rowModel;\r\n    }\r\n    if (!paginateExpandedRows) {\r\n      // Only expand rows at this point if they are being paginated\r\n      return rowModel;\r\n    }\r\n    return expandRows(rowModel);\r\n  }, getMemoOptions(table.options, 'debugTable', 'getExpandedRowModel'));\r\n}\r\nfunction expandRows(rowModel) {\r\n  const expandedRows = [];\r\n  const handleRow = row => {\r\n    var _row$subRows;\r\n    expandedRows.push(row);\r\n    if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getIsExpanded()) {\r\n      row.subRows.forEach(handleRow);\r\n    }\r\n  };\r\n  rowModel.rows.forEach(handleRow);\r\n  return {\r\n    rows: expandedRows,\r\n    flatRows: rowModel.flatRows,\r\n    rowsById: rowModel.rowsById\r\n  };\r\n}\r\n\r\nfunction getFacetedMinMaxValues() {\r\n  return (table, columnId) => memo(() => {\r\n    var _table$getColumn;\r\n    return [(_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()];\r\n  }, facetedRowModel => {\r\n    var _facetedRowModel$flat;\r\n    if (!facetedRowModel) return undefined;\r\n    const firstValue = (_facetedRowModel$flat = facetedRowModel.flatRows[0]) == null ? void 0 : _facetedRowModel$flat.getUniqueValues(columnId);\r\n    if (typeof firstValue === 'undefined') {\r\n      return undefined;\r\n    }\r\n    let facetedMinMaxValues = [firstValue, firstValue];\r\n    for (let i = 0; i < facetedRowModel.flatRows.length; i++) {\r\n      const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);\r\n      for (let j = 0; j < values.length; j++) {\r\n        const value = values[j];\r\n        if (value < facetedMinMaxValues[0]) {\r\n          facetedMinMaxValues[0] = value;\r\n        } else if (value > facetedMinMaxValues[1]) {\r\n          facetedMinMaxValues[1] = value;\r\n        }\r\n      }\r\n    }\r\n    return facetedMinMaxValues;\r\n  }, getMemoOptions(table.options, 'debugTable', 'getFacetedMinMaxValues'));\r\n}\r\n\r\nfunction filterRows(rows, filterRowImpl, table) {\r\n  if (table.options.filterFromLeafRows) {\r\n    return filterRowModelFromLeafs(rows, filterRowImpl, table);\r\n  }\r\n  return filterRowModelFromRoot(rows, filterRowImpl, table);\r\n}\r\nfunction filterRowModelFromLeafs(rowsToFilter, filterRow, table) {\r\n  var _table$options$maxLea;\r\n  const newFilteredFlatRows = [];\r\n  const newFilteredRowsById = {};\r\n  const maxDepth = (_table$options$maxLea = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea : 100;\r\n  const recurseFilterRows = function (rowsToFilter, depth) {\r\n    if (depth === void 0) {\r\n      depth = 0;\r\n    }\r\n    const rows = [];\r\n\r\n    // Filter from children up first\r\n    for (let i = 0; i < rowsToFilter.length; i++) {\r\n      var _row$subRows;\r\n      let row = rowsToFilter[i];\r\n      const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\r\n      newRow.columnFilters = row.columnFilters;\r\n      if ((_row$subRows = row.subRows) != null && _row$subRows.length && depth < maxDepth) {\r\n        newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\r\n        row = newRow;\r\n        if (filterRow(row) && !newRow.subRows.length) {\r\n          rows.push(row);\r\n          newFilteredRowsById[row.id] = row;\r\n          newFilteredFlatRows.push(row);\r\n          continue;\r\n        }\r\n        if (filterRow(row) || newRow.subRows.length) {\r\n          rows.push(row);\r\n          newFilteredRowsById[row.id] = row;\r\n          newFilteredFlatRows.push(row);\r\n          continue;\r\n        }\r\n      } else {\r\n        row = newRow;\r\n        if (filterRow(row)) {\r\n          rows.push(row);\r\n          newFilteredRowsById[row.id] = row;\r\n          newFilteredFlatRows.push(row);\r\n        }\r\n      }\r\n    }\r\n    return rows;\r\n  };\r\n  return {\r\n    rows: recurseFilterRows(rowsToFilter),\r\n    flatRows: newFilteredFlatRows,\r\n    rowsById: newFilteredRowsById\r\n  };\r\n}\r\nfunction filterRowModelFromRoot(rowsToFilter, filterRow, table) {\r\n  var _table$options$maxLea2;\r\n  const newFilteredFlatRows = [];\r\n  const newFilteredRowsById = {};\r\n  const maxDepth = (_table$options$maxLea2 = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea2 : 100;\r\n\r\n  // Filters top level and nested rows\r\n  const recurseFilterRows = function (rowsToFilter, depth) {\r\n    if (depth === void 0) {\r\n      depth = 0;\r\n    }\r\n    // Filter from parents downward first\r\n\r\n    const rows = [];\r\n\r\n    // Apply the filter to any subRows\r\n    for (let i = 0; i < rowsToFilter.length; i++) {\r\n      let row = rowsToFilter[i];\r\n      const pass = filterRow(row);\r\n      if (pass) {\r\n        var _row$subRows2;\r\n        if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length && depth < maxDepth) {\r\n          const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\r\n          newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\r\n          row = newRow;\r\n        }\r\n        rows.push(row);\r\n        newFilteredFlatRows.push(row);\r\n        newFilteredRowsById[row.id] = row;\r\n      }\r\n    }\r\n    return rows;\r\n  };\r\n  return {\r\n    rows: recurseFilterRows(rowsToFilter),\r\n    flatRows: newFilteredFlatRows,\r\n    rowsById: newFilteredRowsById\r\n  };\r\n}\r\n\r\nfunction getFacetedRowModel() {\r\n  return (table, columnId) => memo(() => [table.getPreFilteredRowModel(), table.getState().columnFilters, table.getState().globalFilter, table.getFilteredRowModel()], (preRowModel, columnFilters, globalFilter) => {\r\n    if (!preRowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\r\n      return preRowModel;\r\n    }\r\n    const filterableIds = [...columnFilters.map(d => d.id).filter(d => d !== columnId), globalFilter ? '__global__' : undefined].filter(Boolean);\r\n    const filterRowsImpl = row => {\r\n      // Horizontally filter rows through each column\r\n      for (let i = 0; i < filterableIds.length; i++) {\r\n        if (row.columnFilters[filterableIds[i]] === false) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n    return filterRows(preRowModel.rows, filterRowsImpl, table);\r\n  }, getMemoOptions(table.options, 'debugTable', 'getFacetedRowModel'));\r\n}\r\n\r\nfunction getFacetedUniqueValues() {\r\n  return (table, columnId) => memo(() => {\r\n    var _table$getColumn;\r\n    return [(_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()];\r\n  }, facetedRowModel => {\r\n    if (!facetedRowModel) return new Map();\r\n    let facetedUniqueValues = new Map();\r\n    for (let i = 0; i < facetedRowModel.flatRows.length; i++) {\r\n      const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);\r\n      for (let j = 0; j < values.length; j++) {\r\n        const value = values[j];\r\n        if (facetedUniqueValues.has(value)) {\r\n          var _facetedUniqueValues$;\r\n          facetedUniqueValues.set(value, ((_facetedUniqueValues$ = facetedUniqueValues.get(value)) != null ? _facetedUniqueValues$ : 0) + 1);\r\n        } else {\r\n          facetedUniqueValues.set(value, 1);\r\n        }\r\n      }\r\n    }\r\n    return facetedUniqueValues;\r\n  }, getMemoOptions(table.options, 'debugTable', `getFacetedUniqueValues_${columnId}`));\r\n}\r\n\r\nfunction getFilteredRowModel() {\r\n  return table => memo(() => [table.getPreFilteredRowModel(), table.getState().columnFilters, table.getState().globalFilter], (rowModel, columnFilters, globalFilter) => {\r\n    if (!rowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\r\n      for (let i = 0; i < rowModel.flatRows.length; i++) {\r\n        rowModel.flatRows[i].columnFilters = {};\r\n        rowModel.flatRows[i].columnFiltersMeta = {};\r\n      }\r\n      return rowModel;\r\n    }\r\n    const resolvedColumnFilters = [];\r\n    const resolvedGlobalFilters = [];\r\n    (columnFilters != null ? columnFilters : []).forEach(d => {\r\n      var _filterFn$resolveFilt;\r\n      const column = table.getColumn(d.id);\r\n      if (!column) {\r\n        return;\r\n      }\r\n      const filterFn = column.getFilterFn();\r\n      if (!filterFn) {\r\n        if (true) {\r\n          console.warn(`Could not find a valid 'column.filterFn' for column with the ID: ${column.id}.`);\r\n        }\r\n        return;\r\n      }\r\n      resolvedColumnFilters.push({\r\n        id: d.id,\r\n        filterFn,\r\n        resolvedValue: (_filterFn$resolveFilt = filterFn.resolveFilterValue == null ? void 0 : filterFn.resolveFilterValue(d.value)) != null ? _filterFn$resolveFilt : d.value\r\n      });\r\n    });\r\n    const filterableIds = columnFilters.map(d => d.id);\r\n    const globalFilterFn = table.getGlobalFilterFn();\r\n    const globallyFilterableColumns = table.getAllLeafColumns().filter(column => column.getCanGlobalFilter());\r\n    if (globalFilter && globalFilterFn && globallyFilterableColumns.length) {\r\n      filterableIds.push('__global__');\r\n      globallyFilterableColumns.forEach(column => {\r\n        var _globalFilterFn$resol;\r\n        resolvedGlobalFilters.push({\r\n          id: column.id,\r\n          filterFn: globalFilterFn,\r\n          resolvedValue: (_globalFilterFn$resol = globalFilterFn.resolveFilterValue == null ? void 0 : globalFilterFn.resolveFilterValue(globalFilter)) != null ? _globalFilterFn$resol : globalFilter\r\n        });\r\n      });\r\n    }\r\n    let currentColumnFilter;\r\n    let currentGlobalFilter;\r\n\r\n    // Flag the prefiltered row model with each filter state\r\n    for (let j = 0; j < rowModel.flatRows.length; j++) {\r\n      const row = rowModel.flatRows[j];\r\n      row.columnFilters = {};\r\n      if (resolvedColumnFilters.length) {\r\n        for (let i = 0; i < resolvedColumnFilters.length; i++) {\r\n          currentColumnFilter = resolvedColumnFilters[i];\r\n          const id = currentColumnFilter.id;\r\n\r\n          // Tag the row with the column filter state\r\n          row.columnFilters[id] = currentColumnFilter.filterFn(row, id, currentColumnFilter.resolvedValue, filterMeta => {\r\n            row.columnFiltersMeta[id] = filterMeta;\r\n          });\r\n        }\r\n      }\r\n      if (resolvedGlobalFilters.length) {\r\n        for (let i = 0; i < resolvedGlobalFilters.length; i++) {\r\n          currentGlobalFilter = resolvedGlobalFilters[i];\r\n          const id = currentGlobalFilter.id;\r\n          // Tag the row with the first truthy global filter state\r\n          if (currentGlobalFilter.filterFn(row, id, currentGlobalFilter.resolvedValue, filterMeta => {\r\n            row.columnFiltersMeta[id] = filterMeta;\r\n          })) {\r\n            row.columnFilters.__global__ = true;\r\n            break;\r\n          }\r\n        }\r\n        if (row.columnFilters.__global__ !== true) {\r\n          row.columnFilters.__global__ = false;\r\n        }\r\n      }\r\n    }\r\n    const filterRowsImpl = row => {\r\n      // Horizontally filter rows through each column\r\n      for (let i = 0; i < filterableIds.length; i++) {\r\n        if (row.columnFilters[filterableIds[i]] === false) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n\r\n    // Filter final rows using all of the active filters\r\n    return filterRows(rowModel.rows, filterRowsImpl, table);\r\n  }, getMemoOptions(table.options, 'debugTable', 'getFilteredRowModel', () => table._autoResetPageIndex()));\r\n}\r\n\r\nfunction getGroupedRowModel() {\r\n  return table => memo(() => [table.getState().grouping, table.getPreGroupedRowModel()], (grouping, rowModel) => {\r\n    if (!rowModel.rows.length || !grouping.length) {\r\n      return rowModel;\r\n    }\r\n\r\n    // Filter the grouping list down to columns that exist\r\n    const existingGrouping = grouping.filter(columnId => table.getColumn(columnId));\r\n    const groupedFlatRows = [];\r\n    const groupedRowsById = {};\r\n    // const onlyGroupedFlatRows: Row[] = [];\r\n    // const onlyGroupedRowsById: Record<RowId, Row> = {};\r\n    // const nonGroupedFlatRows: Row[] = [];\r\n    // const nonGroupedRowsById: Record<RowId, Row> = {};\r\n\r\n    // Recursively group the data\r\n    const groupUpRecursively = function (rows, depth, parentId) {\r\n      if (depth === void 0) {\r\n        depth = 0;\r\n      }\r\n      // Grouping depth has been been met\r\n      // Stop grouping and simply rewrite thd depth and row relationships\r\n      if (depth >= existingGrouping.length) {\r\n        return rows.map(row => {\r\n          row.depth = depth;\r\n          groupedFlatRows.push(row);\r\n          groupedRowsById[row.id] = row;\r\n          if (row.subRows) {\r\n            row.subRows = groupUpRecursively(row.subRows, depth + 1, row.id);\r\n          }\r\n          return row;\r\n        });\r\n      }\r\n      const columnId = existingGrouping[depth];\r\n\r\n      // Group the rows together for this level\r\n      const rowGroupsMap = groupBy(rows, columnId);\r\n\r\n      // Peform aggregations for each group\r\n      const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map((_ref, index) => {\r\n        let [groupingValue, groupedRows] = _ref;\r\n        let id = `${columnId}:${groupingValue}`;\r\n        id = parentId ? `${parentId}>${id}` : id;\r\n\r\n        // First, Recurse to group sub rows before aggregation\r\n        const subRows = groupUpRecursively(groupedRows, depth + 1, id);\r\n\r\n        // Flatten the leaf rows of the rows in this group\r\n        const leafRows = depth ? flattenBy(groupedRows, row => row.subRows) : groupedRows;\r\n        const row = createRow(table, id, leafRows[0].original, index, depth, undefined, parentId);\r\n        Object.assign(row, {\r\n          groupingColumnId: columnId,\r\n          groupingValue,\r\n          subRows,\r\n          leafRows,\r\n          getValue: columnId => {\r\n            // Don't aggregate columns that are in the grouping\r\n            if (existingGrouping.includes(columnId)) {\r\n              if (row._valuesCache.hasOwnProperty(columnId)) {\r\n                return row._valuesCache[columnId];\r\n              }\r\n              if (groupedRows[0]) {\r\n                var _groupedRows$0$getVal;\r\n                row._valuesCache[columnId] = (_groupedRows$0$getVal = groupedRows[0].getValue(columnId)) != null ? _groupedRows$0$getVal : undefined;\r\n              }\r\n              return row._valuesCache[columnId];\r\n            }\r\n            if (row._groupingValuesCache.hasOwnProperty(columnId)) {\r\n              return row._groupingValuesCache[columnId];\r\n            }\r\n\r\n            // Aggregate the values\r\n            const column = table.getColumn(columnId);\r\n            const aggregateFn = column == null ? void 0 : column.getAggregationFn();\r\n            if (aggregateFn) {\r\n              row._groupingValuesCache[columnId] = aggregateFn(columnId, leafRows, groupedRows);\r\n              return row._groupingValuesCache[columnId];\r\n            }\r\n          }\r\n        });\r\n        subRows.forEach(subRow => {\r\n          groupedFlatRows.push(subRow);\r\n          groupedRowsById[subRow.id] = subRow;\r\n          // if (subRow.getIsGrouped?.()) {\r\n          //   onlyGroupedFlatRows.push(subRow);\r\n          //   onlyGroupedRowsById[subRow.id] = subRow;\r\n          // } else {\r\n          //   nonGroupedFlatRows.push(subRow);\r\n          //   nonGroupedRowsById[subRow.id] = subRow;\r\n          // }\r\n        });\r\n        return row;\r\n      });\r\n      return aggregatedGroupedRows;\r\n    };\r\n    const groupedRows = groupUpRecursively(rowModel.rows, 0);\r\n    groupedRows.forEach(subRow => {\r\n      groupedFlatRows.push(subRow);\r\n      groupedRowsById[subRow.id] = subRow;\r\n      // if (subRow.getIsGrouped?.()) {\r\n      //   onlyGroupedFlatRows.push(subRow);\r\n      //   onlyGroupedRowsById[subRow.id] = subRow;\r\n      // } else {\r\n      //   nonGroupedFlatRows.push(subRow);\r\n      //   nonGroupedRowsById[subRow.id] = subRow;\r\n      // }\r\n    });\r\n    return {\r\n      rows: groupedRows,\r\n      flatRows: groupedFlatRows,\r\n      rowsById: groupedRowsById\r\n    };\r\n  }, getMemoOptions(table.options, 'debugTable', 'getGroupedRowModel', () => {\r\n    table._queue(() => {\r\n      table._autoResetExpanded();\r\n      table._autoResetPageIndex();\r\n    });\r\n  }));\r\n}\r\nfunction groupBy(rows, columnId) {\r\n  const groupMap = new Map();\r\n  return rows.reduce((map, row) => {\r\n    const resKey = `${row.getGroupingValue(columnId)}`;\r\n    const previous = map.get(resKey);\r\n    if (!previous) {\r\n      map.set(resKey, [row]);\r\n    } else {\r\n      previous.push(row);\r\n    }\r\n    return map;\r\n  }, groupMap);\r\n}\r\n\r\nfunction getPaginationRowModel(opts) {\r\n  return table => memo(() => [table.getState().pagination, table.getPrePaginationRowModel(), table.options.paginateExpandedRows ? undefined : table.getState().expanded], (pagination, rowModel) => {\r\n    if (!rowModel.rows.length) {\r\n      return rowModel;\r\n    }\r\n    const {\r\n      pageSize,\r\n      pageIndex\r\n    } = pagination;\r\n    let {\r\n      rows,\r\n      flatRows,\r\n      rowsById\r\n    } = rowModel;\r\n    const pageStart = pageSize * pageIndex;\r\n    const pageEnd = pageStart + pageSize;\r\n    rows = rows.slice(pageStart, pageEnd);\r\n    let paginatedRowModel;\r\n    if (!table.options.paginateExpandedRows) {\r\n      paginatedRowModel = expandRows({\r\n        rows,\r\n        flatRows,\r\n        rowsById\r\n      });\r\n    } else {\r\n      paginatedRowModel = {\r\n        rows,\r\n        flatRows,\r\n        rowsById\r\n      };\r\n    }\r\n    paginatedRowModel.flatRows = [];\r\n    const handleRow = row => {\r\n      paginatedRowModel.flatRows.push(row);\r\n      if (row.subRows.length) {\r\n        row.subRows.forEach(handleRow);\r\n      }\r\n    };\r\n    paginatedRowModel.rows.forEach(handleRow);\r\n    return paginatedRowModel;\r\n  }, getMemoOptions(table.options, 'debugTable', 'getPaginationRowModel'));\r\n}\r\n\r\nfunction getSortedRowModel() {\r\n  return table => memo(() => [table.getState().sorting, table.getPreSortedRowModel()], (sorting, rowModel) => {\r\n    if (!rowModel.rows.length || !(sorting != null && sorting.length)) {\r\n      return rowModel;\r\n    }\r\n    const sortingState = table.getState().sorting;\r\n    const sortedFlatRows = [];\r\n\r\n    // Filter out sortings that correspond to non existing columns\r\n    const availableSorting = sortingState.filter(sort => {\r\n      var _table$getColumn;\r\n      return (_table$getColumn = table.getColumn(sort.id)) == null ? void 0 : _table$getColumn.getCanSort();\r\n    });\r\n    const columnInfoById = {};\r\n    availableSorting.forEach(sortEntry => {\r\n      const column = table.getColumn(sortEntry.id);\r\n      if (!column) return;\r\n      columnInfoById[sortEntry.id] = {\r\n        sortUndefined: column.columnDef.sortUndefined,\r\n        invertSorting: column.columnDef.invertSorting,\r\n        sortingFn: column.getSortingFn()\r\n      };\r\n    });\r\n    const sortData = rows => {\r\n      // This will also perform a stable sorting using the row index\r\n      // if needed.\r\n      const sortedData = rows.map(row => ({\r\n        ...row\r\n      }));\r\n      sortedData.sort((rowA, rowB) => {\r\n        for (let i = 0; i < availableSorting.length; i += 1) {\r\n          var _sortEntry$desc;\r\n          const sortEntry = availableSorting[i];\r\n          const columnInfo = columnInfoById[sortEntry.id];\r\n          const isDesc = (_sortEntry$desc = sortEntry == null ? void 0 : sortEntry.desc) != null ? _sortEntry$desc : false;\r\n          let sortInt = 0;\r\n\r\n          // All sorting ints should always return in ascending order\r\n          if (columnInfo.sortUndefined) {\r\n            const aValue = rowA.getValue(sortEntry.id);\r\n            const bValue = rowB.getValue(sortEntry.id);\r\n            const aUndefined = aValue === undefined;\r\n            const bUndefined = bValue === undefined;\r\n            if (aUndefined || bUndefined) {\r\n              sortInt = aUndefined && bUndefined ? 0 : aUndefined ? columnInfo.sortUndefined : -columnInfo.sortUndefined;\r\n            }\r\n          }\r\n          if (sortInt === 0) {\r\n            sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);\r\n          }\r\n\r\n          // If sorting is non-zero, take care of desc and inversion\r\n          if (sortInt !== 0) {\r\n            if (isDesc) {\r\n              sortInt *= -1;\r\n            }\r\n            if (columnInfo.invertSorting) {\r\n              sortInt *= -1;\r\n            }\r\n            return sortInt;\r\n          }\r\n        }\r\n        return rowA.index - rowB.index;\r\n      });\r\n\r\n      // If there are sub-rows, sort them\r\n      sortedData.forEach(row => {\r\n        var _row$subRows;\r\n        sortedFlatRows.push(row);\r\n        if ((_row$subRows = row.subRows) != null && _row$subRows.length) {\r\n          row.subRows = sortData(row.subRows);\r\n        }\r\n      });\r\n      return sortedData;\r\n    };\r\n    return {\r\n      rows: sortData(rowModel.rows),\r\n      flatRows: sortedFlatRows,\r\n      rowsById: rowModel.rowsById\r\n    };\r\n  }, getMemoOptions(table.options, 'debugTable', 'getSortedRowModel', () => table._autoResetPageIndex()));\r\n}\r\n\r\n\r\n//# sourceMappingURL=index.mjs.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3RhYmxlLWNvcmUvYnVpbGQvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QixHQUFHLG9CQUFvQjtBQUMxRTtBQUNBO0FBQ0EseUJBQXlCLDREQUE0RCxjQUFjO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFNBQVMsS0FBc0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU8sR0FBRyxVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFxQztBQUNuRCw2QkFBNkIsSUFBSSwwQkFBMEIsWUFBWTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw2REFBNkQ7QUFDekc7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSTtBQUNYLEtBQUs7QUFDTDtBQUNBLGtCQUFrQiw0QkFBNEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdHQUFnRztBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsb0dBQW9HO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxLQUFLO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMkpBQTJKO0FBQ3JNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGdHQUFnRztBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1DQUFtQztBQUN6RCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9JQUFvSTtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUtBQWlLLDhDQUE4QztBQUMvTSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBcUM7QUFDbkQsa0VBQWtFLEdBQUc7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSTtBQUNYLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFVBQVUsS0FBcUM7QUFDL0MsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsR0FBRztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQ0FBcUM7QUFDekQ7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFvQixxQ0FBcUM7QUFDekQ7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHdFQUF3RSxTQUFTO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOEJBQThCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQsMkZBQTJGLFVBQVU7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQ0FBa0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQ0FBa0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTLEdBQUcsY0FBYztBQUM5QywyQkFBMkIsU0FBUyxHQUFHLEdBQUc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0JBQStCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDbzBCO0FBQ3AwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3Rlc3RfY291cnNlLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay90YWJsZS1jb3JlL2J1aWxkL2xpYi9pbmRleC5tanM/ZWRjYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICAgKiB0YWJsZS1jb3JlXHJcbiAgICpcclxuICAgKiBDb3B5cmlnaHQgKGMpIFRhblN0YWNrXHJcbiAgICpcclxuICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICAgKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAgICpcclxuICAgKiBAbGljZW5zZSBNSVRcclxuICAgKi9cclxuLy8gdHlwZSBQZXJzb24gPSB7XHJcbi8vICAgZmlyc3ROYW1lOiBzdHJpbmdcclxuLy8gICBsYXN0TmFtZTogc3RyaW5nXHJcbi8vICAgYWdlOiBudW1iZXJcclxuLy8gICB2aXNpdHM6IG51bWJlclxyXG4vLyAgIHN0YXR1czogc3RyaW5nXHJcbi8vICAgcHJvZ3Jlc3M6IG51bWJlclxyXG4vLyAgIGNyZWF0ZWRBdDogRGF0ZVxyXG4vLyAgIG5lc3RlZDoge1xyXG4vLyAgICAgZm9vOiBbXHJcbi8vICAgICAgIHtcclxuLy8gICAgICAgICBiYXI6ICdiYXInXHJcbi8vICAgICAgIH1cclxuLy8gICAgIF1cclxuLy8gICAgIGJhcjogeyBzdWJCYXI6IGJvb2xlYW4gfVtdXHJcbi8vICAgICBiYXo6IHtcclxuLy8gICAgICAgZm9vOiAnZm9vJ1xyXG4vLyAgICAgICBiYXI6IHtcclxuLy8gICAgICAgICBiYXo6ICdiYXonXHJcbi8vICAgICAgIH1cclxuLy8gICAgIH1cclxuLy8gICB9XHJcbi8vIH1cclxuXHJcbi8vIGNvbnN0IHRlc3Q6IERlZXBLZXlzPFBlcnNvbj4gPSAnbmVzdGVkLmZvby4wLmJhcidcclxuLy8gY29uc3QgdGVzdDI6IERlZXBLZXlzPFBlcnNvbj4gPSAnbmVzdGVkLmJhcidcclxuXHJcbi8vIGNvbnN0IGhlbHBlciA9IGNyZWF0ZUNvbHVtbkhlbHBlcjxQZXJzb24+KClcclxuXHJcbi8vIGhlbHBlci5hY2Nlc3NvcignbmVzdGVkLmZvbycsIHtcclxuLy8gICBjZWxsOiBpbmZvID0+IGluZm8uZ2V0VmFsdWUoKSxcclxuLy8gfSlcclxuXHJcbi8vIGhlbHBlci5hY2Nlc3NvcignbmVzdGVkLmZvby4wLmJhcicsIHtcclxuLy8gICBjZWxsOiBpbmZvID0+IGluZm8uZ2V0VmFsdWUoKSxcclxuLy8gfSlcclxuXHJcbi8vIGhlbHBlci5hY2Nlc3NvcignbmVzdGVkLmJhcicsIHtcclxuLy8gICBjZWxsOiBpbmZvID0+IGluZm8uZ2V0VmFsdWUoKSxcclxuLy8gfSlcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbHVtbkhlbHBlcigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgYWNjZXNzb3I6IChhY2Nlc3NvciwgY29sdW1uKSA9PiB7XHJcbiAgICAgIHJldHVybiB0eXBlb2YgYWNjZXNzb3IgPT09ICdmdW5jdGlvbicgPyB7XHJcbiAgICAgICAgLi4uY29sdW1uLFxyXG4gICAgICAgIGFjY2Vzc29yRm46IGFjY2Vzc29yXHJcbiAgICAgIH0gOiB7XHJcbiAgICAgICAgLi4uY29sdW1uLFxyXG4gICAgICAgIGFjY2Vzc29yS2V5OiBhY2Nlc3NvclxyXG4gICAgICB9O1xyXG4gICAgfSxcclxuICAgIGRpc3BsYXk6IGNvbHVtbiA9PiBjb2x1bW4sXHJcbiAgICBncm91cDogY29sdW1uID0+IGNvbHVtblxyXG4gIH07XHJcbn1cclxuXHJcbi8vIElzIHRoaXMgdHlwZSBhIHR1cGxlP1xyXG5cclxuLy8gSWYgdGhpcyB0eXBlIGlzIGEgdHVwbGUsIHdoYXQgaW5kaWNlcyBhcmUgYWxsb3dlZD9cclxuXHJcbi8vL1xyXG5cclxuZnVuY3Rpb24gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBpbnB1dCkge1xyXG4gIHJldHVybiB0eXBlb2YgdXBkYXRlciA9PT0gJ2Z1bmN0aW9uJyA/IHVwZGF0ZXIoaW5wdXQpIDogdXBkYXRlcjtcclxufVxyXG5mdW5jdGlvbiBub29wKCkge1xyXG4gIC8vXHJcbn1cclxuZnVuY3Rpb24gbWFrZVN0YXRlVXBkYXRlcihrZXksIGluc3RhbmNlKSB7XHJcbiAgcmV0dXJuIHVwZGF0ZXIgPT4ge1xyXG4gICAgaW5zdGFuY2Uuc2V0U3RhdGUob2xkID0+IHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5vbGQsXHJcbiAgICAgICAgW2tleV06IGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgb2xkW2tleV0pXHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZCkge1xyXG4gIHJldHVybiBkIGluc3RhbmNlb2YgRnVuY3Rpb247XHJcbn1cclxuZnVuY3Rpb24gaXNOdW1iZXJBcnJheShkKSB7XHJcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZCkgJiYgZC5ldmVyeSh2YWwgPT4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicpO1xyXG59XHJcbmZ1bmN0aW9uIGZsYXR0ZW5CeShhcnIsIGdldENoaWxkcmVuKSB7XHJcbiAgY29uc3QgZmxhdCA9IFtdO1xyXG4gIGNvbnN0IHJlY3Vyc2UgPSBzdWJBcnIgPT4ge1xyXG4gICAgc3ViQXJyLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgIGZsYXQucHVzaChpdGVtKTtcclxuICAgICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbihpdGVtKTtcclxuICAgICAgaWYgKGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgcmVjdXJzZShjaGlsZHJlbik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XHJcbiAgcmVjdXJzZShhcnIpO1xyXG4gIHJldHVybiBmbGF0O1xyXG59XHJcbmZ1bmN0aW9uIG1lbW8oZ2V0RGVwcywgZm4sIG9wdHMpIHtcclxuICBsZXQgZGVwcyA9IFtdO1xyXG4gIGxldCByZXN1bHQ7XHJcbiAgcmV0dXJuIGRlcEFyZ3MgPT4ge1xyXG4gICAgbGV0IGRlcFRpbWU7XHJcbiAgICBpZiAob3B0cy5rZXkgJiYgb3B0cy5kZWJ1ZykgZGVwVGltZSA9IERhdGUubm93KCk7XHJcbiAgICBjb25zdCBuZXdEZXBzID0gZ2V0RGVwcyhkZXBBcmdzKTtcclxuICAgIGNvbnN0IGRlcHNDaGFuZ2VkID0gbmV3RGVwcy5sZW5ndGggIT09IGRlcHMubGVuZ3RoIHx8IG5ld0RlcHMuc29tZSgoZGVwLCBpbmRleCkgPT4gZGVwc1tpbmRleF0gIT09IGRlcCk7XHJcbiAgICBpZiAoIWRlcHNDaGFuZ2VkKSB7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBkZXBzID0gbmV3RGVwcztcclxuICAgIGxldCByZXN1bHRUaW1lO1xyXG4gICAgaWYgKG9wdHMua2V5ICYmIG9wdHMuZGVidWcpIHJlc3VsdFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgcmVzdWx0ID0gZm4oLi4ubmV3RGVwcyk7XHJcbiAgICBvcHRzID09IG51bGwgfHwgb3B0cy5vbkNoYW5nZSA9PSBudWxsIHx8IG9wdHMub25DaGFuZ2UocmVzdWx0KTtcclxuICAgIGlmIChvcHRzLmtleSAmJiBvcHRzLmRlYnVnKSB7XHJcbiAgICAgIGlmIChvcHRzICE9IG51bGwgJiYgb3B0cy5kZWJ1ZygpKSB7XHJcbiAgICAgICAgY29uc3QgZGVwRW5kVGltZSA9IE1hdGgucm91bmQoKERhdGUubm93KCkgLSBkZXBUaW1lKSAqIDEwMCkgLyAxMDA7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0RW5kVGltZSA9IE1hdGgucm91bmQoKERhdGUubm93KCkgLSByZXN1bHRUaW1lKSAqIDEwMCkgLyAxMDA7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0RnBzUGVyY2VudGFnZSA9IHJlc3VsdEVuZFRpbWUgLyAxNjtcclxuICAgICAgICBjb25zdCBwYWQgPSAoc3RyLCBudW0pID0+IHtcclxuICAgICAgICAgIHN0ciA9IFN0cmluZyhzdHIpO1xyXG4gICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBudW0pIHtcclxuICAgICAgICAgICAgc3RyID0gJyAnICsgc3RyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgJWPij7EgJHtwYWQocmVzdWx0RW5kVGltZSwgNSl9IC8ke3BhZChkZXBFbmRUaW1lLCA1KX0gbXNgLCBgXHJcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogLjZyZW07XHJcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xyXG4gICAgICAgICAgICBjb2xvcjogaHNsKCR7TWF0aC5tYXgoMCwgTWF0aC5taW4oMTIwIC0gMTIwICogcmVzdWx0RnBzUGVyY2VudGFnZSwgMTIwKSl9ZGVnIDEwMCUgMzElKTtgLCBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmtleSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRNZW1vT3B0aW9ucyh0YWJsZU9wdGlvbnMsIGRlYnVnTGV2ZWwsIGtleSwgb25DaGFuZ2UpIHtcclxuICByZXR1cm4ge1xyXG4gICAgZGVidWc6ICgpID0+IHtcclxuICAgICAgdmFyIF90YWJsZU9wdGlvbnMkZGVidWdBbDtcclxuICAgICAgcmV0dXJuIChfdGFibGVPcHRpb25zJGRlYnVnQWwgPSB0YWJsZU9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlT3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZU9wdGlvbnMkZGVidWdBbCA6IHRhYmxlT3B0aW9uc1tkZWJ1Z0xldmVsXTtcclxuICAgIH0sXHJcbiAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIGtleSxcclxuICAgIG9uQ2hhbmdlXHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlQ2VsbCh0YWJsZSwgcm93LCBjb2x1bW4sIGNvbHVtbklkKSB7XHJcbiAgY29uc3QgZ2V0UmVuZGVyVmFsdWUgPSAoKSA9PiB7XHJcbiAgICB2YXIgX2NlbGwkZ2V0VmFsdWU7XHJcbiAgICByZXR1cm4gKF9jZWxsJGdldFZhbHVlID0gY2VsbC5nZXRWYWx1ZSgpKSAhPSBudWxsID8gX2NlbGwkZ2V0VmFsdWUgOiB0YWJsZS5vcHRpb25zLnJlbmRlckZhbGxiYWNrVmFsdWU7XHJcbiAgfTtcclxuICBjb25zdCBjZWxsID0ge1xyXG4gICAgaWQ6IGAke3Jvdy5pZH1fJHtjb2x1bW4uaWR9YCxcclxuICAgIHJvdyxcclxuICAgIGNvbHVtbixcclxuICAgIGdldFZhbHVlOiAoKSA9PiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpLFxyXG4gICAgcmVuZGVyVmFsdWU6IGdldFJlbmRlclZhbHVlLFxyXG4gICAgZ2V0Q29udGV4dDogbWVtbygoKSA9PiBbdGFibGUsIGNvbHVtbiwgcm93LCBjZWxsXSwgKHRhYmxlLCBjb2x1bW4sIHJvdywgY2VsbCkgPT4gKHtcclxuICAgICAgdGFibGUsXHJcbiAgICAgIGNvbHVtbixcclxuICAgICAgcm93LFxyXG4gICAgICBjZWxsOiBjZWxsLFxyXG4gICAgICBnZXRWYWx1ZTogY2VsbC5nZXRWYWx1ZSxcclxuICAgICAgcmVuZGVyVmFsdWU6IGNlbGwucmVuZGVyVmFsdWVcclxuICAgIH0pLCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDZWxscycsICdjZWxsLmdldENvbnRleHQnKSlcclxuICB9O1xyXG4gIHRhYmxlLl9mZWF0dXJlcy5mb3JFYWNoKGZlYXR1cmUgPT4ge1xyXG4gICAgZmVhdHVyZS5jcmVhdGVDZWxsID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVDZWxsKGNlbGwsIGNvbHVtbiwgcm93LCB0YWJsZSk7XHJcbiAgfSwge30pO1xyXG4gIHJldHVybiBjZWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVDb2x1bW4odGFibGUsIGNvbHVtbkRlZiwgZGVwdGgsIHBhcmVudCkge1xyXG4gIHZhciBfcmVmLCBfcmVzb2x2ZWRDb2x1bW5EZWYkaWQ7XHJcbiAgY29uc3QgZGVmYXVsdENvbHVtbiA9IHRhYmxlLl9nZXREZWZhdWx0Q29sdW1uRGVmKCk7XHJcbiAgY29uc3QgcmVzb2x2ZWRDb2x1bW5EZWYgPSB7XHJcbiAgICAuLi5kZWZhdWx0Q29sdW1uLFxyXG4gICAgLi4uY29sdW1uRGVmXHJcbiAgfTtcclxuICBjb25zdCBhY2Nlc3NvcktleSA9IHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yS2V5O1xyXG4gIGxldCBpZCA9IChfcmVmID0gKF9yZXNvbHZlZENvbHVtbkRlZiRpZCA9IHJlc29sdmVkQ29sdW1uRGVmLmlkKSAhPSBudWxsID8gX3Jlc29sdmVkQ29sdW1uRGVmJGlkIDogYWNjZXNzb3JLZXkgPyBhY2Nlc3NvcktleS5yZXBsYWNlKCcuJywgJ18nKSA6IHVuZGVmaW5lZCkgIT0gbnVsbCA/IF9yZWYgOiB0eXBlb2YgcmVzb2x2ZWRDb2x1bW5EZWYuaGVhZGVyID09PSAnc3RyaW5nJyA/IHJlc29sdmVkQ29sdW1uRGVmLmhlYWRlciA6IHVuZGVmaW5lZDtcclxuICBsZXQgYWNjZXNzb3JGbjtcclxuICBpZiAocmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JGbikge1xyXG4gICAgYWNjZXNzb3JGbiA9IHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yRm47XHJcbiAgfSBlbHNlIGlmIChhY2Nlc3NvcktleSkge1xyXG4gICAgLy8gU3VwcG9ydCBkZWVwIGFjY2Vzc29yIGtleXNcclxuICAgIGlmIChhY2Nlc3NvcktleS5pbmNsdWRlcygnLicpKSB7XHJcbiAgICAgIGFjY2Vzc29yRm4gPSBvcmlnaW5hbFJvdyA9PiB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IG9yaWdpbmFsUm93O1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGFjY2Vzc29yS2V5LnNwbGl0KCcuJykpIHtcclxuICAgICAgICAgIHZhciBfcmVzdWx0O1xyXG4gICAgICAgICAgcmVzdWx0ID0gKF9yZXN1bHQgPSByZXN1bHQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVzdWx0W2tleV07XHJcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiByZXN1bHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFwiJHtrZXl9XCIgaW4gZGVlcGx5IG5lc3RlZCBrZXkgXCIke2FjY2Vzc29yS2V5fVwiIHJldHVybmVkIHVuZGVmaW5lZC5gKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGFjY2Vzc29yRm4gPSBvcmlnaW5hbFJvdyA9PiBvcmlnaW5hbFJvd1tyZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvcktleV07XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICghaWQpIHtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvckZuID8gYENvbHVtbnMgcmVxdWlyZSBhbiBpZCB3aGVuIHVzaW5nIGFuIGFjY2Vzc29yRm5gIDogYENvbHVtbnMgcmVxdWlyZSBhbiBpZCB3aGVuIHVzaW5nIGEgbm9uLXN0cmluZyBoZWFkZXJgKTtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcigpO1xyXG4gIH1cclxuICBsZXQgY29sdW1uID0ge1xyXG4gICAgaWQ6IGAke1N0cmluZyhpZCl9YCxcclxuICAgIGFjY2Vzc29yRm4sXHJcbiAgICBwYXJlbnQ6IHBhcmVudCxcclxuICAgIGRlcHRoLFxyXG4gICAgY29sdW1uRGVmOiByZXNvbHZlZENvbHVtbkRlZixcclxuICAgIGNvbHVtbnM6IFtdLFxyXG4gICAgZ2V0RmxhdENvbHVtbnM6IG1lbW8oKCkgPT4gW3RydWVdLCAoKSA9PiB7XHJcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbnM7XHJcbiAgICAgIHJldHVybiBbY29sdW1uLCAuLi4oKF9jb2x1bW4kY29sdW1ucyA9IGNvbHVtbi5jb2x1bW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2NvbHVtbiRjb2x1bW5zLmZsYXRNYXAoZCA9PiBkLmdldEZsYXRDb2x1bW5zKCkpKV07XHJcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2NvbHVtbi5nZXRGbGF0Q29sdW1ucycpKSxcclxuICAgIGdldExlYWZDb2x1bW5zOiBtZW1vKCgpID0+IFt0YWJsZS5fZ2V0T3JkZXJDb2x1bW5zRm4oKV0sIG9yZGVyQ29sdW1ucyA9PiB7XHJcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbnMyO1xyXG4gICAgICBpZiAoKF9jb2x1bW4kY29sdW1uczIgPSBjb2x1bW4uY29sdW1ucykgIT0gbnVsbCAmJiBfY29sdW1uJGNvbHVtbnMyLmxlbmd0aCkge1xyXG4gICAgICAgIGxldCBsZWFmQ29sdW1ucyA9IGNvbHVtbi5jb2x1bW5zLmZsYXRNYXAoY29sdW1uID0+IGNvbHVtbi5nZXRMZWFmQ29sdW1ucygpKTtcclxuICAgICAgICByZXR1cm4gb3JkZXJDb2x1bW5zKGxlYWZDb2x1bW5zKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gW2NvbHVtbl07XHJcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2NvbHVtbi5nZXRMZWFmQ29sdW1ucycpKVxyXG4gIH07XHJcbiAgZm9yIChjb25zdCBmZWF0dXJlIG9mIHRhYmxlLl9mZWF0dXJlcykge1xyXG4gICAgZmVhdHVyZS5jcmVhdGVDb2x1bW4gPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZUNvbHVtbihjb2x1bW4sIHRhYmxlKTtcclxuICB9XHJcblxyXG4gIC8vIFllcywgd2UgaGF2ZSB0byBjb252ZXJ0IHRhYmxlIHRvIHVua25vd24sIGJlY2F1c2Ugd2Uga25vdyBtb3JlIHRoYW4gdGhlIGNvbXBpbGVyIGhlcmUuXHJcbiAgcmV0dXJuIGNvbHVtbjtcclxufVxyXG5cclxuY29uc3QgZGVidWcgPSAnZGVidWdIZWFkZXJzJztcclxuLy9cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUhlYWRlcih0YWJsZSwgY29sdW1uLCBvcHRpb25zKSB7XHJcbiAgdmFyIF9vcHRpb25zJGlkO1xyXG4gIGNvbnN0IGlkID0gKF9vcHRpb25zJGlkID0gb3B0aW9ucy5pZCkgIT0gbnVsbCA/IF9vcHRpb25zJGlkIDogY29sdW1uLmlkO1xyXG4gIGxldCBoZWFkZXIgPSB7XHJcbiAgICBpZCxcclxuICAgIGNvbHVtbixcclxuICAgIGluZGV4OiBvcHRpb25zLmluZGV4LFxyXG4gICAgaXNQbGFjZWhvbGRlcjogISFvcHRpb25zLmlzUGxhY2Vob2xkZXIsXHJcbiAgICBwbGFjZWhvbGRlcklkOiBvcHRpb25zLnBsYWNlaG9sZGVySWQsXHJcbiAgICBkZXB0aDogb3B0aW9ucy5kZXB0aCxcclxuICAgIHN1YkhlYWRlcnM6IFtdLFxyXG4gICAgY29sU3BhbjogMCxcclxuICAgIHJvd1NwYW46IDAsXHJcbiAgICBoZWFkZXJHcm91cDogbnVsbCxcclxuICAgIGdldExlYWZIZWFkZXJzOiAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGxlYWZIZWFkZXJzID0gW107XHJcbiAgICAgIGNvbnN0IHJlY3Vyc2VIZWFkZXIgPSBoID0+IHtcclxuICAgICAgICBpZiAoaC5zdWJIZWFkZXJzICYmIGguc3ViSGVhZGVycy5sZW5ndGgpIHtcclxuICAgICAgICAgIGguc3ViSGVhZGVycy5tYXAocmVjdXJzZUhlYWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxlYWZIZWFkZXJzLnB1c2goaCk7XHJcbiAgICAgIH07XHJcbiAgICAgIHJlY3Vyc2VIZWFkZXIoaGVhZGVyKTtcclxuICAgICAgcmV0dXJuIGxlYWZIZWFkZXJzO1xyXG4gICAgfSxcclxuICAgIGdldENvbnRleHQ6ICgpID0+ICh7XHJcbiAgICAgIHRhYmxlLFxyXG4gICAgICBoZWFkZXI6IGhlYWRlcixcclxuICAgICAgY29sdW1uXHJcbiAgICB9KVxyXG4gIH07XHJcbiAgdGFibGUuX2ZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XHJcbiAgICBmZWF0dXJlLmNyZWF0ZUhlYWRlciA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlSGVhZGVyKGhlYWRlciwgdGFibGUpO1xyXG4gIH0pO1xyXG4gIHJldHVybiBoZWFkZXI7XHJcbn1cclxuY29uc3QgSGVhZGVycyA9IHtcclxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xyXG4gICAgLy8gSGVhZGVyIEdyb3Vwc1xyXG5cclxuICAgIHRhYmxlLmdldEhlYWRlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKSwgdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0LCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIGxlZnQsIHJpZ2h0KSA9PiB7XHJcbiAgICAgIHZhciBfbGVmdCRtYXAkZmlsdGVyLCBfcmlnaHQkbWFwJGZpbHRlcjtcclxuICAgICAgY29uc3QgbGVmdENvbHVtbnMgPSAoX2xlZnQkbWFwJGZpbHRlciA9IGxlZnQgPT0gbnVsbCA/IHZvaWQgMCA6IGxlZnQubWFwKGNvbHVtbklkID0+IGxlYWZDb2x1bW5zLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKSkgIT0gbnVsbCA/IF9sZWZ0JG1hcCRmaWx0ZXIgOiBbXTtcclxuICAgICAgY29uc3QgcmlnaHRDb2x1bW5zID0gKF9yaWdodCRtYXAkZmlsdGVyID0gcmlnaHQgPT0gbnVsbCA/IHZvaWQgMCA6IHJpZ2h0Lm1hcChjb2x1bW5JZCA9PiBsZWFmQ29sdW1ucy5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbikpICE9IG51bGwgPyBfcmlnaHQkbWFwJGZpbHRlciA6IFtdO1xyXG4gICAgICBjb25zdCBjZW50ZXJDb2x1bW5zID0gbGVhZkNvbHVtbnMuZmlsdGVyKGNvbHVtbiA9PiAhKGxlZnQgIT0gbnVsbCAmJiBsZWZ0LmluY2x1ZGVzKGNvbHVtbi5pZCkpICYmICEocmlnaHQgIT0gbnVsbCAmJiByaWdodC5pbmNsdWRlcyhjb2x1bW4uaWQpKSk7XHJcbiAgICAgIGNvbnN0IGhlYWRlckdyb3VwcyA9IGJ1aWxkSGVhZGVyR3JvdXBzKGFsbENvbHVtbnMsIFsuLi5sZWZ0Q29sdW1ucywgLi4uY2VudGVyQ29sdW1ucywgLi4ucmlnaHRDb2x1bW5zXSwgdGFibGUpO1xyXG4gICAgICByZXR1cm4gaGVhZGVyR3JvdXBzO1xyXG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRIZWFkZXJHcm91cHMnKSk7XHJcbiAgICB0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCksIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdCwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKGFsbENvbHVtbnMsIGxlYWZDb2x1bW5zLCBsZWZ0LCByaWdodCkgPT4ge1xyXG4gICAgICBsZWFmQ29sdW1ucyA9IGxlYWZDb2x1bW5zLmZpbHRlcihjb2x1bW4gPT4gIShsZWZ0ICE9IG51bGwgJiYgbGVmdC5pbmNsdWRlcyhjb2x1bW4uaWQpKSAmJiAhKHJpZ2h0ICE9IG51bGwgJiYgcmlnaHQuaW5jbHVkZXMoY29sdW1uLmlkKSkpO1xyXG4gICAgICByZXR1cm4gYnVpbGRIZWFkZXJHcm91cHMoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIHRhYmxlLCAnY2VudGVyJyk7XHJcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldENlbnRlckhlYWRlckdyb3VwcycpKTtcclxuICAgIHRhYmxlLmdldExlZnRIZWFkZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCksIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdF0sIChhbGxDb2x1bW5zLCBsZWFmQ29sdW1ucywgbGVmdCkgPT4ge1xyXG4gICAgICB2YXIgX2xlZnQkbWFwJGZpbHRlcjI7XHJcbiAgICAgIGNvbnN0IG9yZGVyZWRMZWFmQ29sdW1ucyA9IChfbGVmdCRtYXAkZmlsdGVyMiA9IGxlZnQgPT0gbnVsbCA/IHZvaWQgMCA6IGxlZnQubWFwKGNvbHVtbklkID0+IGxlYWZDb2x1bW5zLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKSkgIT0gbnVsbCA/IF9sZWZ0JG1hcCRmaWx0ZXIyIDogW107XHJcbiAgICAgIHJldHVybiBidWlsZEhlYWRlckdyb3VwcyhhbGxDb2x1bW5zLCBvcmRlcmVkTGVhZkNvbHVtbnMsIHRhYmxlLCAnbGVmdCcpO1xyXG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRMZWZ0SGVhZGVyR3JvdXBzJykpO1xyXG4gICAgdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCksIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIHJpZ2h0KSA9PiB7XHJcbiAgICAgIHZhciBfcmlnaHQkbWFwJGZpbHRlcjI7XHJcbiAgICAgIGNvbnN0IG9yZGVyZWRMZWFmQ29sdW1ucyA9IChfcmlnaHQkbWFwJGZpbHRlcjIgPSByaWdodCA9PSBudWxsID8gdm9pZCAwIDogcmlnaHQubWFwKGNvbHVtbklkID0+IGxlYWZDb2x1bW5zLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKSkgIT0gbnVsbCA/IF9yaWdodCRtYXAkZmlsdGVyMiA6IFtdO1xyXG4gICAgICByZXR1cm4gYnVpbGRIZWFkZXJHcm91cHMoYWxsQ29sdW1ucywgb3JkZXJlZExlYWZDb2x1bW5zLCB0YWJsZSwgJ3JpZ2h0Jyk7XHJcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldFJpZ2h0SGVhZGVyR3JvdXBzJykpO1xyXG5cclxuICAgIC8vIEZvb3RlciBHcm91cHNcclxuXHJcbiAgICB0YWJsZS5nZXRGb290ZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRIZWFkZXJHcm91cHMoKV0sIGhlYWRlckdyb3VwcyA9PiB7XHJcbiAgICAgIHJldHVybiBbLi4uaGVhZGVyR3JvdXBzXS5yZXZlcnNlKCk7XHJcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldEZvb3Rlckdyb3VwcycpKTtcclxuICAgIHRhYmxlLmdldExlZnRGb290ZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRMZWZ0SGVhZGVyR3JvdXBzKCldLCBoZWFkZXJHcm91cHMgPT4ge1xyXG4gICAgICByZXR1cm4gWy4uLmhlYWRlckdyb3Vwc10ucmV2ZXJzZSgpO1xyXG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRMZWZ0Rm9vdGVyR3JvdXBzJykpO1xyXG4gICAgdGFibGUuZ2V0Q2VudGVyRm9vdGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0Q2VudGVySGVhZGVyR3JvdXBzKCldLCBoZWFkZXJHcm91cHMgPT4ge1xyXG4gICAgICByZXR1cm4gWy4uLmhlYWRlckdyb3Vwc10ucmV2ZXJzZSgpO1xyXG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRDZW50ZXJGb290ZXJHcm91cHMnKSk7XHJcbiAgICB0YWJsZS5nZXRSaWdodEZvb3Rlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFJpZ2h0SGVhZGVyR3JvdXBzKCldLCBoZWFkZXJHcm91cHMgPT4ge1xyXG4gICAgICByZXR1cm4gWy4uLmhlYWRlckdyb3Vwc10ucmV2ZXJzZSgpO1xyXG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRSaWdodEZvb3Rlckdyb3VwcycpKTtcclxuXHJcbiAgICAvLyBGbGF0IEhlYWRlcnNcclxuXHJcbiAgICB0YWJsZS5nZXRGbGF0SGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEhlYWRlckdyb3VwcygpXSwgaGVhZGVyR3JvdXBzID0+IHtcclxuICAgICAgcmV0dXJuIGhlYWRlckdyb3Vwcy5tYXAoaGVhZGVyR3JvdXAgPT4ge1xyXG4gICAgICAgIHJldHVybiBoZWFkZXJHcm91cC5oZWFkZXJzO1xyXG4gICAgICB9KS5mbGF0KCk7XHJcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldEZsYXRIZWFkZXJzJykpO1xyXG4gICAgdGFibGUuZ2V0TGVmdEZsYXRIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0TGVmdEhlYWRlckdyb3VwcygpXSwgbGVmdCA9PiB7XHJcbiAgICAgIHJldHVybiBsZWZ0Lm1hcChoZWFkZXJHcm91cCA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGhlYWRlckdyb3VwLmhlYWRlcnM7XHJcbiAgICAgIH0pLmZsYXQoKTtcclxuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0TGVmdEZsYXRIZWFkZXJzJykpO1xyXG4gICAgdGFibGUuZ2V0Q2VudGVyRmxhdEhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMoKV0sIGxlZnQgPT4ge1xyXG4gICAgICByZXR1cm4gbGVmdC5tYXAoaGVhZGVyR3JvdXAgPT4ge1xyXG4gICAgICAgIHJldHVybiBoZWFkZXJHcm91cC5oZWFkZXJzO1xyXG4gICAgICB9KS5mbGF0KCk7XHJcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldENlbnRlckZsYXRIZWFkZXJzJykpO1xyXG4gICAgdGFibGUuZ2V0UmlnaHRGbGF0SGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFJpZ2h0SGVhZGVyR3JvdXBzKCldLCBsZWZ0ID0+IHtcclxuICAgICAgcmV0dXJuIGxlZnQubWFwKGhlYWRlckdyb3VwID0+IHtcclxuICAgICAgICByZXR1cm4gaGVhZGVyR3JvdXAuaGVhZGVycztcclxuICAgICAgfSkuZmxhdCgpO1xyXG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRSaWdodEZsYXRIZWFkZXJzJykpO1xyXG5cclxuICAgIC8vIExlYWYgSGVhZGVyc1xyXG5cclxuICAgIHRhYmxlLmdldENlbnRlckxlYWZIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0Q2VudGVyRmxhdEhlYWRlcnMoKV0sIGZsYXRIZWFkZXJzID0+IHtcclxuICAgICAgcmV0dXJuIGZsYXRIZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge1xyXG4gICAgICAgIHZhciBfaGVhZGVyJHN1YkhlYWRlcnM7XHJcbiAgICAgICAgcmV0dXJuICEoKF9oZWFkZXIkc3ViSGVhZGVycyA9IGhlYWRlci5zdWJIZWFkZXJzKSAhPSBudWxsICYmIF9oZWFkZXIkc3ViSGVhZGVycy5sZW5ndGgpO1xyXG4gICAgICB9KTtcclxuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0Q2VudGVyTGVhZkhlYWRlcnMnKSk7XHJcbiAgICB0YWJsZS5nZXRMZWZ0TGVhZkhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRMZWZ0RmxhdEhlYWRlcnMoKV0sIGZsYXRIZWFkZXJzID0+IHtcclxuICAgICAgcmV0dXJuIGZsYXRIZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge1xyXG4gICAgICAgIHZhciBfaGVhZGVyJHN1YkhlYWRlcnMyO1xyXG4gICAgICAgIHJldHVybiAhKChfaGVhZGVyJHN1YkhlYWRlcnMyID0gaGVhZGVyLnN1YkhlYWRlcnMpICE9IG51bGwgJiYgX2hlYWRlciRzdWJIZWFkZXJzMi5sZW5ndGgpO1xyXG4gICAgICB9KTtcclxuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0TGVmdExlYWZIZWFkZXJzJykpO1xyXG4gICAgdGFibGUuZ2V0UmlnaHRMZWFmSGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFJpZ2h0RmxhdEhlYWRlcnMoKV0sIGZsYXRIZWFkZXJzID0+IHtcclxuICAgICAgcmV0dXJuIGZsYXRIZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge1xyXG4gICAgICAgIHZhciBfaGVhZGVyJHN1YkhlYWRlcnMzO1xyXG4gICAgICAgIHJldHVybiAhKChfaGVhZGVyJHN1YkhlYWRlcnMzID0gaGVhZGVyLnN1YkhlYWRlcnMpICE9IG51bGwgJiYgX2hlYWRlciRzdWJIZWFkZXJzMy5sZW5ndGgpO1xyXG4gICAgICB9KTtcclxuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0UmlnaHRMZWFmSGVhZGVycycpKTtcclxuICAgIHRhYmxlLmdldExlYWZIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0TGVmdEhlYWRlckdyb3VwcygpLCB0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMoKSwgdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMoKV0sIChsZWZ0LCBjZW50ZXIsIHJpZ2h0KSA9PiB7XHJcbiAgICAgIHZhciBfbGVmdCQwJGhlYWRlcnMsIF9sZWZ0JCwgX2NlbnRlciQwJGhlYWRlcnMsIF9jZW50ZXIkLCBfcmlnaHQkMCRoZWFkZXJzLCBfcmlnaHQkO1xyXG4gICAgICByZXR1cm4gWy4uLigoX2xlZnQkMCRoZWFkZXJzID0gKF9sZWZ0JCA9IGxlZnRbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfbGVmdCQuaGVhZGVycykgIT0gbnVsbCA/IF9sZWZ0JDAkaGVhZGVycyA6IFtdKSwgLi4uKChfY2VudGVyJDAkaGVhZGVycyA9IChfY2VudGVyJCA9IGNlbnRlclswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jZW50ZXIkLmhlYWRlcnMpICE9IG51bGwgPyBfY2VudGVyJDAkaGVhZGVycyA6IFtdKSwgLi4uKChfcmlnaHQkMCRoZWFkZXJzID0gKF9yaWdodCQgPSByaWdodFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yaWdodCQuaGVhZGVycykgIT0gbnVsbCA/IF9yaWdodCQwJGhlYWRlcnMgOiBbXSldLm1hcChoZWFkZXIgPT4ge1xyXG4gICAgICAgIHJldHVybiBoZWFkZXIuZ2V0TGVhZkhlYWRlcnMoKTtcclxuICAgICAgfSkuZmxhdCgpO1xyXG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRMZWFmSGVhZGVycycpKTtcclxuICB9XHJcbn07XHJcbmZ1bmN0aW9uIGJ1aWxkSGVhZGVyR3JvdXBzKGFsbENvbHVtbnMsIGNvbHVtbnNUb0dyb3VwLCB0YWJsZSwgaGVhZGVyRmFtaWx5KSB7XHJcbiAgdmFyIF9oZWFkZXJHcm91cHMkMCRoZWFkZSwgX2hlYWRlckdyb3VwcyQ7XHJcbiAgLy8gRmluZCB0aGUgbWF4IGRlcHRoIG9mIHRoZSBjb2x1bW5zOlxyXG4gIC8vIGJ1aWxkIHRoZSBsZWFmIGNvbHVtbiByb3dcclxuICAvLyBidWlsZCBlYWNoIGJ1ZmZlciByb3cgZ29pbmcgdXBcclxuICAvLyAgICBwbGFjZWhvbGRlciBmb3Igbm9uLWV4aXN0ZW50IGxldmVsXHJcbiAgLy8gICAgcmVhbCBjb2x1bW4gZm9yIGV4aXN0aW5nIGxldmVsXHJcblxyXG4gIGxldCBtYXhEZXB0aCA9IDA7XHJcbiAgY29uc3QgZmluZE1heERlcHRoID0gZnVuY3Rpb24gKGNvbHVtbnMsIGRlcHRoKSB7XHJcbiAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xyXG4gICAgICBkZXB0aCA9IDE7XHJcbiAgICB9XHJcbiAgICBtYXhEZXB0aCA9IE1hdGgubWF4KG1heERlcHRoLCBkZXB0aCk7XHJcbiAgICBjb2x1bW5zLmZpbHRlcihjb2x1bW4gPT4gY29sdW1uLmdldElzVmlzaWJsZSgpKS5mb3JFYWNoKGNvbHVtbiA9PiB7XHJcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbnM7XHJcbiAgICAgIGlmICgoX2NvbHVtbiRjb2x1bW5zID0gY29sdW1uLmNvbHVtbnMpICE9IG51bGwgJiYgX2NvbHVtbiRjb2x1bW5zLmxlbmd0aCkge1xyXG4gICAgICAgIGZpbmRNYXhEZXB0aChjb2x1bW4uY29sdW1ucywgZGVwdGggKyAxKTtcclxuICAgICAgfVxyXG4gICAgfSwgMCk7XHJcbiAgfTtcclxuICBmaW5kTWF4RGVwdGgoYWxsQ29sdW1ucyk7XHJcbiAgbGV0IGhlYWRlckdyb3VwcyA9IFtdO1xyXG4gIGNvbnN0IGNyZWF0ZUhlYWRlckdyb3VwID0gKGhlYWRlcnNUb0dyb3VwLCBkZXB0aCkgPT4ge1xyXG4gICAgLy8gVGhlIGhlYWRlciBncm91cCB3ZSBhcmUgY3JlYXRpbmdcclxuICAgIGNvbnN0IGhlYWRlckdyb3VwID0ge1xyXG4gICAgICBkZXB0aCxcclxuICAgICAgaWQ6IFtoZWFkZXJGYW1pbHksIGAke2RlcHRofWBdLmZpbHRlcihCb29sZWFuKS5qb2luKCdfJyksXHJcbiAgICAgIGhlYWRlcnM6IFtdXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFRoZSBwYXJlbnQgY29sdW1ucyB3ZSdyZSBnb2luZyB0byBzY2FuIG5leHRcclxuICAgIGNvbnN0IHBlbmRpbmdQYXJlbnRIZWFkZXJzID0gW107XHJcblxyXG4gICAgLy8gU2NhbiBlYWNoIGNvbHVtbiBmb3IgcGFyZW50c1xyXG4gICAgaGVhZGVyc1RvR3JvdXAuZm9yRWFjaChoZWFkZXJUb0dyb3VwID0+IHtcclxuICAgICAgLy8gV2hhdCBpcyB0aGUgbGF0ZXN0IChsYXN0KSBwYXJlbnQgY29sdW1uP1xyXG5cclxuICAgICAgY29uc3QgbGF0ZXN0UGVuZGluZ1BhcmVudEhlYWRlciA9IFsuLi5wZW5kaW5nUGFyZW50SGVhZGVyc10ucmV2ZXJzZSgpWzBdO1xyXG4gICAgICBjb25zdCBpc0xlYWZIZWFkZXIgPSBoZWFkZXJUb0dyb3VwLmNvbHVtbi5kZXB0aCA9PT0gaGVhZGVyR3JvdXAuZGVwdGg7XHJcbiAgICAgIGxldCBjb2x1bW47XHJcbiAgICAgIGxldCBpc1BsYWNlaG9sZGVyID0gZmFsc2U7XHJcbiAgICAgIGlmIChpc0xlYWZIZWFkZXIgJiYgaGVhZGVyVG9Hcm91cC5jb2x1bW4ucGFyZW50KSB7XHJcbiAgICAgICAgLy8gVGhlIHBhcmVudCBoZWFkZXIgaXMgbmV3XHJcbiAgICAgICAgY29sdW1uID0gaGVhZGVyVG9Hcm91cC5jb2x1bW4ucGFyZW50O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFRoZSBwYXJlbnQgaGVhZGVyIGlzIHJlcGVhdGVkXHJcbiAgICAgICAgY29sdW1uID0gaGVhZGVyVG9Hcm91cC5jb2x1bW47XHJcbiAgICAgICAgaXNQbGFjZWhvbGRlciA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGxhdGVzdFBlbmRpbmdQYXJlbnRIZWFkZXIgJiYgKGxhdGVzdFBlbmRpbmdQYXJlbnRIZWFkZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGxhdGVzdFBlbmRpbmdQYXJlbnRIZWFkZXIuY29sdW1uKSA9PT0gY29sdW1uKSB7XHJcbiAgICAgICAgLy8gVGhpcyBjb2x1bW4gaXMgcmVwZWF0ZWQuIEFkZCBpdCBhcyBhIHN1YiBoZWFkZXIgdG8gdGhlIG5leHQgYmF0Y2hcclxuICAgICAgICBsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyLnN1YkhlYWRlcnMucHVzaChoZWFkZXJUb0dyb3VwKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBUaGlzIGlzIGEgbmV3IGhlYWRlci4gTGV0J3MgY3JlYXRlIGl0XHJcbiAgICAgICAgY29uc3QgaGVhZGVyID0gY3JlYXRlSGVhZGVyKHRhYmxlLCBjb2x1bW4sIHtcclxuICAgICAgICAgIGlkOiBbaGVhZGVyRmFtaWx5LCBkZXB0aCwgY29sdW1uLmlkLCBoZWFkZXJUb0dyb3VwID09IG51bGwgPyB2b2lkIDAgOiBoZWFkZXJUb0dyb3VwLmlkXS5maWx0ZXIoQm9vbGVhbikuam9pbignXycpLFxyXG4gICAgICAgICAgaXNQbGFjZWhvbGRlcixcclxuICAgICAgICAgIHBsYWNlaG9sZGVySWQ6IGlzUGxhY2Vob2xkZXIgPyBgJHtwZW5kaW5nUGFyZW50SGVhZGVycy5maWx0ZXIoZCA9PiBkLmNvbHVtbiA9PT0gY29sdW1uKS5sZW5ndGh9YCA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgIGRlcHRoLFxyXG4gICAgICAgICAgaW5kZXg6IHBlbmRpbmdQYXJlbnRIZWFkZXJzLmxlbmd0aFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIGhlYWRlclRvR3JvdXAgYXMgYSBzdWJIZWFkZXIgb2YgdGhlIG5ldyBoZWFkZXJcclxuICAgICAgICBoZWFkZXIuc3ViSGVhZGVycy5wdXNoKGhlYWRlclRvR3JvdXApO1xyXG4gICAgICAgIC8vIEFkZCB0aGUgbmV3IGhlYWRlciB0byB0aGUgcGVuZGluZ1BhcmVudEhlYWRlcnMgdG8gZ2V0IGdyb3VwZWRcclxuICAgICAgICAvLyBpbiB0aGUgbmV4dCBiYXRjaFxyXG4gICAgICAgIHBlbmRpbmdQYXJlbnRIZWFkZXJzLnB1c2goaGVhZGVyKTtcclxuICAgICAgfVxyXG4gICAgICBoZWFkZXJHcm91cC5oZWFkZXJzLnB1c2goaGVhZGVyVG9Hcm91cCk7XHJcbiAgICAgIGhlYWRlclRvR3JvdXAuaGVhZGVyR3JvdXAgPSBoZWFkZXJHcm91cDtcclxuICAgIH0pO1xyXG4gICAgaGVhZGVyR3JvdXBzLnB1c2goaGVhZGVyR3JvdXApO1xyXG4gICAgaWYgKGRlcHRoID4gMCkge1xyXG4gICAgICBjcmVhdGVIZWFkZXJHcm91cChwZW5kaW5nUGFyZW50SGVhZGVycywgZGVwdGggLSAxKTtcclxuICAgIH1cclxuICB9O1xyXG4gIGNvbnN0IGJvdHRvbUhlYWRlcnMgPSBjb2x1bW5zVG9Hcm91cC5tYXAoKGNvbHVtbiwgaW5kZXgpID0+IGNyZWF0ZUhlYWRlcih0YWJsZSwgY29sdW1uLCB7XHJcbiAgICBkZXB0aDogbWF4RGVwdGgsXHJcbiAgICBpbmRleFxyXG4gIH0pKTtcclxuICBjcmVhdGVIZWFkZXJHcm91cChib3R0b21IZWFkZXJzLCBtYXhEZXB0aCAtIDEpO1xyXG4gIGhlYWRlckdyb3Vwcy5yZXZlcnNlKCk7XHJcblxyXG4gIC8vIGhlYWRlckdyb3VwcyA9IGhlYWRlckdyb3Vwcy5maWx0ZXIoaGVhZGVyR3JvdXAgPT4ge1xyXG4gIC8vICAgcmV0dXJuICFoZWFkZXJHcm91cC5oZWFkZXJzLmV2ZXJ5KGhlYWRlciA9PiBoZWFkZXIuaXNQbGFjZWhvbGRlcilcclxuICAvLyB9KVxyXG5cclxuICBjb25zdCByZWN1cnNlSGVhZGVyc0ZvclNwYW5zID0gaGVhZGVycyA9PiB7XHJcbiAgICBjb25zdCBmaWx0ZXJlZEhlYWRlcnMgPSBoZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4gaGVhZGVyLmNvbHVtbi5nZXRJc1Zpc2libGUoKSk7XHJcbiAgICByZXR1cm4gZmlsdGVyZWRIZWFkZXJzLm1hcChoZWFkZXIgPT4ge1xyXG4gICAgICBsZXQgY29sU3BhbiA9IDA7XHJcbiAgICAgIGxldCByb3dTcGFuID0gMDtcclxuICAgICAgbGV0IGNoaWxkUm93U3BhbnMgPSBbMF07XHJcbiAgICAgIGlmIChoZWFkZXIuc3ViSGVhZGVycyAmJiBoZWFkZXIuc3ViSGVhZGVycy5sZW5ndGgpIHtcclxuICAgICAgICBjaGlsZFJvd1NwYW5zID0gW107XHJcbiAgICAgICAgcmVjdXJzZUhlYWRlcnNGb3JTcGFucyhoZWFkZXIuc3ViSGVhZGVycykuZm9yRWFjaChfcmVmID0+IHtcclxuICAgICAgICAgIGxldCB7XHJcbiAgICAgICAgICAgIGNvbFNwYW46IGNoaWxkQ29sU3BhbixcclxuICAgICAgICAgICAgcm93U3BhbjogY2hpbGRSb3dTcGFuXHJcbiAgICAgICAgICB9ID0gX3JlZjtcclxuICAgICAgICAgIGNvbFNwYW4gKz0gY2hpbGRDb2xTcGFuO1xyXG4gICAgICAgICAgY2hpbGRSb3dTcGFucy5wdXNoKGNoaWxkUm93U3Bhbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29sU3BhbiA9IDE7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgbWluQ2hpbGRSb3dTcGFuID0gTWF0aC5taW4oLi4uY2hpbGRSb3dTcGFucyk7XHJcbiAgICAgIHJvd1NwYW4gPSByb3dTcGFuICsgbWluQ2hpbGRSb3dTcGFuO1xyXG4gICAgICBoZWFkZXIuY29sU3BhbiA9IGNvbFNwYW47XHJcbiAgICAgIGhlYWRlci5yb3dTcGFuID0gcm93U3BhbjtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBjb2xTcGFuLFxyXG4gICAgICAgIHJvd1NwYW5cclxuICAgICAgfTtcclxuICAgIH0pO1xyXG4gIH07XHJcbiAgcmVjdXJzZUhlYWRlcnNGb3JTcGFucygoX2hlYWRlckdyb3VwcyQwJGhlYWRlID0gKF9oZWFkZXJHcm91cHMkID0gaGVhZGVyR3JvdXBzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2hlYWRlckdyb3VwcyQuaGVhZGVycykgIT0gbnVsbCA/IF9oZWFkZXJHcm91cHMkMCRoZWFkZSA6IFtdKTtcclxuICByZXR1cm4gaGVhZGVyR3JvdXBzO1xyXG59XHJcblxyXG5jb25zdCBjcmVhdGVSb3cgPSAodGFibGUsIGlkLCBvcmlnaW5hbCwgcm93SW5kZXgsIGRlcHRoLCBzdWJSb3dzLCBwYXJlbnRJZCkgPT4ge1xyXG4gIGxldCByb3cgPSB7XHJcbiAgICBpZCxcclxuICAgIGluZGV4OiByb3dJbmRleCxcclxuICAgIG9yaWdpbmFsLFxyXG4gICAgZGVwdGgsXHJcbiAgICBwYXJlbnRJZCxcclxuICAgIF92YWx1ZXNDYWNoZToge30sXHJcbiAgICBfdW5pcXVlVmFsdWVzQ2FjaGU6IHt9LFxyXG4gICAgZ2V0VmFsdWU6IGNvbHVtbklkID0+IHtcclxuICAgICAgaWYgKHJvdy5fdmFsdWVzQ2FjaGUuaGFzT3duUHJvcGVydHkoY29sdW1uSWQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCk7XHJcbiAgICAgIGlmICghKGNvbHVtbiAhPSBudWxsICYmIGNvbHVtbi5hY2Nlc3NvckZuKSkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF0gPSBjb2x1bW4uYWNjZXNzb3JGbihyb3cub3JpZ2luYWwsIHJvd0luZGV4KTtcclxuICAgICAgcmV0dXJuIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xyXG4gICAgfSxcclxuICAgIGdldFVuaXF1ZVZhbHVlczogY29sdW1uSWQgPT4ge1xyXG4gICAgICBpZiAocm93Ll91bmlxdWVWYWx1ZXNDYWNoZS5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZCkpIHtcclxuICAgICAgICByZXR1cm4gcm93Ll91bmlxdWVWYWx1ZXNDYWNoZVtjb2x1bW5JZF07XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKTtcclxuICAgICAgaWYgKCEoY29sdW1uICE9IG51bGwgJiYgY29sdW1uLmFjY2Vzc29yRm4pKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWNvbHVtbi5jb2x1bW5EZWYuZ2V0VW5pcXVlVmFsdWVzKSB7XHJcbiAgICAgICAgcm93Ll91bmlxdWVWYWx1ZXNDYWNoZVtjb2x1bW5JZF0gPSBbcm93LmdldFZhbHVlKGNvbHVtbklkKV07XHJcbiAgICAgICAgcmV0dXJuIHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xyXG4gICAgICB9XHJcbiAgICAgIHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gY29sdW1uLmNvbHVtbkRlZi5nZXRVbmlxdWVWYWx1ZXMocm93Lm9yaWdpbmFsLCByb3dJbmRleCk7XHJcbiAgICAgIHJldHVybiByb3cuX3VuaXF1ZVZhbHVlc0NhY2hlW2NvbHVtbklkXTtcclxuICAgIH0sXHJcbiAgICByZW5kZXJWYWx1ZTogY29sdW1uSWQgPT4ge1xyXG4gICAgICB2YXIgX3JvdyRnZXRWYWx1ZTtcclxuICAgICAgcmV0dXJuIChfcm93JGdldFZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgIT0gbnVsbCA/IF9yb3ckZ2V0VmFsdWUgOiB0YWJsZS5vcHRpb25zLnJlbmRlckZhbGxiYWNrVmFsdWU7XHJcbiAgICB9LFxyXG4gICAgc3ViUm93czogc3ViUm93cyAhPSBudWxsID8gc3ViUm93cyA6IFtdLFxyXG4gICAgZ2V0TGVhZlJvd3M6ICgpID0+IGZsYXR0ZW5CeShyb3cuc3ViUm93cywgZCA9PiBkLnN1YlJvd3MpLFxyXG4gICAgZ2V0UGFyZW50Um93OiAoKSA9PiByb3cucGFyZW50SWQgPyB0YWJsZS5nZXRSb3cocm93LnBhcmVudElkLCB0cnVlKSA6IHVuZGVmaW5lZCxcclxuICAgIGdldFBhcmVudFJvd3M6ICgpID0+IHtcclxuICAgICAgbGV0IHBhcmVudFJvd3MgPSBbXTtcclxuICAgICAgbGV0IGN1cnJlbnRSb3cgPSByb3c7XHJcbiAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50Um93ID0gY3VycmVudFJvdy5nZXRQYXJlbnRSb3coKTtcclxuICAgICAgICBpZiAoIXBhcmVudFJvdykgYnJlYWs7XHJcbiAgICAgICAgcGFyZW50Um93cy5wdXNoKHBhcmVudFJvdyk7XHJcbiAgICAgICAgY3VycmVudFJvdyA9IHBhcmVudFJvdztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcGFyZW50Um93cy5yZXZlcnNlKCk7XHJcbiAgICB9LFxyXG4gICAgZ2V0QWxsQ2VsbHM6IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbExlYWZDb2x1bW5zKCldLCBsZWFmQ29sdW1ucyA9PiB7XHJcbiAgICAgIHJldHVybiBsZWFmQ29sdW1ucy5tYXAoY29sdW1uID0+IHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlQ2VsbCh0YWJsZSwgcm93LCBjb2x1bW4sIGNvbHVtbi5pZCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRBbGxDZWxscycpKSxcclxuICAgIF9nZXRBbGxDZWxsc0J5Q29sdW1uSWQ6IG1lbW8oKCkgPT4gW3Jvdy5nZXRBbGxDZWxscygpXSwgYWxsQ2VsbHMgPT4ge1xyXG4gICAgICByZXR1cm4gYWxsQ2VsbHMucmVkdWNlKChhY2MsIGNlbGwpID0+IHtcclxuICAgICAgICBhY2NbY2VsbC5jb2x1bW4uaWRdID0gY2VsbDtcclxuICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgICB9LCB7fSk7XHJcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdSb3dzJywgJ2dldEFsbENlbGxzQnlDb2x1bW5JZCcpKVxyXG4gIH07XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWJsZS5fZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGZlYXR1cmUgPSB0YWJsZS5fZmVhdHVyZXNbaV07XHJcbiAgICBmZWF0dXJlID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVSb3cgPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZVJvdyhyb3csIHRhYmxlKTtcclxuICB9XHJcbiAgcmV0dXJuIHJvdztcclxufTtcclxuXHJcbi8vXHJcblxyXG5jb25zdCBDb2x1bW5GYWNldGluZyA9IHtcclxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XHJcbiAgICBjb2x1bW4uX2dldEZhY2V0ZWRSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFJvd01vZGVsKHRhYmxlLCBjb2x1bW4uaWQpO1xyXG4gICAgY29sdW1uLmdldEZhY2V0ZWRSb3dNb2RlbCA9ICgpID0+IHtcclxuICAgICAgaWYgKCFjb2x1bW4uX2dldEZhY2V0ZWRSb3dNb2RlbCkge1xyXG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNvbHVtbi5fZ2V0RmFjZXRlZFJvd01vZGVsKCk7XHJcbiAgICB9O1xyXG4gICAgY29sdW1uLl9nZXRGYWNldGVkVW5pcXVlVmFsdWVzID0gdGFibGUub3B0aW9ucy5nZXRGYWNldGVkVW5pcXVlVmFsdWVzICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyh0YWJsZSwgY29sdW1uLmlkKTtcclxuICAgIGNvbHVtbi5nZXRGYWNldGVkVW5pcXVlVmFsdWVzID0gKCkgPT4ge1xyXG4gICAgICBpZiAoIWNvbHVtbi5fZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcykge1xyXG4gICAgICAgIHJldHVybiBuZXcgTWFwKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNvbHVtbi5fZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcygpO1xyXG4gICAgfTtcclxuICAgIGNvbHVtbi5fZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXModGFibGUsIGNvbHVtbi5pZCk7XHJcbiAgICBjb2x1bW4uZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyA9ICgpID0+IHtcclxuICAgICAgaWYgKCFjb2x1bW4uX2dldEZhY2V0ZWRNaW5NYXhWYWx1ZXMpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjb2x1bW4uX2dldEZhY2V0ZWRNaW5NYXhWYWx1ZXMoKTtcclxuICAgIH07XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgaW5jbHVkZXNTdHJpbmcgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcclxuICB2YXIgX3JvdyRnZXRWYWx1ZTtcclxuICBjb25zdCBzZWFyY2ggPSBmaWx0ZXJWYWx1ZS50b0xvd2VyQ2FzZSgpO1xyXG4gIHJldHVybiBCb29sZWFuKChfcm93JGdldFZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgPT0gbnVsbCB8fCAoX3JvdyRnZXRWYWx1ZSA9IF9yb3ckZ2V0VmFsdWUudG9TdHJpbmcoKSkgPT0gbnVsbCB8fCAoX3JvdyRnZXRWYWx1ZSA9IF9yb3ckZ2V0VmFsdWUudG9Mb3dlckNhc2UoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3ckZ2V0VmFsdWUuaW5jbHVkZXMoc2VhcmNoKSk7XHJcbn07XHJcbmluY2x1ZGVzU3RyaW5nLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpO1xyXG5jb25zdCBpbmNsdWRlc1N0cmluZ1NlbnNpdGl2ZSA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xyXG4gIHZhciBfcm93JGdldFZhbHVlMjtcclxuICByZXR1cm4gQm9vbGVhbigoX3JvdyRnZXRWYWx1ZTIgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSA9PSBudWxsIHx8IChfcm93JGdldFZhbHVlMiA9IF9yb3ckZ2V0VmFsdWUyLnRvU3RyaW5nKCkpID09IG51bGwgPyB2b2lkIDAgOiBfcm93JGdldFZhbHVlMi5pbmNsdWRlcyhmaWx0ZXJWYWx1ZSkpO1xyXG59O1xyXG5pbmNsdWRlc1N0cmluZ1NlbnNpdGl2ZS5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKTtcclxuY29uc3QgZXF1YWxzU3RyaW5nID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XHJcbiAgdmFyIF9yb3ckZ2V0VmFsdWUzO1xyXG4gIHJldHVybiAoKF9yb3ckZ2V0VmFsdWUzID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgPT0gbnVsbCB8fCAoX3JvdyRnZXRWYWx1ZTMgPSBfcm93JGdldFZhbHVlMy50b1N0cmluZygpKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdyRnZXRWYWx1ZTMudG9Mb3dlckNhc2UoKSkgPT09IChmaWx0ZXJWYWx1ZSA9PSBudWxsID8gdm9pZCAwIDogZmlsdGVyVmFsdWUudG9Mb3dlckNhc2UoKSk7XHJcbn07XHJcbmVxdWFsc1N0cmluZy5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKTtcclxuY29uc3QgYXJySW5jbHVkZXMgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcclxuICB2YXIgX3JvdyRnZXRWYWx1ZTQ7XHJcbiAgcmV0dXJuIChfcm93JGdldFZhbHVlNCA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpID09IG51bGwgPyB2b2lkIDAgOiBfcm93JGdldFZhbHVlNC5pbmNsdWRlcyhmaWx0ZXJWYWx1ZSk7XHJcbn07XHJcbmFyckluY2x1ZGVzLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpIHx8ICEodmFsICE9IG51bGwgJiYgdmFsLmxlbmd0aCk7XHJcbmNvbnN0IGFyckluY2x1ZGVzQWxsID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XHJcbiAgcmV0dXJuICFmaWx0ZXJWYWx1ZS5zb21lKHZhbCA9PiB7XHJcbiAgICB2YXIgX3JvdyRnZXRWYWx1ZTU7XHJcbiAgICByZXR1cm4gISgoX3JvdyRnZXRWYWx1ZTUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSAhPSBudWxsICYmIF9yb3ckZ2V0VmFsdWU1LmluY2x1ZGVzKHZhbCkpO1xyXG4gIH0pO1xyXG59O1xyXG5hcnJJbmNsdWRlc0FsbC5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKSB8fCAhKHZhbCAhPSBudWxsICYmIHZhbC5sZW5ndGgpO1xyXG5jb25zdCBhcnJJbmNsdWRlc1NvbWUgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcclxuICByZXR1cm4gZmlsdGVyVmFsdWUuc29tZSh2YWwgPT4ge1xyXG4gICAgdmFyIF9yb3ckZ2V0VmFsdWU2O1xyXG4gICAgcmV0dXJuIChfcm93JGdldFZhbHVlNiA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpID09IG51bGwgPyB2b2lkIDAgOiBfcm93JGdldFZhbHVlNi5pbmNsdWRlcyh2YWwpO1xyXG4gIH0pO1xyXG59O1xyXG5hcnJJbmNsdWRlc1NvbWUuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCkgfHwgISh2YWwgIT0gbnVsbCAmJiB2YWwubGVuZ3RoKTtcclxuY29uc3QgZXF1YWxzID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XHJcbiAgcmV0dXJuIHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkgPT09IGZpbHRlclZhbHVlO1xyXG59O1xyXG5lcXVhbHMuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCk7XHJcbmNvbnN0IHdlYWtFcXVhbHMgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcclxuICByZXR1cm4gcm93LmdldFZhbHVlKGNvbHVtbklkKSA9PSBmaWx0ZXJWYWx1ZTtcclxufTtcclxud2Vha0VxdWFscy5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKTtcclxuY29uc3QgaW5OdW1iZXJSYW5nZSA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xyXG4gIGxldCBbbWluLCBtYXhdID0gZmlsdGVyVmFsdWU7XHJcbiAgY29uc3Qgcm93VmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpO1xyXG4gIHJldHVybiByb3dWYWx1ZSA+PSBtaW4gJiYgcm93VmFsdWUgPD0gbWF4O1xyXG59O1xyXG5pbk51bWJlclJhbmdlLnJlc29sdmVGaWx0ZXJWYWx1ZSA9IHZhbCA9PiB7XHJcbiAgbGV0IFt1bnNhZmVNaW4sIHVuc2FmZU1heF0gPSB2YWw7XHJcbiAgbGV0IHBhcnNlZE1pbiA9IHR5cGVvZiB1bnNhZmVNaW4gIT09ICdudW1iZXInID8gcGFyc2VGbG9hdCh1bnNhZmVNaW4pIDogdW5zYWZlTWluO1xyXG4gIGxldCBwYXJzZWRNYXggPSB0eXBlb2YgdW5zYWZlTWF4ICE9PSAnbnVtYmVyJyA/IHBhcnNlRmxvYXQodW5zYWZlTWF4KSA6IHVuc2FmZU1heDtcclxuICBsZXQgbWluID0gdW5zYWZlTWluID09PSBudWxsIHx8IE51bWJlci5pc05hTihwYXJzZWRNaW4pID8gLUluZmluaXR5IDogcGFyc2VkTWluO1xyXG4gIGxldCBtYXggPSB1bnNhZmVNYXggPT09IG51bGwgfHwgTnVtYmVyLmlzTmFOKHBhcnNlZE1heCkgPyBJbmZpbml0eSA6IHBhcnNlZE1heDtcclxuICBpZiAobWluID4gbWF4KSB7XHJcbiAgICBjb25zdCB0ZW1wID0gbWluO1xyXG4gICAgbWluID0gbWF4O1xyXG4gICAgbWF4ID0gdGVtcDtcclxuICB9XHJcbiAgcmV0dXJuIFttaW4sIG1heF07XHJcbn07XHJcbmluTnVtYmVyUmFuZ2UuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCkgfHwgdGVzdEZhbHNleSh2YWxbMF0pICYmIHRlc3RGYWxzZXkodmFsWzFdKTtcclxuXHJcbi8vIEV4cG9ydFxyXG5cclxuY29uc3QgZmlsdGVyRm5zID0ge1xyXG4gIGluY2x1ZGVzU3RyaW5nLFxyXG4gIGluY2x1ZGVzU3RyaW5nU2Vuc2l0aXZlLFxyXG4gIGVxdWFsc1N0cmluZyxcclxuICBhcnJJbmNsdWRlcyxcclxuICBhcnJJbmNsdWRlc0FsbCxcclxuICBhcnJJbmNsdWRlc1NvbWUsXHJcbiAgZXF1YWxzLFxyXG4gIHdlYWtFcXVhbHMsXHJcbiAgaW5OdW1iZXJSYW5nZVxyXG59O1xyXG4vLyBVdGlsc1xyXG5cclxuZnVuY3Rpb24gdGVzdEZhbHNleSh2YWwpIHtcclxuICByZXR1cm4gdmFsID09PSB1bmRlZmluZWQgfHwgdmFsID09PSBudWxsIHx8IHZhbCA9PT0gJyc7XHJcbn1cclxuXHJcbi8vXHJcblxyXG5jb25zdCBDb2x1bW5GaWx0ZXJpbmcgPSB7XHJcbiAgZ2V0RGVmYXVsdENvbHVtbkRlZjogKCkgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZmlsdGVyRm46ICdhdXRvJ1xyXG4gICAgfTtcclxuICB9LFxyXG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY29sdW1uRmlsdGVyczogW10sXHJcbiAgICAgIC4uLnN0YXRlXHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG9uQ29sdW1uRmlsdGVyc0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uRmlsdGVycycsIHRhYmxlKSxcclxuICAgICAgZmlsdGVyRnJvbUxlYWZSb3dzOiBmYWxzZSxcclxuICAgICAgbWF4TGVhZlJvd0ZpbHRlckRlcHRoOiAxMDBcclxuICAgIH07XHJcbiAgfSxcclxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XHJcbiAgICBjb2x1bW4uZ2V0QXV0b0ZpbHRlckZuID0gKCkgPT4ge1xyXG4gICAgICBjb25zdCBmaXJzdFJvdyA9IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpLmZsYXRSb3dzWzBdO1xyXG4gICAgICBjb25zdCB2YWx1ZSA9IGZpcnN0Um93ID09IG51bGwgPyB2b2lkIDAgOiBmaXJzdFJvdy5nZXRWYWx1ZShjb2x1bW4uaWQpO1xyXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBmaWx0ZXJGbnMuaW5jbHVkZXNTdHJpbmc7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gZmlsdGVyRm5zLmluTnVtYmVyUmFuZ2U7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlckZucy5lcXVhbHM7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICByZXR1cm4gZmlsdGVyRm5zLmVxdWFscztcclxuICAgICAgfVxyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gZmlsdGVyRm5zLmFyckluY2x1ZGVzO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmaWx0ZXJGbnMud2Vha0VxdWFscztcclxuICAgIH07XHJcbiAgICBjb2x1bW4uZ2V0RmlsdGVyRm4gPSAoKSA9PiB7XHJcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRmaWx0ZXIsIF90YWJsZSRvcHRpb25zJGZpbHRlcjI7XHJcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGNvbHVtbi5jb2x1bW5EZWYuZmlsdGVyRm4pID8gY29sdW1uLmNvbHVtbkRlZi5maWx0ZXJGbiA6IGNvbHVtbi5jb2x1bW5EZWYuZmlsdGVyRm4gPT09ICdhdXRvJyA/IGNvbHVtbi5nZXRBdXRvRmlsdGVyRm4oKSA6IC8vIEB0cy1pZ25vcmVcclxuICAgICAgKF90YWJsZSRvcHRpb25zJGZpbHRlciA9IChfdGFibGUkb3B0aW9ucyRmaWx0ZXIyID0gdGFibGUub3B0aW9ucy5maWx0ZXJGbnMpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkb3B0aW9ucyRmaWx0ZXIyW2NvbHVtbi5jb2x1bW5EZWYuZmlsdGVyRm5dKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZmlsdGVyIDogZmlsdGVyRm5zW2NvbHVtbi5jb2x1bW5EZWYuZmlsdGVyRm5dO1xyXG4gICAgfTtcclxuICAgIGNvbHVtbi5nZXRDYW5GaWx0ZXIgPSAoKSA9PiB7XHJcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbkRlZiRlbmEsIF90YWJsZSRvcHRpb25zJGVuYWJsZSwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlMjtcclxuICAgICAgcmV0dXJuICgoX2NvbHVtbiRjb2x1bW5EZWYkZW5hID0gY29sdW1uLmNvbHVtbkRlZi5lbmFibGVDb2x1bW5GaWx0ZXIpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlQ29sdW1uRmlsdGVycykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlRmlsdGVycykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTIgOiB0cnVlKSAmJiAhIWNvbHVtbi5hY2Nlc3NvckZuO1xyXG4gICAgfTtcclxuICAgIGNvbHVtbi5nZXRJc0ZpbHRlcmVkID0gKCkgPT4gY29sdW1uLmdldEZpbHRlckluZGV4KCkgPiAtMTtcclxuICAgIGNvbHVtbi5nZXRGaWx0ZXJWYWx1ZSA9ICgpID0+IHtcclxuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRjb2x1bTtcclxuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0U3RhdGUkY29sdW0gPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtbkZpbHRlcnMpID09IG51bGwgfHwgKF90YWJsZSRnZXRTdGF0ZSRjb2x1bSA9IF90YWJsZSRnZXRTdGF0ZSRjb2x1bS5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRjb2x1bS52YWx1ZTtcclxuICAgIH07XHJcbiAgICBjb2x1bW4uZ2V0RmlsdGVySW5kZXggPSAoKSA9PiB7XHJcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkY29sdW0yLCBfdGFibGUkZ2V0U3RhdGUkY29sdW0zO1xyXG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIgPSAoX3RhYmxlJGdldFN0YXRlJGNvbHVtMyA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uRmlsdGVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRjb2x1bTMuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIgOiAtMTtcclxuICAgIH07XHJcbiAgICBjb2x1bW4uc2V0RmlsdGVyVmFsdWUgPSB2YWx1ZSA9PiB7XHJcbiAgICAgIHRhYmxlLnNldENvbHVtbkZpbHRlcnMob2xkID0+IHtcclxuICAgICAgICBjb25zdCBmaWx0ZXJGbiA9IGNvbHVtbi5nZXRGaWx0ZXJGbigpO1xyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzRmlsdGVyID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCk7XHJcbiAgICAgICAgY29uc3QgbmV3RmlsdGVyID0gZnVuY3Rpb25hbFVwZGF0ZSh2YWx1ZSwgcHJldmlvdXNGaWx0ZXIgPyBwcmV2aW91c0ZpbHRlci52YWx1ZSA6IHVuZGVmaW5lZCk7XHJcblxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgaWYgKHNob3VsZEF1dG9SZW1vdmVGaWx0ZXIoZmlsdGVyRm4sIG5ld0ZpbHRlciwgY29sdW1uKSkge1xyXG4gICAgICAgICAgdmFyIF9vbGQkZmlsdGVyO1xyXG4gICAgICAgICAgcmV0dXJuIChfb2xkJGZpbHRlciA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmZpbHRlcihkID0+IGQuaWQgIT09IGNvbHVtbi5pZCkpICE9IG51bGwgPyBfb2xkJGZpbHRlciA6IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXdGaWx0ZXJPYmogPSB7XHJcbiAgICAgICAgICBpZDogY29sdW1uLmlkLFxyXG4gICAgICAgICAgdmFsdWU6IG5ld0ZpbHRlclxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHByZXZpb3VzRmlsdGVyKSB7XHJcbiAgICAgICAgICB2YXIgX29sZCRtYXA7XHJcbiAgICAgICAgICByZXR1cm4gKF9vbGQkbWFwID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQubWFwKGQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZC5pZCA9PT0gY29sdW1uLmlkKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld0ZpbHRlck9iajtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZDtcclxuICAgICAgICAgIH0pKSAhPSBudWxsID8gX29sZCRtYXAgOiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9sZCAhPSBudWxsICYmIG9sZC5sZW5ndGgpIHtcclxuICAgICAgICAgIHJldHVybiBbLi4ub2xkLCBuZXdGaWx0ZXJPYmpdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW25ld0ZpbHRlck9ial07XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuICB9LFxyXG4gIGNyZWF0ZVJvdzogKHJvdywgX3RhYmxlKSA9PiB7XHJcbiAgICByb3cuY29sdW1uRmlsdGVycyA9IHt9O1xyXG4gICAgcm93LmNvbHVtbkZpbHRlcnNNZXRhID0ge307XHJcbiAgfSxcclxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xyXG4gICAgdGFibGUuc2V0Q29sdW1uRmlsdGVycyA9IHVwZGF0ZXIgPT4ge1xyXG4gICAgICBjb25zdCBsZWFmQ29sdW1ucyA9IHRhYmxlLmdldEFsbExlYWZDb2x1bW5zKCk7XHJcbiAgICAgIGNvbnN0IHVwZGF0ZUZuID0gb2xkID0+IHtcclxuICAgICAgICB2YXIgX2Z1bmN0aW9uYWxVcGRhdGU7XHJcbiAgICAgICAgcmV0dXJuIChfZnVuY3Rpb25hbFVwZGF0ZSA9IGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgb2xkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mdW5jdGlvbmFsVXBkYXRlLmZpbHRlcihmaWx0ZXIgPT4ge1xyXG4gICAgICAgICAgY29uc3QgY29sdW1uID0gbGVhZkNvbHVtbnMuZmluZChkID0+IGQuaWQgPT09IGZpbHRlci5pZCk7XHJcbiAgICAgICAgICBpZiAoY29sdW1uKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlckZuID0gY29sdW1uLmdldEZpbHRlckZuKCk7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRBdXRvUmVtb3ZlRmlsdGVyKGZpbHRlckZuLCBmaWx0ZXIudmFsdWUsIGNvbHVtbikpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG4gICAgICB0YWJsZS5vcHRpb25zLm9uQ29sdW1uRmlsdGVyc0NoYW5nZSA9PSBudWxsIHx8IHRhYmxlLm9wdGlvbnMub25Db2x1bW5GaWx0ZXJzQ2hhbmdlKHVwZGF0ZUZuKTtcclxuICAgIH07XHJcbiAgICB0YWJsZS5yZXNldENvbHVtbkZpbHRlcnMgPSBkZWZhdWx0U3RhdGUgPT4ge1xyXG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRjLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xyXG4gICAgICB0YWJsZS5zZXRDb2x1bW5GaWx0ZXJzKGRlZmF1bHRTdGF0ZSA/IFtdIDogKF90YWJsZSRpbml0aWFsU3RhdGUkYyA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5jb2x1bW5GaWx0ZXJzKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjIDogW10pO1xyXG4gICAgfTtcclxuICAgIHRhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRDb3JlUm93TW9kZWwoKTtcclxuICAgIHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwgPSAoKSA9PiB7XHJcbiAgICAgIGlmICghdGFibGUuX2dldEZpbHRlcmVkUm93TW9kZWwgJiYgdGFibGUub3B0aW9ucy5nZXRGaWx0ZXJlZFJvd01vZGVsKSB7XHJcbiAgICAgICAgdGFibGUuX2dldEZpbHRlcmVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldEZpbHRlcmVkUm93TW9kZWwodGFibGUpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0YWJsZS5vcHRpb25zLm1hbnVhbEZpbHRlcmluZyB8fCAhdGFibGUuX2dldEZpbHRlcmVkUm93TW9kZWwpIHtcclxuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0RmlsdGVyZWRSb3dNb2RlbCgpO1xyXG4gICAgfTtcclxuICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNob3VsZEF1dG9SZW1vdmVGaWx0ZXIoZmlsdGVyRm4sIHZhbHVlLCBjb2x1bW4pIHtcclxuICByZXR1cm4gKGZpbHRlckZuICYmIGZpbHRlckZuLmF1dG9SZW1vdmUgPyBmaWx0ZXJGbi5hdXRvUmVtb3ZlKHZhbHVlLCBjb2x1bW4pIDogZmFsc2UpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAhdmFsdWU7XHJcbn1cclxuXHJcbmNvbnN0IHN1bSA9IChjb2x1bW5JZCwgX2xlYWZSb3dzLCBjaGlsZFJvd3MpID0+IHtcclxuICAvLyBJdCdzIGZhc3RlciB0byBqdXN0IGFkZCB0aGUgYWdncmVnYXRpb25zIHRvZ2V0aGVyIGluc3RlYWQgb2ZcclxuICAvLyBwcm9jZXNzIGxlYWYgbm9kZXMgaW5kaXZpZHVhbGx5XHJcbiAgcmV0dXJuIGNoaWxkUm93cy5yZWR1Y2UoKHN1bSwgbmV4dCkgPT4ge1xyXG4gICAgY29uc3QgbmV4dFZhbHVlID0gbmV4dC5nZXRWYWx1ZShjb2x1bW5JZCk7XHJcbiAgICByZXR1cm4gc3VtICsgKHR5cGVvZiBuZXh0VmFsdWUgPT09ICdudW1iZXInID8gbmV4dFZhbHVlIDogMCk7XHJcbiAgfSwgMCk7XHJcbn07XHJcbmNvbnN0IG1pbiA9IChjb2x1bW5JZCwgX2xlYWZSb3dzLCBjaGlsZFJvd3MpID0+IHtcclxuICBsZXQgbWluO1xyXG4gIGNoaWxkUm93cy5mb3JFYWNoKHJvdyA9PiB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCk7XHJcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAobWluID4gdmFsdWUgfHwgbWluID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSB7XHJcbiAgICAgIG1pbiA9IHZhbHVlO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiBtaW47XHJcbn07XHJcbmNvbnN0IG1heCA9IChjb2x1bW5JZCwgX2xlYWZSb3dzLCBjaGlsZFJvd3MpID0+IHtcclxuICBsZXQgbWF4O1xyXG4gIGNoaWxkUm93cy5mb3JFYWNoKHJvdyA9PiB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCk7XHJcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAobWF4IDwgdmFsdWUgfHwgbWF4ID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSB7XHJcbiAgICAgIG1heCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiBtYXg7XHJcbn07XHJcbmNvbnN0IGV4dGVudCA9IChjb2x1bW5JZCwgX2xlYWZSb3dzLCBjaGlsZFJvd3MpID0+IHtcclxuICBsZXQgbWluO1xyXG4gIGxldCBtYXg7XHJcbiAgY2hpbGRSb3dzLmZvckVhY2gocm93ID0+IHtcclxuICAgIGNvbnN0IHZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKTtcclxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgIGlmIChtaW4gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA+PSB2YWx1ZSkgbWluID0gbWF4ID0gdmFsdWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKG1pbiA+IHZhbHVlKSBtaW4gPSB2YWx1ZTtcclxuICAgICAgICBpZiAobWF4IDwgdmFsdWUpIG1heCA9IHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIFttaW4sIG1heF07XHJcbn07XHJcbmNvbnN0IG1lYW4gPSAoY29sdW1uSWQsIGxlYWZSb3dzKSA9PiB7XHJcbiAgbGV0IGNvdW50ID0gMDtcclxuICBsZXQgc3VtID0gMDtcclxuICBsZWFmUm93cy5mb3JFYWNoKHJvdyA9PiB7XHJcbiAgICBsZXQgdmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpO1xyXG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgKHZhbHVlID0gK3ZhbHVlKSA+PSB2YWx1ZSkge1xyXG4gICAgICArK2NvdW50LCBzdW0gKz0gdmFsdWU7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgaWYgKGNvdW50KSByZXR1cm4gc3VtIC8gY291bnQ7XHJcbiAgcmV0dXJuO1xyXG59O1xyXG5jb25zdCBtZWRpYW4gPSAoY29sdW1uSWQsIGxlYWZSb3dzKSA9PiB7XHJcbiAgaWYgKCFsZWFmUm93cy5sZW5ndGgpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY29uc3QgdmFsdWVzID0gbGVhZlJvd3MubWFwKHJvdyA9PiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKTtcclxuICBpZiAoIWlzTnVtYmVyQXJyYXkodmFsdWVzKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgcmV0dXJuIHZhbHVlc1swXTtcclxuICB9XHJcbiAgY29uc3QgbWlkID0gTWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoIC8gMik7XHJcbiAgY29uc3QgbnVtcyA9IHZhbHVlcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XHJcbiAgcmV0dXJuIHZhbHVlcy5sZW5ndGggJSAyICE9PSAwID8gbnVtc1ttaWRdIDogKG51bXNbbWlkIC0gMV0gKyBudW1zW21pZF0pIC8gMjtcclxufTtcclxuY29uc3QgdW5pcXVlID0gKGNvbHVtbklkLCBsZWFmUm93cykgPT4ge1xyXG4gIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQobGVhZlJvd3MubWFwKGQgPT4gZC5nZXRWYWx1ZShjb2x1bW5JZCkpKS52YWx1ZXMoKSk7XHJcbn07XHJcbmNvbnN0IHVuaXF1ZUNvdW50ID0gKGNvbHVtbklkLCBsZWFmUm93cykgPT4ge1xyXG4gIHJldHVybiBuZXcgU2V0KGxlYWZSb3dzLm1hcChkID0+IGQuZ2V0VmFsdWUoY29sdW1uSWQpKSkuc2l6ZTtcclxufTtcclxuY29uc3QgY291bnQgPSAoX2NvbHVtbklkLCBsZWFmUm93cykgPT4ge1xyXG4gIHJldHVybiBsZWFmUm93cy5sZW5ndGg7XHJcbn07XHJcbmNvbnN0IGFnZ3JlZ2F0aW9uRm5zID0ge1xyXG4gIHN1bSxcclxuICBtaW4sXHJcbiAgbWF4LFxyXG4gIGV4dGVudCxcclxuICBtZWFuLFxyXG4gIG1lZGlhbixcclxuICB1bmlxdWUsXHJcbiAgdW5pcXVlQ291bnQsXHJcbiAgY291bnRcclxufTtcclxuXHJcbi8vXHJcblxyXG5jb25zdCBDb2x1bW5Hcm91cGluZyA9IHtcclxuICBnZXREZWZhdWx0Q29sdW1uRGVmOiAoKSA9PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBhZ2dyZWdhdGVkQ2VsbDogcHJvcHMgPT4ge1xyXG4gICAgICAgIHZhciBfdG9TdHJpbmcsIF9wcm9wcyRnZXRWYWx1ZTtcclxuICAgICAgICByZXR1cm4gKF90b1N0cmluZyA9IChfcHJvcHMkZ2V0VmFsdWUgPSBwcm9wcy5nZXRWYWx1ZSgpKSA9PSBudWxsIHx8IF9wcm9wcyRnZXRWYWx1ZS50b1N0cmluZyA9PSBudWxsID8gdm9pZCAwIDogX3Byb3BzJGdldFZhbHVlLnRvU3RyaW5nKCkpICE9IG51bGwgPyBfdG9TdHJpbmcgOiBudWxsO1xyXG4gICAgICB9LFxyXG4gICAgICBhZ2dyZWdhdGlvbkZuOiAnYXV0bydcclxuICAgIH07XHJcbiAgfSxcclxuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGdyb3VwaW5nOiBbXSxcclxuICAgICAgLi4uc3RhdGVcclxuICAgIH07XHJcbiAgfSxcclxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgb25Hcm91cGluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignZ3JvdXBpbmcnLCB0YWJsZSksXHJcbiAgICAgIGdyb3VwZWRDb2x1bW5Nb2RlOiAncmVvcmRlcidcclxuICAgIH07XHJcbiAgfSxcclxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XHJcbiAgICBjb2x1bW4udG9nZ2xlR3JvdXBpbmcgPSAoKSA9PiB7XHJcbiAgICAgIHRhYmxlLnNldEdyb3VwaW5nKG9sZCA9PiB7XHJcbiAgICAgICAgLy8gRmluZCBhbnkgZXhpc3RpbmcgZ3JvdXBpbmcgZm9yIHRoaXMgY29sdW1uXHJcbiAgICAgICAgaWYgKG9sZCAhPSBudWxsICYmIG9sZC5pbmNsdWRlcyhjb2x1bW4uaWQpKSB7XHJcbiAgICAgICAgICByZXR1cm4gb2xkLmZpbHRlcihkID0+IGQgIT09IGNvbHVtbi5pZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbLi4uKG9sZCAhPSBudWxsID8gb2xkIDogW10pLCBjb2x1bW4uaWRdO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgICBjb2x1bW4uZ2V0Q2FuR3JvdXAgPSAoKSA9PiB7XHJcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbkRlZiRlbmEsIF90YWJsZSRvcHRpb25zJGVuYWJsZTtcclxuICAgICAgcmV0dXJuICgoX2NvbHVtbiRjb2x1bW5EZWYkZW5hID0gY29sdW1uLmNvbHVtbkRlZi5lbmFibGVHcm91cGluZykgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJGVuYSA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVHcm91cGluZykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWUpICYmICghIWNvbHVtbi5hY2Nlc3NvckZuIHx8ICEhY29sdW1uLmNvbHVtbkRlZi5nZXRHcm91cGluZ1ZhbHVlKTtcclxuICAgIH07XHJcbiAgICBjb2x1bW4uZ2V0SXNHcm91cGVkID0gKCkgPT4ge1xyXG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJGdyb3VwO1xyXG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRTdGF0ZSRncm91cCA9IHRhYmxlLmdldFN0YXRlKCkuZ3JvdXBpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkZ3JvdXAuaW5jbHVkZXMoY29sdW1uLmlkKTtcclxuICAgIH07XHJcbiAgICBjb2x1bW4uZ2V0R3JvdXBlZEluZGV4ID0gKCkgPT4ge1xyXG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJGdyb3VwMjtcclxuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0U3RhdGUkZ3JvdXAyID0gdGFibGUuZ2V0U3RhdGUoKS5ncm91cGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRncm91cDIuaW5kZXhPZihjb2x1bW4uaWQpO1xyXG4gICAgfTtcclxuICAgIGNvbHVtbi5nZXRUb2dnbGVHcm91cGluZ0hhbmRsZXIgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNhbkdyb3VwID0gY29sdW1uLmdldENhbkdyb3VwKCk7XHJcbiAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFjYW5Hcm91cCkgcmV0dXJuO1xyXG4gICAgICAgIGNvbHVtbi50b2dnbGVHcm91cGluZygpO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICAgIGNvbHVtbi5nZXRBdXRvQWdncmVnYXRpb25GbiA9ICgpID0+IHtcclxuICAgICAgY29uc3QgZmlyc3RSb3cgPSB0YWJsZS5nZXRDb3JlUm93TW9kZWwoKS5mbGF0Um93c1swXTtcclxuICAgICAgY29uc3QgdmFsdWUgPSBmaXJzdFJvdyA9PSBudWxsID8gdm9pZCAwIDogZmlyc3RSb3cuZ2V0VmFsdWUoY29sdW1uLmlkKTtcclxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gYWdncmVnYXRpb25GbnMuc3VtO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBEYXRlXScpIHtcclxuICAgICAgICByZXR1cm4gYWdncmVnYXRpb25GbnMuZXh0ZW50O1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29sdW1uLmdldEFnZ3JlZ2F0aW9uRm4gPSAoKSA9PiB7XHJcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRhZ2dyZWcsIF90YWJsZSRvcHRpb25zJGFnZ3JlZzI7XHJcbiAgICAgIGlmICghY29sdW1uKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oY29sdW1uLmNvbHVtbkRlZi5hZ2dyZWdhdGlvbkZuKSA/IGNvbHVtbi5jb2x1bW5EZWYuYWdncmVnYXRpb25GbiA6IGNvbHVtbi5jb2x1bW5EZWYuYWdncmVnYXRpb25GbiA9PT0gJ2F1dG8nID8gY29sdW1uLmdldEF1dG9BZ2dyZWdhdGlvbkZuKCkgOiAoX3RhYmxlJG9wdGlvbnMkYWdncmVnID0gKF90YWJsZSRvcHRpb25zJGFnZ3JlZzIgPSB0YWJsZS5vcHRpb25zLmFnZ3JlZ2F0aW9uRm5zKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJG9wdGlvbnMkYWdncmVnMltjb2x1bW4uY29sdW1uRGVmLmFnZ3JlZ2F0aW9uRm5dKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkYWdncmVnIDogYWdncmVnYXRpb25GbnNbY29sdW1uLmNvbHVtbkRlZi5hZ2dyZWdhdGlvbkZuXTtcclxuICAgIH07XHJcbiAgfSxcclxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xyXG4gICAgdGFibGUuc2V0R3JvdXBpbmcgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Hcm91cGluZ0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vbkdyb3VwaW5nQ2hhbmdlKHVwZGF0ZXIpO1xyXG4gICAgdGFibGUucmVzZXRHcm91cGluZyA9IGRlZmF1bHRTdGF0ZSA9PiB7XHJcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGcsIF90YWJsZSRpbml0aWFsU3RhdGU7XHJcbiAgICAgIHRhYmxlLnNldEdyb3VwaW5nKGRlZmF1bHRTdGF0ZSA/IFtdIDogKF90YWJsZSRpbml0aWFsU3RhdGUkZyA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5ncm91cGluZykgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkZyA6IFtdKTtcclxuICAgIH07XHJcbiAgICB0YWJsZS5nZXRQcmVHcm91cGVkUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCk7XHJcbiAgICB0YWJsZS5nZXRHcm91cGVkUm93TW9kZWwgPSAoKSA9PiB7XHJcbiAgICAgIGlmICghdGFibGUuX2dldEdyb3VwZWRSb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldEdyb3VwZWRSb3dNb2RlbCkge1xyXG4gICAgICAgIHRhYmxlLl9nZXRHcm91cGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldEdyb3VwZWRSb3dNb2RlbCh0YWJsZSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRhYmxlLm9wdGlvbnMubWFudWFsR3JvdXBpbmcgfHwgIXRhYmxlLl9nZXRHcm91cGVkUm93TW9kZWwpIHtcclxuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlR3JvdXBlZFJvd01vZGVsKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRHcm91cGVkUm93TW9kZWwoKTtcclxuICAgIH07XHJcbiAgfSxcclxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XHJcbiAgICByb3cuZ2V0SXNHcm91cGVkID0gKCkgPT4gISFyb3cuZ3JvdXBpbmdDb2x1bW5JZDtcclxuICAgIHJvdy5nZXRHcm91cGluZ1ZhbHVlID0gY29sdW1uSWQgPT4ge1xyXG4gICAgICBpZiAocm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xyXG4gICAgICAgIHJldHVybiByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCk7XHJcbiAgICAgIGlmICghKGNvbHVtbiAhPSBudWxsICYmIGNvbHVtbi5jb2x1bW5EZWYuZ2V0R3JvdXBpbmdWYWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gcm93LmdldFZhbHVlKGNvbHVtbklkKTtcclxuICAgICAgfVxyXG4gICAgICByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gY29sdW1uLmNvbHVtbkRlZi5nZXRHcm91cGluZ1ZhbHVlKHJvdy5vcmlnaW5hbCk7XHJcbiAgICAgIHJldHVybiByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xyXG4gICAgfTtcclxuICAgIHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZSA9IHt9O1xyXG4gIH0sXHJcbiAgY3JlYXRlQ2VsbDogKGNlbGwsIGNvbHVtbiwgcm93LCB0YWJsZSkgPT4ge1xyXG4gICAgY2VsbC5nZXRJc0dyb3VwZWQgPSAoKSA9PiBjb2x1bW4uZ2V0SXNHcm91cGVkKCkgJiYgY29sdW1uLmlkID09PSByb3cuZ3JvdXBpbmdDb2x1bW5JZDtcclxuICAgIGNlbGwuZ2V0SXNQbGFjZWhvbGRlciA9ICgpID0+ICFjZWxsLmdldElzR3JvdXBlZCgpICYmIGNvbHVtbi5nZXRJc0dyb3VwZWQoKTtcclxuICAgIGNlbGwuZ2V0SXNBZ2dyZWdhdGVkID0gKCkgPT4ge1xyXG4gICAgICB2YXIgX3JvdyRzdWJSb3dzO1xyXG4gICAgICByZXR1cm4gIWNlbGwuZ2V0SXNHcm91cGVkKCkgJiYgIWNlbGwuZ2V0SXNQbGFjZWhvbGRlcigpICYmICEhKChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MubGVuZ3RoKTtcclxuICAgIH07XHJcbiAgfVxyXG59O1xyXG5mdW5jdGlvbiBvcmRlckNvbHVtbnMobGVhZkNvbHVtbnMsIGdyb3VwaW5nLCBncm91cGVkQ29sdW1uTW9kZSkge1xyXG4gIGlmICghKGdyb3VwaW5nICE9IG51bGwgJiYgZ3JvdXBpbmcubGVuZ3RoKSB8fCAhZ3JvdXBlZENvbHVtbk1vZGUpIHtcclxuICAgIHJldHVybiBsZWFmQ29sdW1ucztcclxuICB9XHJcbiAgY29uc3Qgbm9uR3JvdXBpbmdDb2x1bW5zID0gbGVhZkNvbHVtbnMuZmlsdGVyKGNvbCA9PiAhZ3JvdXBpbmcuaW5jbHVkZXMoY29sLmlkKSk7XHJcbiAgaWYgKGdyb3VwZWRDb2x1bW5Nb2RlID09PSAncmVtb3ZlJykge1xyXG4gICAgcmV0dXJuIG5vbkdyb3VwaW5nQ29sdW1ucztcclxuICB9XHJcbiAgY29uc3QgZ3JvdXBpbmdDb2x1bW5zID0gZ3JvdXBpbmcubWFwKGcgPT4gbGVhZkNvbHVtbnMuZmluZChjb2wgPT4gY29sLmlkID09PSBnKSkuZmlsdGVyKEJvb2xlYW4pO1xyXG4gIHJldHVybiBbLi4uZ3JvdXBpbmdDb2x1bW5zLCAuLi5ub25Hcm91cGluZ0NvbHVtbnNdO1xyXG59XHJcblxyXG4vL1xyXG5cclxuY29uc3QgQ29sdW1uT3JkZXJpbmcgPSB7XHJcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjb2x1bW5PcmRlcjogW10sXHJcbiAgICAgIC4uLnN0YXRlXHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG9uQ29sdW1uT3JkZXJDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2NvbHVtbk9yZGVyJywgdGFibGUpXHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xyXG4gICAgY29sdW1uLmdldEluZGV4ID0gbWVtbyhwb3NpdGlvbiA9PiBbX2dldFZpc2libGVMZWFmQ29sdW1ucyh0YWJsZSwgcG9zaXRpb24pXSwgY29sdW1ucyA9PiBjb2x1bW5zLmZpbmRJbmRleChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCksIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0SW5kZXgnKSk7XHJcbiAgICBjb2x1bW4uZ2V0SXNGaXJzdENvbHVtbiA9IHBvc2l0aW9uID0+IHtcclxuICAgICAgdmFyIF9jb2x1bW5zJDtcclxuICAgICAgY29uc3QgY29sdW1ucyA9IF9nZXRWaXNpYmxlTGVhZkNvbHVtbnModGFibGUsIHBvc2l0aW9uKTtcclxuICAgICAgcmV0dXJuICgoX2NvbHVtbnMkID0gY29sdW1uc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jb2x1bW5zJC5pZCkgPT09IGNvbHVtbi5pZDtcclxuICAgIH07XHJcbiAgICBjb2x1bW4uZ2V0SXNMYXN0Q29sdW1uID0gcG9zaXRpb24gPT4ge1xyXG4gICAgICB2YXIgX2NvbHVtbnM7XHJcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSBfZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKHRhYmxlLCBwb3NpdGlvbik7XHJcbiAgICAgIHJldHVybiAoKF9jb2x1bW5zID0gY29sdW1uc1tjb2x1bW5zLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX2NvbHVtbnMuaWQpID09PSBjb2x1bW4uaWQ7XHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcclxuICAgIHRhYmxlLnNldENvbHVtbk9yZGVyID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uT3JkZXJDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Db2x1bW5PcmRlckNoYW5nZSh1cGRhdGVyKTtcclxuICAgIHRhYmxlLnJlc2V0Q29sdW1uT3JkZXIgPSBkZWZhdWx0U3RhdGUgPT4ge1xyXG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRjO1xyXG4gICAgICB0YWJsZS5zZXRDb2x1bW5PcmRlcihkZWZhdWx0U3RhdGUgPyBbXSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGMgPSB0YWJsZS5pbml0aWFsU3RhdGUuY29sdW1uT3JkZXIpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGMgOiBbXSk7XHJcbiAgICB9O1xyXG4gICAgdGFibGUuX2dldE9yZGVyQ29sdW1uc0ZuID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5PcmRlciwgdGFibGUuZ2V0U3RhdGUoKS5ncm91cGluZywgdGFibGUub3B0aW9ucy5ncm91cGVkQ29sdW1uTW9kZV0sIChjb2x1bW5PcmRlciwgZ3JvdXBpbmcsIGdyb3VwZWRDb2x1bW5Nb2RlKSA9PiBjb2x1bW5zID0+IHtcclxuICAgICAgLy8gU29ydCBncm91cGVkIGNvbHVtbnMgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb2x1bW4gbGlzdFxyXG4gICAgICAvLyBiZWZvcmUgdGhlIGhlYWRlcnMgYXJlIGJ1aWx0XHJcbiAgICAgIGxldCBvcmRlcmVkQ29sdW1ucyA9IFtdO1xyXG5cclxuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gb3JkZXIsIHJldHVybiB0aGUgbm9ybWFsIGNvbHVtbnNcclxuICAgICAgaWYgKCEoY29sdW1uT3JkZXIgIT0gbnVsbCAmJiBjb2x1bW5PcmRlci5sZW5ndGgpKSB7XHJcbiAgICAgICAgb3JkZXJlZENvbHVtbnMgPSBjb2x1bW5zO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGNvbHVtbk9yZGVyQ29weSA9IFsuLi5jb2x1bW5PcmRlcl07XHJcblxyXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIG9yZGVyLCBtYWtlIGEgY29weSBvZiB0aGUgY29sdW1uc1xyXG4gICAgICAgIGNvbnN0IGNvbHVtbnNDb3B5ID0gWy4uLmNvbHVtbnNdO1xyXG5cclxuICAgICAgICAvLyBBbmQgbWFrZSBhIG5ldyBvcmRlcmVkIGFycmF5IG9mIHRoZSBjb2x1bW5zXHJcblxyXG4gICAgICAgIC8vIExvb3Agb3ZlciB0aGUgY29sdW1ucyBhbmQgcGxhY2UgdGhlbSBpbiBvcmRlciBpbnRvIHRoZSBuZXcgYXJyYXlcclxuICAgICAgICB3aGlsZSAoY29sdW1uc0NvcHkubGVuZ3RoICYmIGNvbHVtbk9yZGVyQ29weS5sZW5ndGgpIHtcclxuICAgICAgICAgIGNvbnN0IHRhcmdldENvbHVtbklkID0gY29sdW1uT3JkZXJDb3B5LnNoaWZ0KCk7XHJcbiAgICAgICAgICBjb25zdCBmb3VuZEluZGV4ID0gY29sdW1uc0NvcHkuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gdGFyZ2V0Q29sdW1uSWQpO1xyXG4gICAgICAgICAgaWYgKGZvdW5kSW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICBvcmRlcmVkQ29sdW1ucy5wdXNoKGNvbHVtbnNDb3B5LnNwbGljZShmb3VuZEluZGV4LCAxKVswXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYW55IGNvbHVtbnMgbGVmdCwgYWRkIHRoZW0gdG8gdGhlIGVuZFxyXG4gICAgICAgIG9yZGVyZWRDb2x1bW5zID0gWy4uLm9yZGVyZWRDb2x1bW5zLCAuLi5jb2x1bW5zQ29weV07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG9yZGVyQ29sdW1ucyhvcmRlcmVkQ29sdW1ucywgZ3JvdXBpbmcsIGdyb3VwZWRDb2x1bW5Nb2RlKTtcclxuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ19nZXRPcmRlckNvbHVtbnNGbicpKTtcclxuICB9XHJcbn07XHJcblxyXG4vL1xyXG5cclxuY29uc3QgZ2V0RGVmYXVsdENvbHVtblBpbm5pbmdTdGF0ZSA9ICgpID0+ICh7XHJcbiAgbGVmdDogW10sXHJcbiAgcmlnaHQ6IFtdXHJcbn0pO1xyXG5jb25zdCBDb2x1bW5QaW5uaW5nID0ge1xyXG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY29sdW1uUGlubmluZzogZ2V0RGVmYXVsdENvbHVtblBpbm5pbmdTdGF0ZSgpLFxyXG4gICAgICAuLi5zdGF0ZVxyXG4gICAgfTtcclxuICB9LFxyXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBvbkNvbHVtblBpbm5pbmdDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2NvbHVtblBpbm5pbmcnLCB0YWJsZSlcclxuICAgIH07XHJcbiAgfSxcclxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XHJcbiAgICBjb2x1bW4ucGluID0gcG9zaXRpb24gPT4ge1xyXG4gICAgICBjb25zdCBjb2x1bW5JZHMgPSBjb2x1bW4uZ2V0TGVhZkNvbHVtbnMoKS5tYXAoZCA9PiBkLmlkKS5maWx0ZXIoQm9vbGVhbik7XHJcbiAgICAgIHRhYmxlLnNldENvbHVtblBpbm5pbmcob2xkID0+IHtcclxuICAgICAgICB2YXIgX29sZCRsZWZ0MywgX29sZCRyaWdodDM7XHJcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XHJcbiAgICAgICAgICB2YXIgX29sZCRsZWZ0LCBfb2xkJHJpZ2h0O1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbGVmdDogKChfb2xkJGxlZnQgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5sZWZ0KSAhPSBudWxsID8gX29sZCRsZWZ0IDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSksXHJcbiAgICAgICAgICAgIHJpZ2h0OiBbLi4uKChfb2xkJHJpZ2h0ID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQucmlnaHQpICE9IG51bGwgPyBfb2xkJHJpZ2h0IDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSksIC4uLmNvbHVtbklkc11cclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgICB2YXIgX29sZCRsZWZ0MiwgX29sZCRyaWdodDI7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsZWZ0OiBbLi4uKChfb2xkJGxlZnQyID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQubGVmdCkgIT0gbnVsbCA/IF9vbGQkbGVmdDIgOiBbXSkuZmlsdGVyKGQgPT4gIShjb2x1bW5JZHMgIT0gbnVsbCAmJiBjb2x1bW5JZHMuaW5jbHVkZXMoZCkpKSwgLi4uY29sdW1uSWRzXSxcclxuICAgICAgICAgICAgcmlnaHQ6ICgoX29sZCRyaWdodDIgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5yaWdodCkgIT0gbnVsbCA/IF9vbGQkcmlnaHQyIDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSlcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBsZWZ0OiAoKF9vbGQkbGVmdDMgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5sZWZ0KSAhPSBudWxsID8gX29sZCRsZWZ0MyA6IFtdKS5maWx0ZXIoZCA9PiAhKGNvbHVtbklkcyAhPSBudWxsICYmIGNvbHVtbklkcy5pbmNsdWRlcyhkKSkpLFxyXG4gICAgICAgICAgcmlnaHQ6ICgoX29sZCRyaWdodDMgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5yaWdodCkgIT0gbnVsbCA/IF9vbGQkcmlnaHQzIDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSlcclxuICAgICAgICB9O1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgICBjb2x1bW4uZ2V0Q2FuUGluID0gKCkgPT4ge1xyXG4gICAgICBjb25zdCBsZWFmQ29sdW1ucyA9IGNvbHVtbi5nZXRMZWFmQ29sdW1ucygpO1xyXG4gICAgICByZXR1cm4gbGVhZkNvbHVtbnMuc29tZShkID0+IHtcclxuICAgICAgICB2YXIgX2QkY29sdW1uRGVmJGVuYWJsZVBpLCBfcmVmLCBfdGFibGUkb3B0aW9ucyRlbmFibGU7XHJcbiAgICAgICAgcmV0dXJuICgoX2QkY29sdW1uRGVmJGVuYWJsZVBpID0gZC5jb2x1bW5EZWYuZW5hYmxlUGlubmluZykgIT0gbnVsbCA/IF9kJGNvbHVtbkRlZiRlbmFibGVQaSA6IHRydWUpICYmICgoX3JlZiA9IChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUNvbHVtblBpbm5pbmcpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUgOiB0YWJsZS5vcHRpb25zLmVuYWJsZVBpbm5pbmcpICE9IG51bGwgPyBfcmVmIDogdHJ1ZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIGNvbHVtbi5nZXRJc1Bpbm5lZCA9ICgpID0+IHtcclxuICAgICAgY29uc3QgbGVhZkNvbHVtbklkcyA9IGNvbHVtbi5nZXRMZWFmQ29sdW1ucygpLm1hcChkID0+IGQuaWQpO1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgbGVmdCxcclxuICAgICAgICByaWdodFxyXG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nO1xyXG4gICAgICBjb25zdCBpc0xlZnQgPSBsZWFmQ29sdW1uSWRzLnNvbWUoZCA9PiBsZWZ0ID09IG51bGwgPyB2b2lkIDAgOiBsZWZ0LmluY2x1ZGVzKGQpKTtcclxuICAgICAgY29uc3QgaXNSaWdodCA9IGxlYWZDb2x1bW5JZHMuc29tZShkID0+IHJpZ2h0ID09IG51bGwgPyB2b2lkIDAgOiByaWdodC5pbmNsdWRlcyhkKSk7XHJcbiAgICAgIHJldHVybiBpc0xlZnQgPyAnbGVmdCcgOiBpc1JpZ2h0ID8gJ3JpZ2h0JyA6IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIGNvbHVtbi5nZXRQaW5uZWRJbmRleCA9ICgpID0+IHtcclxuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRjb2x1bSwgX3RhYmxlJGdldFN0YXRlJGNvbHVtMjtcclxuICAgICAgY29uc3QgcG9zaXRpb24gPSBjb2x1bW4uZ2V0SXNQaW5uZWQoKTtcclxuICAgICAgcmV0dXJuIHBvc2l0aW9uID8gKF90YWJsZSRnZXRTdGF0ZSRjb2x1bSA9IChfdGFibGUkZ2V0U3RhdGUkY29sdW0yID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nKSA9PSBudWxsIHx8IChfdGFibGUkZ2V0U3RhdGUkY29sdW0yID0gX3RhYmxlJGdldFN0YXRlJGNvbHVtMltwb3NpdGlvbl0pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkY29sdW0yLmluZGV4T2YoY29sdW1uLmlkKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRTdGF0ZSRjb2x1bSA6IC0xIDogMDtcclxuICAgIH07XHJcbiAgfSxcclxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XHJcbiAgICByb3cuZ2V0Q2VudGVyVmlzaWJsZUNlbGxzID0gbWVtbygoKSA9PiBbcm93Ll9nZXRBbGxWaXNpYmxlQ2VsbHMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnQsIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sIChhbGxDZWxscywgbGVmdCwgcmlnaHQpID0+IHtcclxuICAgICAgY29uc3QgbGVmdEFuZFJpZ2h0ID0gWy4uLihsZWZ0ICE9IG51bGwgPyBsZWZ0IDogW10pLCAuLi4ocmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogW10pXTtcclxuICAgICAgcmV0dXJuIGFsbENlbGxzLmZpbHRlcihkID0+ICFsZWZ0QW5kUmlnaHQuaW5jbHVkZXMoZC5jb2x1bW4uaWQpKTtcclxuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnZ2V0Q2VudGVyVmlzaWJsZUNlbGxzJykpO1xyXG4gICAgcm93LmdldExlZnRWaXNpYmxlQ2VsbHMgPSBtZW1vKCgpID0+IFtyb3cuX2dldEFsbFZpc2libGVDZWxscygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdF0sIChhbGxDZWxscywgbGVmdCkgPT4ge1xyXG4gICAgICBjb25zdCBjZWxscyA9IChsZWZ0ICE9IG51bGwgPyBsZWZ0IDogW10pLm1hcChjb2x1bW5JZCA9PiBhbGxDZWxscy5maW5kKGNlbGwgPT4gY2VsbC5jb2x1bW4uaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pLm1hcChkID0+ICh7XHJcbiAgICAgICAgLi4uZCxcclxuICAgICAgICBwb3NpdGlvbjogJ2xlZnQnXHJcbiAgICAgIH0pKTtcclxuICAgICAgcmV0dXJuIGNlbGxzO1xyXG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRMZWZ0VmlzaWJsZUNlbGxzJykpO1xyXG4gICAgcm93LmdldFJpZ2h0VmlzaWJsZUNlbGxzID0gbWVtbygoKSA9PiBbcm93Ll9nZXRBbGxWaXNpYmxlQ2VsbHMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKGFsbENlbGxzLCByaWdodCkgPT4ge1xyXG4gICAgICBjb25zdCBjZWxscyA9IChyaWdodCAhPSBudWxsID8gcmlnaHQgOiBbXSkubWFwKGNvbHVtbklkID0+IGFsbENlbGxzLmZpbmQoY2VsbCA9PiBjZWxsLmNvbHVtbi5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbikubWFwKGQgPT4gKHtcclxuICAgICAgICAuLi5kLFxyXG4gICAgICAgIHBvc2l0aW9uOiAncmlnaHQnXHJcbiAgICAgIH0pKTtcclxuICAgICAgcmV0dXJuIGNlbGxzO1xyXG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRSaWdodFZpc2libGVDZWxscycpKTtcclxuICB9LFxyXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XHJcbiAgICB0YWJsZS5zZXRDb2x1bW5QaW5uaW5nID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uUGlubmluZ0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vbkNvbHVtblBpbm5pbmdDaGFuZ2UodXBkYXRlcik7XHJcbiAgICB0YWJsZS5yZXNldENvbHVtblBpbm5pbmcgPSBkZWZhdWx0U3RhdGUgPT4ge1xyXG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRjLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xyXG4gICAgICByZXR1cm4gdGFibGUuc2V0Q29sdW1uUGlubmluZyhkZWZhdWx0U3RhdGUgPyBnZXREZWZhdWx0Q29sdW1uUGlubmluZ1N0YXRlKCkgOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRjID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLmNvbHVtblBpbm5pbmcpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGMgOiBnZXREZWZhdWx0Q29sdW1uUGlubmluZ1N0YXRlKCkpO1xyXG4gICAgfTtcclxuICAgIHRhYmxlLmdldElzU29tZUNvbHVtbnNQaW5uZWQgPSBwb3NpdGlvbiA9PiB7XHJcbiAgICAgIHZhciBfcGlubmluZ1N0YXRlJHBvc2l0aW87XHJcbiAgICAgIGNvbnN0IHBpbm5pbmdTdGF0ZSA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZztcclxuICAgICAgaWYgKCFwb3NpdGlvbikge1xyXG4gICAgICAgIHZhciBfcGlubmluZ1N0YXRlJGxlZnQsIF9waW5uaW5nU3RhdGUkcmlnaHQ7XHJcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKChfcGlubmluZ1N0YXRlJGxlZnQgPSBwaW5uaW5nU3RhdGUubGVmdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkbGVmdC5sZW5ndGgpIHx8ICgoX3Bpbm5pbmdTdGF0ZSRyaWdodCA9IHBpbm5pbmdTdGF0ZS5yaWdodCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkcmlnaHQubGVuZ3RoKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIEJvb2xlYW4oKF9waW5uaW5nU3RhdGUkcG9zaXRpbyA9IHBpbm5pbmdTdGF0ZVtwb3NpdGlvbl0pID09IG51bGwgPyB2b2lkIDAgOiBfcGlubmluZ1N0YXRlJHBvc2l0aW8ubGVuZ3RoKTtcclxuICAgIH07XHJcbiAgICB0YWJsZS5nZXRMZWZ0TGVhZkNvbHVtbnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdF0sIChhbGxDb2x1bW5zLCBsZWZ0KSA9PiB7XHJcbiAgICAgIHJldHVybiAobGVmdCAhPSBudWxsID8gbGVmdCA6IFtdKS5tYXAoY29sdW1uSWQgPT4gYWxsQ29sdW1ucy5maW5kKGNvbHVtbiA9PiBjb2x1bW4uaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pO1xyXG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRMZWZ0TGVhZkNvbHVtbnMnKSk7XHJcbiAgICB0YWJsZS5nZXRSaWdodExlYWZDb2x1bW5zID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKGFsbENvbHVtbnMsIHJpZ2h0KSA9PiB7XHJcbiAgICAgIHJldHVybiAocmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogW10pLm1hcChjb2x1bW5JZCA9PiBhbGxDb2x1bW5zLmZpbmQoY29sdW1uID0+IGNvbHVtbi5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbik7XHJcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2dldFJpZ2h0TGVhZkNvbHVtbnMnKSk7XHJcbiAgICB0YWJsZS5nZXRDZW50ZXJMZWFmQ29sdW1ucyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbExlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0LCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgbGVmdCwgcmlnaHQpID0+IHtcclxuICAgICAgY29uc3QgbGVmdEFuZFJpZ2h0ID0gWy4uLihsZWZ0ICE9IG51bGwgPyBsZWZ0IDogW10pLCAuLi4ocmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogW10pXTtcclxuICAgICAgcmV0dXJuIGFsbENvbHVtbnMuZmlsdGVyKGQgPT4gIWxlZnRBbmRSaWdodC5pbmNsdWRlcyhkLmlkKSk7XHJcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2dldENlbnRlckxlYWZDb2x1bW5zJykpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vXHJcblxyXG4vL1xyXG5cclxuY29uc3QgZGVmYXVsdENvbHVtblNpemluZyA9IHtcclxuICBzaXplOiAxNTAsXHJcbiAgbWluU2l6ZTogMjAsXHJcbiAgbWF4U2l6ZTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcclxufTtcclxuY29uc3QgZ2V0RGVmYXVsdENvbHVtblNpemluZ0luZm9TdGF0ZSA9ICgpID0+ICh7XHJcbiAgc3RhcnRPZmZzZXQ6IG51bGwsXHJcbiAgc3RhcnRTaXplOiBudWxsLFxyXG4gIGRlbHRhT2Zmc2V0OiBudWxsLFxyXG4gIGRlbHRhUGVyY2VudGFnZTogbnVsbCxcclxuICBpc1Jlc2l6aW5nQ29sdW1uOiBmYWxzZSxcclxuICBjb2x1bW5TaXppbmdTdGFydDogW11cclxufSk7XHJcbmNvbnN0IENvbHVtblNpemluZyA9IHtcclxuICBnZXREZWZhdWx0Q29sdW1uRGVmOiAoKSA9PiB7XHJcbiAgICByZXR1cm4gZGVmYXVsdENvbHVtblNpemluZztcclxuICB9LFxyXG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY29sdW1uU2l6aW5nOiB7fSxcclxuICAgICAgY29sdW1uU2l6aW5nSW5mbzogZ2V0RGVmYXVsdENvbHVtblNpemluZ0luZm9TdGF0ZSgpLFxyXG4gICAgICAuLi5zdGF0ZVxyXG4gICAgfTtcclxuICB9LFxyXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjb2x1bW5SZXNpemVNb2RlOiAnb25FbmQnLFxyXG4gICAgICBjb2x1bW5SZXNpemVEaXJlY3Rpb246ICdsdHInLFxyXG4gICAgICBvbkNvbHVtblNpemluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uU2l6aW5nJywgdGFibGUpLFxyXG4gICAgICBvbkNvbHVtblNpemluZ0luZm9DaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2NvbHVtblNpemluZ0luZm8nLCB0YWJsZSlcclxuICAgIH07XHJcbiAgfSxcclxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XHJcbiAgICBjb2x1bW4uZ2V0U2l6ZSA9ICgpID0+IHtcclxuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uRGVmJG1pbiwgX3JlZiwgX2NvbHVtbiRjb2x1bW5EZWYkbWF4O1xyXG4gICAgICBjb25zdCBjb2x1bW5TaXplID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5TaXppbmdbY29sdW1uLmlkXTtcclxuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KChfY29sdW1uJGNvbHVtbkRlZiRtaW4gPSBjb2x1bW4uY29sdW1uRGVmLm1pblNpemUpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRtaW4gOiBkZWZhdWx0Q29sdW1uU2l6aW5nLm1pblNpemUsIChfcmVmID0gY29sdW1uU2l6ZSAhPSBudWxsID8gY29sdW1uU2l6ZSA6IGNvbHVtbi5jb2x1bW5EZWYuc2l6ZSkgIT0gbnVsbCA/IF9yZWYgOiBkZWZhdWx0Q29sdW1uU2l6aW5nLnNpemUpLCAoX2NvbHVtbiRjb2x1bW5EZWYkbWF4ID0gY29sdW1uLmNvbHVtbkRlZi5tYXhTaXplKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkbWF4IDogZGVmYXVsdENvbHVtblNpemluZy5tYXhTaXplKTtcclxuICAgIH07XHJcbiAgICBjb2x1bW4uZ2V0U3RhcnQgPSBtZW1vKHBvc2l0aW9uID0+IFtwb3NpdGlvbiwgX2dldFZpc2libGVMZWFmQ29sdW1ucyh0YWJsZSwgcG9zaXRpb24pLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblNpemluZ10sIChwb3NpdGlvbiwgY29sdW1ucykgPT4gY29sdW1ucy5zbGljZSgwLCBjb2x1bW4uZ2V0SW5kZXgocG9zaXRpb24pKS5yZWR1Y2UoKHN1bSwgY29sdW1uKSA9PiBzdW0gKyBjb2x1bW4uZ2V0U2l6ZSgpLCAwKSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRTdGFydCcpKTtcclxuICAgIGNvbHVtbi5nZXRBZnRlciA9IG1lbW8ocG9zaXRpb24gPT4gW3Bvc2l0aW9uLCBfZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKHRhYmxlLCBwb3NpdGlvbiksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uU2l6aW5nXSwgKHBvc2l0aW9uLCBjb2x1bW5zKSA9PiBjb2x1bW5zLnNsaWNlKGNvbHVtbi5nZXRJbmRleChwb3NpdGlvbikgKyAxKS5yZWR1Y2UoKHN1bSwgY29sdW1uKSA9PiBzdW0gKyBjb2x1bW4uZ2V0U2l6ZSgpLCAwKSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRBZnRlcicpKTtcclxuICAgIGNvbHVtbi5yZXNldFNpemUgPSAoKSA9PiB7XHJcbiAgICAgIHRhYmxlLnNldENvbHVtblNpemluZyhfcmVmMiA9PiB7XHJcbiAgICAgICAgbGV0IHtcclxuICAgICAgICAgIFtjb2x1bW4uaWRdOiBfLFxyXG4gICAgICAgICAgLi4ucmVzdFxyXG4gICAgICAgIH0gPSBfcmVmMjtcclxuICAgICAgICByZXR1cm4gcmVzdDtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgY29sdW1uLmdldENhblJlc2l6ZSA9ICgpID0+IHtcclxuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uRGVmJGVuYSwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlO1xyXG4gICAgICByZXR1cm4gKChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZVJlc2l6aW5nKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUNvbHVtblJlc2l6aW5nKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgY29sdW1uLmdldElzUmVzaXppbmcgPSAoKSA9PiB7XHJcbiAgICAgIHJldHVybiB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblNpemluZ0luZm8uaXNSZXNpemluZ0NvbHVtbiA9PT0gY29sdW1uLmlkO1xyXG4gICAgfTtcclxuICB9LFxyXG4gIGNyZWF0ZUhlYWRlcjogKGhlYWRlciwgdGFibGUpID0+IHtcclxuICAgIGhlYWRlci5nZXRTaXplID0gKCkgPT4ge1xyXG4gICAgICBsZXQgc3VtID0gMDtcclxuICAgICAgY29uc3QgcmVjdXJzZSA9IGhlYWRlciA9PiB7XHJcbiAgICAgICAgaWYgKGhlYWRlci5zdWJIZWFkZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgaGVhZGVyLnN1YkhlYWRlcnMuZm9yRWFjaChyZWN1cnNlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFyIF9oZWFkZXIkY29sdW1uJGdldFNpejtcclxuICAgICAgICAgIHN1bSArPSAoX2hlYWRlciRjb2x1bW4kZ2V0U2l6ID0gaGVhZGVyLmNvbHVtbi5nZXRTaXplKCkpICE9IG51bGwgPyBfaGVhZGVyJGNvbHVtbiRnZXRTaXogOiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgcmVjdXJzZShoZWFkZXIpO1xyXG4gICAgICByZXR1cm4gc3VtO1xyXG4gICAgfTtcclxuICAgIGhlYWRlci5nZXRTdGFydCA9ICgpID0+IHtcclxuICAgICAgaWYgKGhlYWRlci5pbmRleCA+IDApIHtcclxuICAgICAgICBjb25zdCBwcmV2U2libGluZ0hlYWRlciA9IGhlYWRlci5oZWFkZXJHcm91cC5oZWFkZXJzW2hlYWRlci5pbmRleCAtIDFdO1xyXG4gICAgICAgIHJldHVybiBwcmV2U2libGluZ0hlYWRlci5nZXRTdGFydCgpICsgcHJldlNpYmxpbmdIZWFkZXIuZ2V0U2l6ZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfTtcclxuICAgIGhlYWRlci5nZXRSZXNpemVIYW5kbGVyID0gX2NvbnRleHREb2N1bWVudCA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihoZWFkZXIuY29sdW1uLmlkKTtcclxuICAgICAgY29uc3QgY2FuUmVzaXplID0gY29sdW1uID09IG51bGwgPyB2b2lkIDAgOiBjb2x1bW4uZ2V0Q2FuUmVzaXplKCk7XHJcbiAgICAgIHJldHVybiBlID0+IHtcclxuICAgICAgICBpZiAoIWNvbHVtbiB8fCAhY2FuUmVzaXplKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGUucGVyc2lzdCA9PSBudWxsIHx8IGUucGVyc2lzdCgpO1xyXG4gICAgICAgIGlmIChpc1RvdWNoU3RhcnRFdmVudChlKSkge1xyXG4gICAgICAgICAgLy8gbGV0cyBub3QgcmVzcG9uZCB0byBtdWx0aXBsZSB0b3VjaGVzIChlLmcuIDIgb3IgMyBmaW5nZXJzKVxyXG4gICAgICAgICAgaWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN0YXJ0U2l6ZSA9IGhlYWRlci5nZXRTaXplKCk7XHJcbiAgICAgICAgY29uc3QgY29sdW1uU2l6aW5nU3RhcnQgPSBoZWFkZXIgPyBoZWFkZXIuZ2V0TGVhZkhlYWRlcnMoKS5tYXAoZCA9PiBbZC5jb2x1bW4uaWQsIGQuY29sdW1uLmdldFNpemUoKV0pIDogW1tjb2x1bW4uaWQsIGNvbHVtbi5nZXRTaXplKCldXTtcclxuICAgICAgICBjb25zdCBjbGllbnRYID0gaXNUb3VjaFN0YXJ0RXZlbnQoZSkgPyBNYXRoLnJvdW5kKGUudG91Y2hlc1swXS5jbGllbnRYKSA6IGUuY2xpZW50WDtcclxuICAgICAgICBjb25zdCBuZXdDb2x1bW5TaXppbmcgPSB7fTtcclxuICAgICAgICBjb25zdCB1cGRhdGVPZmZzZXQgPSAoZXZlbnRUeXBlLCBjbGllbnRYUG9zKSA9PiB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIGNsaWVudFhQb3MgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRhYmxlLnNldENvbHVtblNpemluZ0luZm8ob2xkID0+IHtcclxuICAgICAgICAgICAgdmFyIF9vbGQkc3RhcnRPZmZzZXQsIF9vbGQkc3RhcnRTaXplO1xyXG4gICAgICAgICAgICBjb25zdCBkZWx0YURpcmVjdGlvbiA9IHRhYmxlLm9wdGlvbnMuY29sdW1uUmVzaXplRGlyZWN0aW9uID09PSAncnRsJyA/IC0xIDogMTtcclxuICAgICAgICAgICAgY29uc3QgZGVsdGFPZmZzZXQgPSAoY2xpZW50WFBvcyAtICgoX29sZCRzdGFydE9mZnNldCA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnN0YXJ0T2Zmc2V0KSAhPSBudWxsID8gX29sZCRzdGFydE9mZnNldCA6IDApKSAqIGRlbHRhRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICBjb25zdCBkZWx0YVBlcmNlbnRhZ2UgPSBNYXRoLm1heChkZWx0YU9mZnNldCAvICgoX29sZCRzdGFydFNpemUgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5zdGFydFNpemUpICE9IG51bGwgPyBfb2xkJHN0YXJ0U2l6ZSA6IDApLCAtMC45OTk5OTkpO1xyXG4gICAgICAgICAgICBvbGQuY29sdW1uU2l6aW5nU3RhcnQuZm9yRWFjaChfcmVmMyA9PiB7XHJcbiAgICAgICAgICAgICAgbGV0IFtjb2x1bW5JZCwgaGVhZGVyU2l6ZV0gPSBfcmVmMztcclxuICAgICAgICAgICAgICBuZXdDb2x1bW5TaXppbmdbY29sdW1uSWRdID0gTWF0aC5yb3VuZChNYXRoLm1heChoZWFkZXJTaXplICsgaGVhZGVyU2l6ZSAqIGRlbHRhUGVyY2VudGFnZSwgMCkgKiAxMDApIC8gMTAwO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAuLi5vbGQsXHJcbiAgICAgICAgICAgICAgZGVsdGFPZmZzZXQsXHJcbiAgICAgICAgICAgICAgZGVsdGFQZXJjZW50YWdlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGlmICh0YWJsZS5vcHRpb25zLmNvbHVtblJlc2l6ZU1vZGUgPT09ICdvbkNoYW5nZScgfHwgZXZlbnRUeXBlID09PSAnZW5kJykge1xyXG4gICAgICAgICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmcob2xkID0+ICh7XHJcbiAgICAgICAgICAgICAgLi4ub2xkLFxyXG4gICAgICAgICAgICAgIC4uLm5ld0NvbHVtblNpemluZ1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBvbk1vdmUgPSBjbGllbnRYUG9zID0+IHVwZGF0ZU9mZnNldCgnbW92ZScsIGNsaWVudFhQb3MpO1xyXG4gICAgICAgIGNvbnN0IG9uRW5kID0gY2xpZW50WFBvcyA9PiB7XHJcbiAgICAgICAgICB1cGRhdGVPZmZzZXQoJ2VuZCcsIGNsaWVudFhQb3MpO1xyXG4gICAgICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nSW5mbyhvbGQgPT4gKHtcclxuICAgICAgICAgICAgLi4ub2xkLFxyXG4gICAgICAgICAgICBpc1Jlc2l6aW5nQ29sdW1uOiBmYWxzZSxcclxuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IG51bGwsXHJcbiAgICAgICAgICAgIHN0YXJ0U2l6ZTogbnVsbCxcclxuICAgICAgICAgICAgZGVsdGFPZmZzZXQ6IG51bGwsXHJcbiAgICAgICAgICAgIGRlbHRhUGVyY2VudGFnZTogbnVsbCxcclxuICAgICAgICAgICAgY29sdW1uU2l6aW5nU3RhcnQ6IFtdXHJcbiAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBjb250ZXh0RG9jdW1lbnQgPSBfY29udGV4dERvY3VtZW50IHx8IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IG51bGw7XHJcbiAgICAgICAgY29uc3QgbW91c2VFdmVudHMgPSB7XHJcbiAgICAgICAgICBtb3ZlSGFuZGxlcjogZSA9PiBvbk1vdmUoZS5jbGllbnRYKSxcclxuICAgICAgICAgIHVwSGFuZGxlcjogZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnRleHREb2N1bWVudCA9PSBudWxsIHx8IGNvbnRleHREb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3VzZUV2ZW50cy5tb3ZlSGFuZGxlcik7XHJcbiAgICAgICAgICAgIGNvbnRleHREb2N1bWVudCA9PSBudWxsIHx8IGNvbnRleHREb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2VFdmVudHMudXBIYW5kbGVyKTtcclxuICAgICAgICAgICAgb25FbmQoZS5jbGllbnRYKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHRvdWNoRXZlbnRzID0ge1xyXG4gICAgICAgICAgbW92ZUhhbmRsZXI6IGUgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZS5jYW5jZWxhYmxlKSB7XHJcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb25Nb3ZlKGUudG91Y2hlc1swXS5jbGllbnRYKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHVwSGFuZGxlcjogZSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfZSR0b3VjaGVzJDtcclxuICAgICAgICAgICAgY29udGV4dERvY3VtZW50ID09IG51bGwgfHwgY29udGV4dERvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNoRXZlbnRzLm1vdmVIYW5kbGVyKTtcclxuICAgICAgICAgICAgY29udGV4dERvY3VtZW50ID09IG51bGwgfHwgY29udGV4dERvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hFdmVudHMudXBIYW5kbGVyKTtcclxuICAgICAgICAgICAgaWYgKGUuY2FuY2VsYWJsZSkge1xyXG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9uRW5kKChfZSR0b3VjaGVzJCA9IGUudG91Y2hlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lJHRvdWNoZXMkLmNsaWVudFgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcGFzc2l2ZUlmU3VwcG9ydGVkID0gcGFzc2l2ZUV2ZW50U3VwcG9ydGVkKCkgPyB7XHJcbiAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxyXG4gICAgICAgIH0gOiBmYWxzZTtcclxuICAgICAgICBpZiAoaXNUb3VjaFN0YXJ0RXZlbnQoZSkpIHtcclxuICAgICAgICAgIGNvbnRleHREb2N1bWVudCA9PSBudWxsIHx8IGNvbnRleHREb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0b3VjaEV2ZW50cy5tb3ZlSGFuZGxlciwgcGFzc2l2ZUlmU3VwcG9ydGVkKTtcclxuICAgICAgICAgIGNvbnRleHREb2N1bWVudCA9PSBudWxsIHx8IGNvbnRleHREb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoRXZlbnRzLnVwSGFuZGxlciwgcGFzc2l2ZUlmU3VwcG9ydGVkKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29udGV4dERvY3VtZW50ID09IG51bGwgfHwgY29udGV4dERvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdXNlRXZlbnRzLm1vdmVIYW5kbGVyLCBwYXNzaXZlSWZTdXBwb3J0ZWQpO1xyXG4gICAgICAgICAgY29udGV4dERvY3VtZW50ID09IG51bGwgfHwgY29udGV4dERvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtb3VzZUV2ZW50cy51cEhhbmRsZXIsIHBhc3NpdmVJZlN1cHBvcnRlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRhYmxlLnNldENvbHVtblNpemluZ0luZm8ob2xkID0+ICh7XHJcbiAgICAgICAgICAuLi5vbGQsXHJcbiAgICAgICAgICBzdGFydE9mZnNldDogY2xpZW50WCxcclxuICAgICAgICAgIHN0YXJ0U2l6ZSxcclxuICAgICAgICAgIGRlbHRhT2Zmc2V0OiAwLFxyXG4gICAgICAgICAgZGVsdGFQZXJjZW50YWdlOiAwLFxyXG4gICAgICAgICAgY29sdW1uU2l6aW5nU3RhcnQsXHJcbiAgICAgICAgICBpc1Jlc2l6aW5nQ29sdW1uOiBjb2x1bW4uaWRcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcclxuICAgIHRhYmxlLnNldENvbHVtblNpemluZyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkNvbHVtblNpemluZ0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vbkNvbHVtblNpemluZ0NoYW5nZSh1cGRhdGVyKTtcclxuICAgIHRhYmxlLnNldENvbHVtblNpemluZ0luZm8gPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Db2x1bW5TaXppbmdJbmZvQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uU2l6aW5nSW5mb0NoYW5nZSh1cGRhdGVyKTtcclxuICAgIHRhYmxlLnJlc2V0Q29sdW1uU2l6aW5nID0gZGVmYXVsdFN0YXRlID0+IHtcclxuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYztcclxuICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nKGRlZmF1bHRTdGF0ZSA/IHt9IDogKF90YWJsZSRpbml0aWFsU3RhdGUkYyA9IHRhYmxlLmluaXRpYWxTdGF0ZS5jb2x1bW5TaXppbmcpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGMgOiB7fSk7XHJcbiAgICB9O1xyXG4gICAgdGFibGUucmVzZXRIZWFkZXJTaXplSW5mbyA9IGRlZmF1bHRTdGF0ZSA9PiB7XHJcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGMyO1xyXG4gICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmdJbmZvKGRlZmF1bHRTdGF0ZSA/IGdldERlZmF1bHRDb2x1bW5TaXppbmdJbmZvU3RhdGUoKSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGMyID0gdGFibGUuaW5pdGlhbFN0YXRlLmNvbHVtblNpemluZ0luZm8pICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGMyIDogZ2V0RGVmYXVsdENvbHVtblNpemluZ0luZm9TdGF0ZSgpKTtcclxuICAgIH07XHJcbiAgICB0YWJsZS5nZXRUb3RhbFNpemUgPSAoKSA9PiB7XHJcbiAgICAgIHZhciBfdGFibGUkZ2V0SGVhZGVyR3JvdXAsIF90YWJsZSRnZXRIZWFkZXJHcm91cDI7XHJcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldEhlYWRlckdyb3VwID0gKF90YWJsZSRnZXRIZWFkZXJHcm91cDIgPSB0YWJsZS5nZXRIZWFkZXJHcm91cHMoKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRIZWFkZXJHcm91cDIuaGVhZGVycy5yZWR1Y2UoKHN1bSwgaGVhZGVyKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHN1bSArIGhlYWRlci5nZXRTaXplKCk7XHJcbiAgICAgIH0sIDApKSAhPSBudWxsID8gX3RhYmxlJGdldEhlYWRlckdyb3VwIDogMDtcclxuICAgIH07XHJcbiAgICB0YWJsZS5nZXRMZWZ0VG90YWxTaXplID0gKCkgPT4ge1xyXG4gICAgICB2YXIgX3RhYmxlJGdldExlZnRIZWFkZXJHLCBfdGFibGUkZ2V0TGVmdEhlYWRlckcyO1xyXG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRMZWZ0SGVhZGVyRyA9IChfdGFibGUkZ2V0TGVmdEhlYWRlckcyID0gdGFibGUuZ2V0TGVmdEhlYWRlckdyb3VwcygpWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldExlZnRIZWFkZXJHMi5oZWFkZXJzLnJlZHVjZSgoc3VtLCBoZWFkZXIpID0+IHtcclxuICAgICAgICByZXR1cm4gc3VtICsgaGVhZGVyLmdldFNpemUoKTtcclxuICAgICAgfSwgMCkpICE9IG51bGwgPyBfdGFibGUkZ2V0TGVmdEhlYWRlckcgOiAwO1xyXG4gICAgfTtcclxuICAgIHRhYmxlLmdldENlbnRlclRvdGFsU2l6ZSA9ICgpID0+IHtcclxuICAgICAgdmFyIF90YWJsZSRnZXRDZW50ZXJIZWFkZSwgX3RhYmxlJGdldENlbnRlckhlYWRlMjtcclxuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0Q2VudGVySGVhZGUgPSAoX3RhYmxlJGdldENlbnRlckhlYWRlMiA9IHRhYmxlLmdldENlbnRlckhlYWRlckdyb3VwcygpWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldENlbnRlckhlYWRlMi5oZWFkZXJzLnJlZHVjZSgoc3VtLCBoZWFkZXIpID0+IHtcclxuICAgICAgICByZXR1cm4gc3VtICsgaGVhZGVyLmdldFNpemUoKTtcclxuICAgICAgfSwgMCkpICE9IG51bGwgPyBfdGFibGUkZ2V0Q2VudGVySGVhZGUgOiAwO1xyXG4gICAgfTtcclxuICAgIHRhYmxlLmdldFJpZ2h0VG90YWxTaXplID0gKCkgPT4ge1xyXG4gICAgICB2YXIgX3RhYmxlJGdldFJpZ2h0SGVhZGVyLCBfdGFibGUkZ2V0UmlnaHRIZWFkZXIyO1xyXG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRSaWdodEhlYWRlciA9IChfdGFibGUkZ2V0UmlnaHRIZWFkZXIyID0gdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMoKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRSaWdodEhlYWRlcjIuaGVhZGVycy5yZWR1Y2UoKHN1bSwgaGVhZGVyKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHN1bSArIGhlYWRlci5nZXRTaXplKCk7XHJcbiAgICAgIH0sIDApKSAhPSBudWxsID8gX3RhYmxlJGdldFJpZ2h0SGVhZGVyIDogMDtcclxuICAgIH07XHJcbiAgfVxyXG59O1xyXG5sZXQgcGFzc2l2ZVN1cHBvcnRlZCA9IG51bGw7XHJcbmZ1bmN0aW9uIHBhc3NpdmVFdmVudFN1cHBvcnRlZCgpIHtcclxuICBpZiAodHlwZW9mIHBhc3NpdmVTdXBwb3J0ZWQgPT09ICdib29sZWFuJykgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWQ7XHJcbiAgbGV0IHN1cHBvcnRlZCA9IGZhbHNlO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICBnZXQgcGFzc2l2ZSgpIHtcclxuICAgICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0Jywgbm9vcCwgb3B0aW9ucyk7XHJcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG5vb3ApO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgc3VwcG9ydGVkID0gZmFsc2U7XHJcbiAgfVxyXG4gIHBhc3NpdmVTdXBwb3J0ZWQgPSBzdXBwb3J0ZWQ7XHJcbiAgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWQ7XHJcbn1cclxuZnVuY3Rpb24gaXNUb3VjaFN0YXJ0RXZlbnQoZSkge1xyXG4gIHJldHVybiBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JztcclxufVxyXG5cclxuLy9cclxuXHJcbmNvbnN0IENvbHVtblZpc2liaWxpdHkgPSB7XHJcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjb2x1bW5WaXNpYmlsaXR5OiB7fSxcclxuICAgICAgLi4uc3RhdGVcclxuICAgIH07XHJcbiAgfSxcclxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgb25Db2x1bW5WaXNpYmlsaXR5Q2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdjb2x1bW5WaXNpYmlsaXR5JywgdGFibGUpXHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xyXG4gICAgY29sdW1uLnRvZ2dsZVZpc2liaWxpdHkgPSB2YWx1ZSA9PiB7XHJcbiAgICAgIGlmIChjb2x1bW4uZ2V0Q2FuSGlkZSgpKSB7XHJcbiAgICAgICAgdGFibGUuc2V0Q29sdW1uVmlzaWJpbGl0eShvbGQgPT4gKHtcclxuICAgICAgICAgIC4uLm9sZCxcclxuICAgICAgICAgIFtjb2x1bW4uaWRdOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiAhY29sdW1uLmdldElzVmlzaWJsZSgpXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29sdW1uLmdldElzVmlzaWJsZSA9ICgpID0+IHtcclxuICAgICAgdmFyIF9yZWYsIF90YWJsZSRnZXRTdGF0ZSRjb2x1bTtcclxuICAgICAgY29uc3QgY2hpbGRDb2x1bW5zID0gY29sdW1uLmNvbHVtbnM7XHJcbiAgICAgIHJldHVybiAoX3JlZiA9IGNoaWxkQ29sdW1ucy5sZW5ndGggPyBjaGlsZENvbHVtbnMuc29tZShjID0+IGMuZ2V0SXNWaXNpYmxlKCkpIDogKF90YWJsZSRnZXRTdGF0ZSRjb2x1bSA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uVmlzaWJpbGl0eSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRjb2x1bVtjb2x1bW4uaWRdKSAhPSBudWxsID8gX3JlZiA6IHRydWU7XHJcbiAgICB9O1xyXG4gICAgY29sdW1uLmdldENhbkhpZGUgPSAoKSA9PiB7XHJcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbkRlZiRlbmEsIF90YWJsZSRvcHRpb25zJGVuYWJsZTtcclxuICAgICAgcmV0dXJuICgoX2NvbHVtbiRjb2x1bW5EZWYkZW5hID0gY29sdW1uLmNvbHVtbkRlZi5lbmFibGVIaWRpbmcpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlSGlkaW5nKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgY29sdW1uLmdldFRvZ2dsZVZpc2liaWxpdHlIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICByZXR1cm4gZSA9PiB7XHJcbiAgICAgICAgY29sdW1uLnRvZ2dsZVZpc2liaWxpdHkgPT0gbnVsbCB8fCBjb2x1bW4udG9nZ2xlVmlzaWJpbGl0eShlLnRhcmdldC5jaGVja2VkKTtcclxuICAgICAgfTtcclxuICAgIH07XHJcbiAgfSxcclxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XHJcbiAgICByb3cuX2dldEFsbFZpc2libGVDZWxscyA9IG1lbW8oKCkgPT4gW3Jvdy5nZXRBbGxDZWxscygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblZpc2liaWxpdHldLCBjZWxscyA9PiB7XHJcbiAgICAgIHJldHVybiBjZWxscy5maWx0ZXIoY2VsbCA9PiBjZWxsLmNvbHVtbi5nZXRJc1Zpc2libGUoKSk7XHJcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdSb3dzJywgJ19nZXRBbGxWaXNpYmxlQ2VsbHMnKSk7XHJcbiAgICByb3cuZ2V0VmlzaWJsZUNlbGxzID0gbWVtbygoKSA9PiBbcm93LmdldExlZnRWaXNpYmxlQ2VsbHMoKSwgcm93LmdldENlbnRlclZpc2libGVDZWxscygpLCByb3cuZ2V0UmlnaHRWaXNpYmxlQ2VsbHMoKV0sIChsZWZ0LCBjZW50ZXIsIHJpZ2h0KSA9PiBbLi4ubGVmdCwgLi4uY2VudGVyLCAuLi5yaWdodF0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnZ2V0VmlzaWJsZUNlbGxzJykpO1xyXG4gIH0sXHJcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcclxuICAgIGNvbnN0IG1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCA9IChrZXksIGdldENvbHVtbnMpID0+IHtcclxuICAgICAgcmV0dXJuIG1lbW8oKCkgPT4gW2dldENvbHVtbnMoKSwgZ2V0Q29sdW1ucygpLmZpbHRlcihkID0+IGQuZ2V0SXNWaXNpYmxlKCkpLm1hcChkID0+IGQuaWQpLmpvaW4oJ18nKV0sIGNvbHVtbnMgPT4ge1xyXG4gICAgICAgIHJldHVybiBjb2x1bW5zLmZpbHRlcihkID0+IGQuZ2V0SXNWaXNpYmxlID09IG51bGwgPyB2b2lkIDAgOiBkLmdldElzVmlzaWJsZSgpKTtcclxuICAgICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsIGtleSkpO1xyXG4gICAgfTtcclxuICAgIHRhYmxlLmdldFZpc2libGVGbGF0Q29sdW1ucyA9IG1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCgnZ2V0VmlzaWJsZUZsYXRDb2x1bW5zJywgKCkgPT4gdGFibGUuZ2V0QWxsRmxhdENvbHVtbnMoKSk7XHJcbiAgICB0YWJsZS5nZXRWaXNpYmxlTGVhZkNvbHVtbnMgPSBtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QoJ2dldFZpc2libGVMZWFmQ29sdW1ucycsICgpID0+IHRhYmxlLmdldEFsbExlYWZDb2x1bW5zKCkpO1xyXG4gICAgdGFibGUuZ2V0TGVmdFZpc2libGVMZWFmQ29sdW1ucyA9IG1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCgnZ2V0TGVmdFZpc2libGVMZWFmQ29sdW1ucycsICgpID0+IHRhYmxlLmdldExlZnRMZWFmQ29sdW1ucygpKTtcclxuICAgIHRhYmxlLmdldFJpZ2h0VmlzaWJsZUxlYWZDb2x1bW5zID0gbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kKCdnZXRSaWdodFZpc2libGVMZWFmQ29sdW1ucycsICgpID0+IHRhYmxlLmdldFJpZ2h0TGVhZkNvbHVtbnMoKSk7XHJcbiAgICB0YWJsZS5nZXRDZW50ZXJWaXNpYmxlTGVhZkNvbHVtbnMgPSBtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QoJ2dldENlbnRlclZpc2libGVMZWFmQ29sdW1ucycsICgpID0+IHRhYmxlLmdldENlbnRlckxlYWZDb2x1bW5zKCkpO1xyXG4gICAgdGFibGUuc2V0Q29sdW1uVmlzaWJpbGl0eSA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkNvbHVtblZpc2liaWxpdHlDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Db2x1bW5WaXNpYmlsaXR5Q2hhbmdlKHVwZGF0ZXIpO1xyXG4gICAgdGFibGUucmVzZXRDb2x1bW5WaXNpYmlsaXR5ID0gZGVmYXVsdFN0YXRlID0+IHtcclxuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYztcclxuICAgICAgdGFibGUuc2V0Q29sdW1uVmlzaWJpbGl0eShkZWZhdWx0U3RhdGUgPyB7fSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGMgPSB0YWJsZS5pbml0aWFsU3RhdGUuY29sdW1uVmlzaWJpbGl0eSkgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkYyA6IHt9KTtcclxuICAgIH07XHJcbiAgICB0YWJsZS50b2dnbGVBbGxDb2x1bW5zVmlzaWJsZSA9IHZhbHVlID0+IHtcclxuICAgICAgdmFyIF92YWx1ZTtcclxuICAgICAgdmFsdWUgPSAoX3ZhbHVlID0gdmFsdWUpICE9IG51bGwgPyBfdmFsdWUgOiAhdGFibGUuZ2V0SXNBbGxDb2x1bW5zVmlzaWJsZSgpO1xyXG4gICAgICB0YWJsZS5zZXRDb2x1bW5WaXNpYmlsaXR5KHRhYmxlLmdldEFsbExlYWZDb2x1bW5zKCkucmVkdWNlKChvYmosIGNvbHVtbikgPT4gKHtcclxuICAgICAgICAuLi5vYmosXHJcbiAgICAgICAgW2NvbHVtbi5pZF06ICF2YWx1ZSA/ICEoY29sdW1uLmdldENhbkhpZGUgIT0gbnVsbCAmJiBjb2x1bW4uZ2V0Q2FuSGlkZSgpKSA6IHZhbHVlXHJcbiAgICAgIH0pLCB7fSkpO1xyXG4gICAgfTtcclxuICAgIHRhYmxlLmdldElzQWxsQ29sdW1uc1Zpc2libGUgPSAoKSA9PiAhdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKS5zb21lKGNvbHVtbiA9PiAhKGNvbHVtbi5nZXRJc1Zpc2libGUgIT0gbnVsbCAmJiBjb2x1bW4uZ2V0SXNWaXNpYmxlKCkpKTtcclxuICAgIHRhYmxlLmdldElzU29tZUNvbHVtbnNWaXNpYmxlID0gKCkgPT4gdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKS5zb21lKGNvbHVtbiA9PiBjb2x1bW4uZ2V0SXNWaXNpYmxlID09IG51bGwgPyB2b2lkIDAgOiBjb2x1bW4uZ2V0SXNWaXNpYmxlKCkpO1xyXG4gICAgdGFibGUuZ2V0VG9nZ2xlQWxsQ29sdW1uc1Zpc2liaWxpdHlIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICByZXR1cm4gZSA9PiB7XHJcbiAgICAgICAgdmFyIF90YXJnZXQ7XHJcbiAgICAgICAgdGFibGUudG9nZ2xlQWxsQ29sdW1uc1Zpc2libGUoKF90YXJnZXQgPSBlLnRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YXJnZXQuY2hlY2tlZCk7XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG4gIH1cclxufTtcclxuZnVuY3Rpb24gX2dldFZpc2libGVMZWFmQ29sdW1ucyh0YWJsZSwgcG9zaXRpb24pIHtcclxuICByZXR1cm4gIXBvc2l0aW9uID8gdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCkgOiBwb3NpdGlvbiA9PT0gJ2NlbnRlcicgPyB0YWJsZS5nZXRDZW50ZXJWaXNpYmxlTGVhZkNvbHVtbnMoKSA6IHBvc2l0aW9uID09PSAnbGVmdCcgPyB0YWJsZS5nZXRMZWZ0VmlzaWJsZUxlYWZDb2x1bW5zKCkgOiB0YWJsZS5nZXRSaWdodFZpc2libGVMZWFmQ29sdW1ucygpO1xyXG59XHJcblxyXG4vL1xyXG5cclxuY29uc3QgR2xvYmFsRmFjZXRpbmcgPSB7XHJcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcclxuICAgIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRSb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRSb3dNb2RlbCh0YWJsZSwgJ19fZ2xvYmFsX18nKTtcclxuICAgIHRhYmxlLmdldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCA9ICgpID0+IHtcclxuICAgICAgaWYgKHRhYmxlLm9wdGlvbnMubWFudWFsRmlsdGVyaW5nIHx8ICF0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFJvd01vZGVsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCgpO1xyXG4gICAgfTtcclxuICAgIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkVW5pcXVlVmFsdWVzID0gdGFibGUub3B0aW9ucy5nZXRGYWNldGVkVW5pcXVlVmFsdWVzICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyh0YWJsZSwgJ19fZ2xvYmFsX18nKTtcclxuICAgIHRhYmxlLmdldEdsb2JhbEZhY2V0ZWRVbmlxdWVWYWx1ZXMgPSAoKSA9PiB7XHJcbiAgICAgIGlmICghdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRVbmlxdWVWYWx1ZXMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1hcCgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcygpO1xyXG4gICAgfTtcclxuICAgIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkTWluTWF4VmFsdWVzID0gdGFibGUub3B0aW9ucy5nZXRGYWNldGVkTWluTWF4VmFsdWVzICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyh0YWJsZSwgJ19fZ2xvYmFsX18nKTtcclxuICAgIHRhYmxlLmdldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSAoKSA9PiB7XHJcbiAgICAgIGlmICghdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkTWluTWF4VmFsdWVzKCk7XHJcbiAgICB9O1xyXG4gIH1cclxufTtcclxuXHJcbi8vXHJcblxyXG5jb25zdCBHbG9iYWxGaWx0ZXJpbmcgPSB7XHJcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBnbG9iYWxGaWx0ZXI6IHVuZGVmaW5lZCxcclxuICAgICAgLi4uc3RhdGVcclxuICAgIH07XHJcbiAgfSxcclxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgb25HbG9iYWxGaWx0ZXJDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2dsb2JhbEZpbHRlcicsIHRhYmxlKSxcclxuICAgICAgZ2xvYmFsRmlsdGVyRm46ICdhdXRvJyxcclxuICAgICAgZ2V0Q29sdW1uQ2FuR2xvYmFsRmlsdGVyOiBjb2x1bW4gPT4ge1xyXG4gICAgICAgIHZhciBfdGFibGUkZ2V0Q29yZVJvd01vZGU7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSAoX3RhYmxlJGdldENvcmVSb3dNb2RlID0gdGFibGUuZ2V0Q29yZVJvd01vZGVsKCkuZmxhdFJvd3NbMF0pID09IG51bGwgfHwgKF90YWJsZSRnZXRDb3JlUm93TW9kZSA9IF90YWJsZSRnZXRDb3JlUm93TW9kZS5fZ2V0QWxsQ2VsbHNCeUNvbHVtbklkKClbY29sdW1uLmlkXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRDb3JlUm93TW9kZS5nZXRWYWx1ZSgpO1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSxcclxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XHJcbiAgICBjb2x1bW4uZ2V0Q2FuR2xvYmFsRmlsdGVyID0gKCkgPT4ge1xyXG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hLCBfdGFibGUkb3B0aW9ucyRlbmFibGUsIF90YWJsZSRvcHRpb25zJGVuYWJsZTIsIF90YWJsZSRvcHRpb25zJGdldENvbDtcclxuICAgICAgcmV0dXJuICgoX2NvbHVtbiRjb2x1bW5EZWYkZW5hID0gY29sdW1uLmNvbHVtbkRlZi5lbmFibGVHbG9iYWxGaWx0ZXIpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlR2xvYmFsRmlsdGVyKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUyID0gdGFibGUub3B0aW9ucy5lbmFibGVGaWx0ZXJzKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZ2V0Q29sID0gdGFibGUub3B0aW9ucy5nZXRDb2x1bW5DYW5HbG9iYWxGaWx0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMuZ2V0Q29sdW1uQ2FuR2xvYmFsRmlsdGVyKGNvbHVtbikpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRnZXRDb2wgOiB0cnVlKSAmJiAhIWNvbHVtbi5hY2Nlc3NvckZuO1xyXG4gICAgfTtcclxuICB9LFxyXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XHJcbiAgICB0YWJsZS5nZXRHbG9iYWxBdXRvRmlsdGVyRm4gPSAoKSA9PiB7XHJcbiAgICAgIHJldHVybiBmaWx0ZXJGbnMuaW5jbHVkZXNTdHJpbmc7XHJcbiAgICB9O1xyXG4gICAgdGFibGUuZ2V0R2xvYmFsRmlsdGVyRm4gPSAoKSA9PiB7XHJcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRmaWx0ZXIsIF90YWJsZSRvcHRpb25zJGZpbHRlcjI7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICBnbG9iYWxGaWx0ZXJGbjogZ2xvYmFsRmlsdGVyRm5cclxuICAgICAgfSA9IHRhYmxlLm9wdGlvbnM7XHJcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGdsb2JhbEZpbHRlckZuKSA/IGdsb2JhbEZpbHRlckZuIDogZ2xvYmFsRmlsdGVyRm4gPT09ICdhdXRvJyA/IHRhYmxlLmdldEdsb2JhbEF1dG9GaWx0ZXJGbigpIDogKF90YWJsZSRvcHRpb25zJGZpbHRlciA9IChfdGFibGUkb3B0aW9ucyRmaWx0ZXIyID0gdGFibGUub3B0aW9ucy5maWx0ZXJGbnMpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkb3B0aW9ucyRmaWx0ZXIyW2dsb2JhbEZpbHRlckZuXSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGZpbHRlciA6IGZpbHRlckZuc1tnbG9iYWxGaWx0ZXJGbl07XHJcbiAgICB9O1xyXG4gICAgdGFibGUuc2V0R2xvYmFsRmlsdGVyID0gdXBkYXRlciA9PiB7XHJcbiAgICAgIHRhYmxlLm9wdGlvbnMub25HbG9iYWxGaWx0ZXJDaGFuZ2UgPT0gbnVsbCB8fCB0YWJsZS5vcHRpb25zLm9uR2xvYmFsRmlsdGVyQ2hhbmdlKHVwZGF0ZXIpO1xyXG4gICAgfTtcclxuICAgIHRhYmxlLnJlc2V0R2xvYmFsRmlsdGVyID0gZGVmYXVsdFN0YXRlID0+IHtcclxuICAgICAgdGFibGUuc2V0R2xvYmFsRmlsdGVyKGRlZmF1bHRTdGF0ZSA/IHVuZGVmaW5lZCA6IHRhYmxlLmluaXRpYWxTdGF0ZS5nbG9iYWxGaWx0ZXIpO1xyXG4gICAgfTtcclxuICB9XHJcbn07XHJcblxyXG4vL1xyXG5cclxuY29uc3QgUm93RXhwYW5kaW5nID0ge1xyXG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZXhwYW5kZWQ6IHt9LFxyXG4gICAgICAuLi5zdGF0ZVxyXG4gICAgfTtcclxuICB9LFxyXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBvbkV4cGFuZGVkQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdleHBhbmRlZCcsIHRhYmxlKSxcclxuICAgICAgcGFnaW5hdGVFeHBhbmRlZFJvd3M6IHRydWVcclxuICAgIH07XHJcbiAgfSxcclxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xyXG4gICAgbGV0IHJlZ2lzdGVyZWQgPSBmYWxzZTtcclxuICAgIGxldCBxdWV1ZWQgPSBmYWxzZTtcclxuICAgIHRhYmxlLl9hdXRvUmVzZXRFeHBhbmRlZCA9ICgpID0+IHtcclxuICAgICAgdmFyIF9yZWYsIF90YWJsZSRvcHRpb25zJGF1dG9SZTtcclxuICAgICAgaWYgKCFyZWdpc3RlcmVkKSB7XHJcbiAgICAgICAgdGFibGUuX3F1ZXVlKCgpID0+IHtcclxuICAgICAgICAgIHJlZ2lzdGVyZWQgPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoKF9yZWYgPSAoX3RhYmxlJG9wdGlvbnMkYXV0b1JlID0gdGFibGUub3B0aW9ucy5hdXRvUmVzZXRBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRhdXRvUmUgOiB0YWJsZS5vcHRpb25zLmF1dG9SZXNldEV4cGFuZGVkKSAhPSBudWxsID8gX3JlZiA6ICF0YWJsZS5vcHRpb25zLm1hbnVhbEV4cGFuZGluZykge1xyXG4gICAgICAgIGlmIChxdWV1ZWQpIHJldHVybjtcclxuICAgICAgICBxdWV1ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRhYmxlLl9xdWV1ZSgoKSA9PiB7XHJcbiAgICAgICAgICB0YWJsZS5yZXNldEV4cGFuZGVkKCk7XHJcbiAgICAgICAgICBxdWV1ZWQgPSBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRhYmxlLnNldEV4cGFuZGVkID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uRXhwYW5kZWRDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25FeHBhbmRlZENoYW5nZSh1cGRhdGVyKTtcclxuICAgIHRhYmxlLnRvZ2dsZUFsbFJvd3NFeHBhbmRlZCA9IGV4cGFuZGVkID0+IHtcclxuICAgICAgaWYgKGV4cGFuZGVkICE9IG51bGwgPyBleHBhbmRlZCA6ICF0YWJsZS5nZXRJc0FsbFJvd3NFeHBhbmRlZCgpKSB7XHJcbiAgICAgICAgdGFibGUuc2V0RXhwYW5kZWQodHJ1ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGFibGUuc2V0RXhwYW5kZWQoe30pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGFibGUucmVzZXRFeHBhbmRlZCA9IGRlZmF1bHRTdGF0ZSA9PiB7XHJcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGUsIF90YWJsZSRpbml0aWFsU3RhdGU7XHJcbiAgICAgIHRhYmxlLnNldEV4cGFuZGVkKGRlZmF1bHRTdGF0ZSA/IHt9IDogKF90YWJsZSRpbml0aWFsU3RhdGUkZSA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5leHBhbmRlZCkgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkZSA6IHt9KTtcclxuICAgIH07XHJcbiAgICB0YWJsZS5nZXRDYW5Tb21lUm93c0V4cGFuZCA9ICgpID0+IHtcclxuICAgICAgcmV0dXJuIHRhYmxlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCgpLmZsYXRSb3dzLnNvbWUocm93ID0+IHJvdy5nZXRDYW5FeHBhbmQoKSk7XHJcbiAgICB9O1xyXG4gICAgdGFibGUuZ2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkSGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgcmV0dXJuIGUgPT4ge1xyXG4gICAgICAgIGUucGVyc2lzdCA9PSBudWxsIHx8IGUucGVyc2lzdCgpO1xyXG4gICAgICAgIHRhYmxlLnRvZ2dsZUFsbFJvd3NFeHBhbmRlZCgpO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICAgIHRhYmxlLmdldElzU29tZVJvd3NFeHBhbmRlZCA9ICgpID0+IHtcclxuICAgICAgY29uc3QgZXhwYW5kZWQgPSB0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkO1xyXG4gICAgICByZXR1cm4gZXhwYW5kZWQgPT09IHRydWUgfHwgT2JqZWN0LnZhbHVlcyhleHBhbmRlZCkuc29tZShCb29sZWFuKTtcclxuICAgIH07XHJcbiAgICB0YWJsZS5nZXRJc0FsbFJvd3NFeHBhbmRlZCA9ICgpID0+IHtcclxuICAgICAgY29uc3QgZXhwYW5kZWQgPSB0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkO1xyXG5cclxuICAgICAgLy8gSWYgZXhwYW5kZWQgaXMgdHJ1ZSwgc2F2ZSBzb21lIGN5Y2xlcyBhbmQgcmV0dXJuIHRydWVcclxuICAgICAgaWYgKHR5cGVvZiBleHBhbmRlZCA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4cGFuZGVkID09PSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghT2JqZWN0LmtleXMoZXhwYW5kZWQpLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgYW55IHJvdyBpcyBub3QgZXhwYW5kZWQsIHJldHVybiBmYWxzZVxyXG4gICAgICBpZiAodGFibGUuZ2V0Um93TW9kZWwoKS5mbGF0Um93cy5zb21lKHJvdyA9PiAhcm93LmdldElzRXhwYW5kZWQoKSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRoZXkgbXVzdCBhbGwgYmUgZXhwYW5kZWQgOnNocnVnOlxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICB0YWJsZS5nZXRFeHBhbmRlZERlcHRoID0gKCkgPT4ge1xyXG4gICAgICBsZXQgbWF4RGVwdGggPSAwO1xyXG4gICAgICBjb25zdCByb3dJZHMgPSB0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkID09PSB0cnVlID8gT2JqZWN0LmtleXModGFibGUuZ2V0Um93TW9kZWwoKS5yb3dzQnlJZCkgOiBPYmplY3Qua2V5cyh0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkKTtcclxuICAgICAgcm93SWRzLmZvckVhY2goaWQgPT4ge1xyXG4gICAgICAgIGNvbnN0IHNwbGl0SWQgPSBpZC5zcGxpdCgnLicpO1xyXG4gICAgICAgIG1heERlcHRoID0gTWF0aC5tYXgobWF4RGVwdGgsIHNwbGl0SWQubGVuZ3RoKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBtYXhEZXB0aDtcclxuICAgIH07XHJcbiAgICB0YWJsZS5nZXRQcmVFeHBhbmRlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0U29ydGVkUm93TW9kZWwoKTtcclxuICAgIHRhYmxlLmdldEV4cGFuZGVkUm93TW9kZWwgPSAoKSA9PiB7XHJcbiAgICAgIGlmICghdGFibGUuX2dldEV4cGFuZGVkUm93TW9kZWwgJiYgdGFibGUub3B0aW9ucy5nZXRFeHBhbmRlZFJvd01vZGVsKSB7XHJcbiAgICAgICAgdGFibGUuX2dldEV4cGFuZGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldEV4cGFuZGVkUm93TW9kZWwodGFibGUpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0YWJsZS5vcHRpb25zLm1hbnVhbEV4cGFuZGluZyB8fCAhdGFibGUuX2dldEV4cGFuZGVkUm93TW9kZWwpIHtcclxuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlRXhwYW5kZWRSb3dNb2RlbCgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0RXhwYW5kZWRSb3dNb2RlbCgpO1xyXG4gICAgfTtcclxuICB9LFxyXG4gIGNyZWF0ZVJvdzogKHJvdywgdGFibGUpID0+IHtcclxuICAgIHJvdy50b2dnbGVFeHBhbmRlZCA9IGV4cGFuZGVkID0+IHtcclxuICAgICAgdGFibGUuc2V0RXhwYW5kZWQob2xkID0+IHtcclxuICAgICAgICB2YXIgX2V4cGFuZGVkO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IG9sZCA9PT0gdHJ1ZSA/IHRydWUgOiAhIShvbGQgIT0gbnVsbCAmJiBvbGRbcm93LmlkXSk7XHJcbiAgICAgICAgbGV0IG9sZEV4cGFuZGVkID0ge307XHJcbiAgICAgICAgaWYgKG9sZCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgT2JqZWN0LmtleXModGFibGUuZ2V0Um93TW9kZWwoKS5yb3dzQnlJZCkuZm9yRWFjaChyb3dJZCA9PiB7XHJcbiAgICAgICAgICAgIG9sZEV4cGFuZGVkW3Jvd0lkXSA9IHRydWU7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgb2xkRXhwYW5kZWQgPSBvbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4cGFuZGVkID0gKF9leHBhbmRlZCA9IGV4cGFuZGVkKSAhPSBudWxsID8gX2V4cGFuZGVkIDogIWV4aXN0cztcclxuICAgICAgICBpZiAoIWV4aXN0cyAmJiBleHBhbmRlZCkge1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4ub2xkRXhwYW5kZWQsXHJcbiAgICAgICAgICAgIFtyb3cuaWRdOiB0cnVlXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXhpc3RzICYmICFleHBhbmRlZCkge1xyXG4gICAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICBbcm93LmlkXTogXyxcclxuICAgICAgICAgICAgLi4ucmVzdFxyXG4gICAgICAgICAgfSA9IG9sZEV4cGFuZGVkO1xyXG4gICAgICAgICAgcmV0dXJuIHJlc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvbGQ7XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJvdy5nZXRJc0V4cGFuZGVkID0gKCkgPT4ge1xyXG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZ2V0SXNSO1xyXG4gICAgICBjb25zdCBleHBhbmRlZCA9IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQ7XHJcbiAgICAgIHJldHVybiAhISgoX3RhYmxlJG9wdGlvbnMkZ2V0SXNSID0gdGFibGUub3B0aW9ucy5nZXRJc1Jvd0V4cGFuZGVkID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLmdldElzUm93RXhwYW5kZWQocm93KSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGdldElzUiA6IGV4cGFuZGVkID09PSB0cnVlIHx8IChleHBhbmRlZCA9PSBudWxsID8gdm9pZCAwIDogZXhwYW5kZWRbcm93LmlkXSkpO1xyXG4gICAgfTtcclxuICAgIHJvdy5nZXRDYW5FeHBhbmQgPSAoKSA9PiB7XHJcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRnZXRSb3csIF90YWJsZSRvcHRpb25zJGVuYWJsZSwgX3JvdyRzdWJSb3dzO1xyXG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGdldFJvdyA9IHRhYmxlLm9wdGlvbnMuZ2V0Um93Q2FuRXhwYW5kID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLmdldFJvd0NhbkV4cGFuZChyb3cpKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZ2V0Um93IDogKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUV4cGFuZGluZykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWUpICYmICEhKChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MubGVuZ3RoKTtcclxuICAgIH07XHJcbiAgICByb3cuZ2V0SXNBbGxQYXJlbnRzRXhwYW5kZWQgPSAoKSA9PiB7XHJcbiAgICAgIGxldCBpc0Z1bGx5RXhwYW5kZWQgPSB0cnVlO1xyXG4gICAgICBsZXQgY3VycmVudFJvdyA9IHJvdztcclxuICAgICAgd2hpbGUgKGlzRnVsbHlFeHBhbmRlZCAmJiBjdXJyZW50Um93LnBhcmVudElkKSB7XHJcbiAgICAgICAgY3VycmVudFJvdyA9IHRhYmxlLmdldFJvdyhjdXJyZW50Um93LnBhcmVudElkLCB0cnVlKTtcclxuICAgICAgICBpc0Z1bGx5RXhwYW5kZWQgPSBjdXJyZW50Um93LmdldElzRXhwYW5kZWQoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaXNGdWxseUV4cGFuZGVkO1xyXG4gICAgfTtcclxuICAgIHJvdy5nZXRUb2dnbGVFeHBhbmRlZEhhbmRsZXIgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNhbkV4cGFuZCA9IHJvdy5nZXRDYW5FeHBhbmQoKTtcclxuICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBpZiAoIWNhbkV4cGFuZCkgcmV0dXJuO1xyXG4gICAgICAgIHJvdy50b2dnbGVFeHBhbmRlZCgpO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICB9XHJcbn07XHJcblxyXG4vL1xyXG5cclxuY29uc3QgZGVmYXVsdFBhZ2VJbmRleCA9IDA7XHJcbmNvbnN0IGRlZmF1bHRQYWdlU2l6ZSA9IDEwO1xyXG5jb25zdCBnZXREZWZhdWx0UGFnaW5hdGlvblN0YXRlID0gKCkgPT4gKHtcclxuICBwYWdlSW5kZXg6IGRlZmF1bHRQYWdlSW5kZXgsXHJcbiAgcGFnZVNpemU6IGRlZmF1bHRQYWdlU2l6ZVxyXG59KTtcclxuY29uc3QgUm93UGFnaW5hdGlvbiA9IHtcclxuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIC4uLnN0YXRlLFxyXG4gICAgICBwYWdpbmF0aW9uOiB7XHJcbiAgICAgICAgLi4uZ2V0RGVmYXVsdFBhZ2luYXRpb25TdGF0ZSgpLFxyXG4gICAgICAgIC4uLihzdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUucGFnaW5hdGlvbilcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LFxyXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBvblBhZ2luYXRpb25DaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ3BhZ2luYXRpb24nLCB0YWJsZSlcclxuICAgIH07XHJcbiAgfSxcclxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xyXG4gICAgbGV0IHJlZ2lzdGVyZWQgPSBmYWxzZTtcclxuICAgIGxldCBxdWV1ZWQgPSBmYWxzZTtcclxuICAgIHRhYmxlLl9hdXRvUmVzZXRQYWdlSW5kZXggPSAoKSA9PiB7XHJcbiAgICAgIHZhciBfcmVmLCBfdGFibGUkb3B0aW9ucyRhdXRvUmU7XHJcbiAgICAgIGlmICghcmVnaXN0ZXJlZCkge1xyXG4gICAgICAgIHRhYmxlLl9xdWV1ZSgoKSA9PiB7XHJcbiAgICAgICAgICByZWdpc3RlcmVkID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKChfcmVmID0gKF90YWJsZSRvcHRpb25zJGF1dG9SZSA9IHRhYmxlLm9wdGlvbnMuYXV0b1Jlc2V0QWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkYXV0b1JlIDogdGFibGUub3B0aW9ucy5hdXRvUmVzZXRQYWdlSW5kZXgpICE9IG51bGwgPyBfcmVmIDogIXRhYmxlLm9wdGlvbnMubWFudWFsUGFnaW5hdGlvbikge1xyXG4gICAgICAgIGlmIChxdWV1ZWQpIHJldHVybjtcclxuICAgICAgICBxdWV1ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRhYmxlLl9xdWV1ZSgoKSA9PiB7XHJcbiAgICAgICAgICB0YWJsZS5yZXNldFBhZ2VJbmRleCgpO1xyXG4gICAgICAgICAgcXVldWVkID0gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB0YWJsZS5zZXRQYWdpbmF0aW9uID0gdXBkYXRlciA9PiB7XHJcbiAgICAgIGNvbnN0IHNhZmVVcGRhdGVyID0gb2xkID0+IHtcclxuICAgICAgICBsZXQgbmV3U3RhdGUgPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZCk7XHJcbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5vblBhZ2luYXRpb25DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25QYWdpbmF0aW9uQ2hhbmdlKHNhZmVVcGRhdGVyKTtcclxuICAgIH07XHJcbiAgICB0YWJsZS5yZXNldFBhZ2luYXRpb24gPSBkZWZhdWx0U3RhdGUgPT4ge1xyXG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRwO1xyXG4gICAgICB0YWJsZS5zZXRQYWdpbmF0aW9uKGRlZmF1bHRTdGF0ZSA/IGdldERlZmF1bHRQYWdpbmF0aW9uU3RhdGUoKSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJHAgPSB0YWJsZS5pbml0aWFsU3RhdGUucGFnaW5hdGlvbikgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkcCA6IGdldERlZmF1bHRQYWdpbmF0aW9uU3RhdGUoKSk7XHJcbiAgICB9O1xyXG4gICAgdGFibGUuc2V0UGFnZUluZGV4ID0gdXBkYXRlciA9PiB7XHJcbiAgICAgIHRhYmxlLnNldFBhZ2luYXRpb24ob2xkID0+IHtcclxuICAgICAgICBsZXQgcGFnZUluZGV4ID0gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBvbGQucGFnZUluZGV4KTtcclxuICAgICAgICBjb25zdCBtYXhQYWdlSW5kZXggPSB0eXBlb2YgdGFibGUub3B0aW9ucy5wYWdlQ291bnQgPT09ICd1bmRlZmluZWQnIHx8IHRhYmxlLm9wdGlvbnMucGFnZUNvdW50ID09PSAtMSA/IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIDogdGFibGUub3B0aW9ucy5wYWdlQ291bnQgLSAxO1xyXG4gICAgICAgIHBhZ2VJbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VJbmRleCwgbWF4UGFnZUluZGV4KSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIC4uLm9sZCxcclxuICAgICAgICAgIHBhZ2VJbmRleFxyXG4gICAgICAgIH07XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHRhYmxlLnJlc2V0UGFnZUluZGV4ID0gZGVmYXVsdFN0YXRlID0+IHtcclxuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkcDIsIF90YWJsZSRpbml0aWFsU3RhdGU7XHJcbiAgICAgIHRhYmxlLnNldFBhZ2VJbmRleChkZWZhdWx0U3RhdGUgPyBkZWZhdWx0UGFnZUluZGV4IDogKF90YWJsZSRpbml0aWFsU3RhdGUkcDIgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZSA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCB8fCAoX3RhYmxlJGluaXRpYWxTdGF0ZSA9IF90YWJsZSRpbml0aWFsU3RhdGUucGFnaW5hdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUucGFnZUluZGV4KSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRwMiA6IGRlZmF1bHRQYWdlSW5kZXgpO1xyXG4gICAgfTtcclxuICAgIHRhYmxlLnJlc2V0UGFnZVNpemUgPSBkZWZhdWx0U3RhdGUgPT4ge1xyXG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRwMywgX3RhYmxlJGluaXRpYWxTdGF0ZTI7XHJcbiAgICAgIHRhYmxlLnNldFBhZ2VTaXplKGRlZmF1bHRTdGF0ZSA/IGRlZmF1bHRQYWdlU2l6ZSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJHAzID0gKF90YWJsZSRpbml0aWFsU3RhdGUyID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsIHx8IChfdGFibGUkaW5pdGlhbFN0YXRlMiA9IF90YWJsZSRpbml0aWFsU3RhdGUyLnBhZ2luYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlMi5wYWdlU2l6ZSkgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkcDMgOiBkZWZhdWx0UGFnZVNpemUpO1xyXG4gICAgfTtcclxuICAgIHRhYmxlLnNldFBhZ2VTaXplID0gdXBkYXRlciA9PiB7XHJcbiAgICAgIHRhYmxlLnNldFBhZ2luYXRpb24ob2xkID0+IHtcclxuICAgICAgICBjb25zdCBwYWdlU2l6ZSA9IE1hdGgubWF4KDEsIGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgb2xkLnBhZ2VTaXplKSk7XHJcbiAgICAgICAgY29uc3QgdG9wUm93SW5kZXggPSBvbGQucGFnZVNpemUgKiBvbGQucGFnZUluZGV4O1xyXG4gICAgICAgIGNvbnN0IHBhZ2VJbmRleCA9IE1hdGguZmxvb3IodG9wUm93SW5kZXggLyBwYWdlU2l6ZSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIC4uLm9sZCxcclxuICAgICAgICAgIHBhZ2VJbmRleCxcclxuICAgICAgICAgIHBhZ2VTaXplXHJcbiAgICAgICAgfTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy9kZXByZWNhdGVkXHJcbiAgICB0YWJsZS5zZXRQYWdlQ291bnQgPSB1cGRhdGVyID0+IHRhYmxlLnNldFBhZ2luYXRpb24ob2xkID0+IHtcclxuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJHBhZ2VDbztcclxuICAgICAgbGV0IG5ld1BhZ2VDb3VudCA9IGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgKF90YWJsZSRvcHRpb25zJHBhZ2VDbyA9IHRhYmxlLm9wdGlvbnMucGFnZUNvdW50KSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkcGFnZUNvIDogLTEpO1xyXG4gICAgICBpZiAodHlwZW9mIG5ld1BhZ2VDb3VudCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICBuZXdQYWdlQ291bnQgPSBNYXRoLm1heCgtMSwgbmV3UGFnZUNvdW50KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLm9sZCxcclxuICAgICAgICBwYWdlQ291bnQ6IG5ld1BhZ2VDb3VudFxyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICB0YWJsZS5nZXRQYWdlT3B0aW9ucyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFBhZ2VDb3VudCgpXSwgcGFnZUNvdW50ID0+IHtcclxuICAgICAgbGV0IHBhZ2VPcHRpb25zID0gW107XHJcbiAgICAgIGlmIChwYWdlQ291bnQgJiYgcGFnZUNvdW50ID4gMCkge1xyXG4gICAgICAgIHBhZ2VPcHRpb25zID0gWy4uLm5ldyBBcnJheShwYWdlQ291bnQpXS5maWxsKG51bGwpLm1hcCgoXywgaSkgPT4gaSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHBhZ2VPcHRpb25zO1xyXG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0UGFnZU9wdGlvbnMnKSk7XHJcbiAgICB0YWJsZS5nZXRDYW5QcmV2aW91c1BhZ2UgPSAoKSA9PiB0YWJsZS5nZXRTdGF0ZSgpLnBhZ2luYXRpb24ucGFnZUluZGV4ID4gMDtcclxuICAgIHRhYmxlLmdldENhbk5leHRQYWdlID0gKCkgPT4ge1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgcGFnZUluZGV4XHJcbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpLnBhZ2luYXRpb247XHJcbiAgICAgIGNvbnN0IHBhZ2VDb3VudCA9IHRhYmxlLmdldFBhZ2VDb3VudCgpO1xyXG4gICAgICBpZiAocGFnZUNvdW50ID09PSAtMSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwYWdlQ291bnQgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHBhZ2VJbmRleCA8IHBhZ2VDb3VudCAtIDE7XHJcbiAgICB9O1xyXG4gICAgdGFibGUucHJldmlvdXNQYWdlID0gKCkgPT4ge1xyXG4gICAgICByZXR1cm4gdGFibGUuc2V0UGFnZUluZGV4KG9sZCA9PiBvbGQgLSAxKTtcclxuICAgIH07XHJcbiAgICB0YWJsZS5uZXh0UGFnZSA9ICgpID0+IHtcclxuICAgICAgcmV0dXJuIHRhYmxlLnNldFBhZ2VJbmRleChvbGQgPT4ge1xyXG4gICAgICAgIHJldHVybiBvbGQgKyAxO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgICB0YWJsZS5maXJzdFBhZ2UgPSAoKSA9PiB7XHJcbiAgICAgIHJldHVybiB0YWJsZS5zZXRQYWdlSW5kZXgoMCk7XHJcbiAgICB9O1xyXG4gICAgdGFibGUubGFzdFBhZ2UgPSAoKSA9PiB7XHJcbiAgICAgIHJldHVybiB0YWJsZS5zZXRQYWdlSW5kZXgodGFibGUuZ2V0UGFnZUNvdW50KCkgLSAxKTtcclxuICAgIH07XHJcbiAgICB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRFeHBhbmRlZFJvd01vZGVsKCk7XHJcbiAgICB0YWJsZS5nZXRQYWdpbmF0aW9uUm93TW9kZWwgPSAoKSA9PiB7XHJcbiAgICAgIGlmICghdGFibGUuX2dldFBhZ2luYXRpb25Sb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldFBhZ2luYXRpb25Sb3dNb2RlbCkge1xyXG4gICAgICAgIHRhYmxlLl9nZXRQYWdpbmF0aW9uUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldFBhZ2luYXRpb25Sb3dNb2RlbCh0YWJsZSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRhYmxlLm9wdGlvbnMubWFudWFsUGFnaW5hdGlvbiB8fCAhdGFibGUuX2dldFBhZ2luYXRpb25Sb3dNb2RlbCkge1xyXG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGFibGUuX2dldFBhZ2luYXRpb25Sb3dNb2RlbCgpO1xyXG4gICAgfTtcclxuICAgIHRhYmxlLmdldFBhZ2VDb3VudCA9ICgpID0+IHtcclxuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJHBhZ2VDbzI7XHJcbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkcGFnZUNvMiA9IHRhYmxlLm9wdGlvbnMucGFnZUNvdW50KSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkcGFnZUNvMiA6IE1hdGguY2VpbCh0YWJsZS5nZXRSb3dDb3VudCgpIC8gdGFibGUuZ2V0U3RhdGUoKS5wYWdpbmF0aW9uLnBhZ2VTaXplKTtcclxuICAgIH07XHJcbiAgICB0YWJsZS5nZXRSb3dDb3VudCA9ICgpID0+IHtcclxuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJHJvd0NvdTtcclxuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRyb3dDb3UgPSB0YWJsZS5vcHRpb25zLnJvd0NvdW50KSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkcm93Q291IDogdGFibGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCkucm93cy5sZW5ndGg7XHJcbiAgICB9O1xyXG4gIH1cclxufTtcclxuXHJcbi8vXHJcblxyXG5jb25zdCBnZXREZWZhdWx0Um93UGlubmluZ1N0YXRlID0gKCkgPT4gKHtcclxuICB0b3A6IFtdLFxyXG4gIGJvdHRvbTogW11cclxufSk7XHJcbmNvbnN0IFJvd1Bpbm5pbmcgPSB7XHJcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByb3dQaW5uaW5nOiBnZXREZWZhdWx0Um93UGlubmluZ1N0YXRlKCksXHJcbiAgICAgIC4uLnN0YXRlXHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG9uUm93UGlubmluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcigncm93UGlubmluZycsIHRhYmxlKVxyXG4gICAgfTtcclxuICB9LFxyXG4gIGNyZWF0ZVJvdzogKHJvdywgdGFibGUpID0+IHtcclxuICAgIHJvdy5waW4gPSAocG9zaXRpb24sIGluY2x1ZGVMZWFmUm93cywgaW5jbHVkZVBhcmVudFJvd3MpID0+IHtcclxuICAgICAgY29uc3QgbGVhZlJvd0lkcyA9IGluY2x1ZGVMZWFmUm93cyA/IHJvdy5nZXRMZWFmUm93cygpLm1hcChfcmVmID0+IHtcclxuICAgICAgICBsZXQge1xyXG4gICAgICAgICAgaWRcclxuICAgICAgICB9ID0gX3JlZjtcclxuICAgICAgICByZXR1cm4gaWQ7XHJcbiAgICAgIH0pIDogW107XHJcbiAgICAgIGNvbnN0IHBhcmVudFJvd0lkcyA9IGluY2x1ZGVQYXJlbnRSb3dzID8gcm93LmdldFBhcmVudFJvd3MoKS5tYXAoX3JlZjIgPT4ge1xyXG4gICAgICAgIGxldCB7XHJcbiAgICAgICAgICBpZFxyXG4gICAgICAgIH0gPSBfcmVmMjtcclxuICAgICAgICByZXR1cm4gaWQ7XHJcbiAgICAgIH0pIDogW107XHJcbiAgICAgIGNvbnN0IHJvd0lkcyA9IG5ldyBTZXQoWy4uLnBhcmVudFJvd0lkcywgcm93LmlkLCAuLi5sZWFmUm93SWRzXSk7XHJcbiAgICAgIHRhYmxlLnNldFJvd1Bpbm5pbmcob2xkID0+IHtcclxuICAgICAgICB2YXIgX29sZCR0b3AzLCBfb2xkJGJvdHRvbTM7XHJcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xyXG4gICAgICAgICAgdmFyIF9vbGQkdG9wLCBfb2xkJGJvdHRvbTtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRvcDogKChfb2xkJHRvcCA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnRvcCkgIT0gbnVsbCA/IF9vbGQkdG9wIDogW10pLmZpbHRlcihkID0+ICEocm93SWRzICE9IG51bGwgJiYgcm93SWRzLmhhcyhkKSkpLFxyXG4gICAgICAgICAgICBib3R0b206IFsuLi4oKF9vbGQkYm90dG9tID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuYm90dG9tKSAhPSBudWxsID8gX29sZCRib3R0b20gOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSksIC4uLkFycmF5LmZyb20ocm93SWRzKV1cclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcclxuICAgICAgICAgIHZhciBfb2xkJHRvcDIsIF9vbGQkYm90dG9tMjtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRvcDogWy4uLigoX29sZCR0b3AyID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQudG9wKSAhPSBudWxsID8gX29sZCR0b3AyIDogW10pLmZpbHRlcihkID0+ICEocm93SWRzICE9IG51bGwgJiYgcm93SWRzLmhhcyhkKSkpLCAuLi5BcnJheS5mcm9tKHJvd0lkcyldLFxyXG4gICAgICAgICAgICBib3R0b206ICgoX29sZCRib3R0b20yID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuYm90dG9tKSAhPSBudWxsID8gX29sZCRib3R0b20yIDogW10pLmZpbHRlcihkID0+ICEocm93SWRzICE9IG51bGwgJiYgcm93SWRzLmhhcyhkKSkpXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgdG9wOiAoKF9vbGQkdG9wMyA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnRvcCkgIT0gbnVsbCA/IF9vbGQkdG9wMyA6IFtdKS5maWx0ZXIoZCA9PiAhKHJvd0lkcyAhPSBudWxsICYmIHJvd0lkcy5oYXMoZCkpKSxcclxuICAgICAgICAgIGJvdHRvbTogKChfb2xkJGJvdHRvbTMgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5ib3R0b20pICE9IG51bGwgPyBfb2xkJGJvdHRvbTMgOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSlcclxuICAgICAgICB9O1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgICByb3cuZ2V0Q2FuUGluID0gKCkgPT4ge1xyXG4gICAgICB2YXIgX3JlZjM7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICBlbmFibGVSb3dQaW5uaW5nLFxyXG4gICAgICAgIGVuYWJsZVBpbm5pbmdcclxuICAgICAgfSA9IHRhYmxlLm9wdGlvbnM7XHJcbiAgICAgIGlmICh0eXBlb2YgZW5hYmxlUm93UGlubmluZyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHJldHVybiBlbmFibGVSb3dQaW5uaW5nKHJvdyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIChfcmVmMyA9IGVuYWJsZVJvd1Bpbm5pbmcgIT0gbnVsbCA/IGVuYWJsZVJvd1Bpbm5pbmcgOiBlbmFibGVQaW5uaW5nKSAhPSBudWxsID8gX3JlZjMgOiB0cnVlO1xyXG4gICAgfTtcclxuICAgIHJvdy5nZXRJc1Bpbm5lZCA9ICgpID0+IHtcclxuICAgICAgY29uc3Qgcm93SWRzID0gW3Jvdy5pZF07XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICB0b3AsXHJcbiAgICAgICAgYm90dG9tXHJcbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpLnJvd1Bpbm5pbmc7XHJcbiAgICAgIGNvbnN0IGlzVG9wID0gcm93SWRzLnNvbWUoZCA9PiB0b3AgPT0gbnVsbCA/IHZvaWQgMCA6IHRvcC5pbmNsdWRlcyhkKSk7XHJcbiAgICAgIGNvbnN0IGlzQm90dG9tID0gcm93SWRzLnNvbWUoZCA9PiBib3R0b20gPT0gbnVsbCA/IHZvaWQgMCA6IGJvdHRvbS5pbmNsdWRlcyhkKSk7XHJcbiAgICAgIHJldHVybiBpc1RvcCA/ICd0b3AnIDogaXNCb3R0b20gPyAnYm90dG9tJyA6IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIHJvdy5nZXRQaW5uZWRJbmRleCA9ICgpID0+IHtcclxuICAgICAgdmFyIF90YWJsZSRfZ2V0UGlubmVkUm93cywgX3Zpc2libGVQaW5uZWRSb3dJZHMkO1xyXG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHJvdy5nZXRJc1Bpbm5lZCgpO1xyXG4gICAgICBpZiAoIXBvc2l0aW9uKSByZXR1cm4gLTE7XHJcbiAgICAgIGNvbnN0IHZpc2libGVQaW5uZWRSb3dJZHMgPSAoX3RhYmxlJF9nZXRQaW5uZWRSb3dzID0gdGFibGUuX2dldFBpbm5lZFJvd3MocG9zaXRpb24pKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJF9nZXRQaW5uZWRSb3dzLm1hcChfcmVmNCA9PiB7XHJcbiAgICAgICAgbGV0IHtcclxuICAgICAgICAgIGlkXHJcbiAgICAgICAgfSA9IF9yZWY0O1xyXG4gICAgICAgIHJldHVybiBpZDtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiAoX3Zpc2libGVQaW5uZWRSb3dJZHMkID0gdmlzaWJsZVBpbm5lZFJvd0lkcyA9PSBudWxsID8gdm9pZCAwIDogdmlzaWJsZVBpbm5lZFJvd0lkcy5pbmRleE9mKHJvdy5pZCkpICE9IG51bGwgPyBfdmlzaWJsZVBpbm5lZFJvd0lkcyQgOiAtMTtcclxuICAgIH07XHJcbiAgfSxcclxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xyXG4gICAgdGFibGUuc2V0Um93UGlubmluZyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vblJvd1Bpbm5pbmdDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Sb3dQaW5uaW5nQ2hhbmdlKHVwZGF0ZXIpO1xyXG4gICAgdGFibGUucmVzZXRSb3dQaW5uaW5nID0gZGVmYXVsdFN0YXRlID0+IHtcclxuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkciwgX3RhYmxlJGluaXRpYWxTdGF0ZTtcclxuICAgICAgcmV0dXJuIHRhYmxlLnNldFJvd1Bpbm5pbmcoZGVmYXVsdFN0YXRlID8gZ2V0RGVmYXVsdFJvd1Bpbm5pbmdTdGF0ZSgpIDogKF90YWJsZSRpbml0aWFsU3RhdGUkciA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5yb3dQaW5uaW5nKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRyIDogZ2V0RGVmYXVsdFJvd1Bpbm5pbmdTdGF0ZSgpKTtcclxuICAgIH07XHJcbiAgICB0YWJsZS5nZXRJc1NvbWVSb3dzUGlubmVkID0gcG9zaXRpb24gPT4ge1xyXG4gICAgICB2YXIgX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvO1xyXG4gICAgICBjb25zdCBwaW5uaW5nU3RhdGUgPSB0YWJsZS5nZXRTdGF0ZSgpLnJvd1Bpbm5pbmc7XHJcbiAgICAgIGlmICghcG9zaXRpb24pIHtcclxuICAgICAgICB2YXIgX3Bpbm5pbmdTdGF0ZSR0b3AsIF9waW5uaW5nU3RhdGUkYm90dG9tO1xyXG4gICAgICAgIHJldHVybiBCb29sZWFuKCgoX3Bpbm5pbmdTdGF0ZSR0b3AgPSBwaW5uaW5nU3RhdGUudG9wKSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSR0b3AubGVuZ3RoKSB8fCAoKF9waW5uaW5nU3RhdGUkYm90dG9tID0gcGlubmluZ1N0YXRlLmJvdHRvbSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkYm90dG9tLmxlbmd0aCkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBCb29sZWFuKChfcGlubmluZ1N0YXRlJHBvc2l0aW8gPSBwaW5uaW5nU3RhdGVbcG9zaXRpb25dKSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvLmxlbmd0aCk7XHJcbiAgICB9O1xyXG4gICAgdGFibGUuX2dldFBpbm5lZFJvd3MgPSBtZW1vKHBvc2l0aW9uID0+IFt0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3MsIHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZ1twb3NpdGlvbl0sIHBvc2l0aW9uXSwgKHZpc2libGVSb3dzLCBwaW5uZWRSb3dJZHMsIHBvc2l0aW9uKSA9PiB7XHJcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRrZWVwUGk7XHJcbiAgICAgIGNvbnN0IHJvd3MgPSAoKF90YWJsZSRvcHRpb25zJGtlZXBQaSA9IHRhYmxlLm9wdGlvbnMua2VlcFBpbm5lZFJvd3MpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRrZWVwUGkgOiB0cnVlKSA/XHJcbiAgICAgIC8vZ2V0IGFsbCByb3dzIHRoYXQgYXJlIHBpbm5lZCBldmVuIGlmIHRoZXkgd291bGQgbm90IGJlIG90aGVyd2lzZSB2aXNpYmxlXHJcbiAgICAgIC8vYWNjb3VudCBmb3IgZXhwYW5kZWQgcGFyZW50IHJvd3MsIGJ1dCBub3QgcGFnaW5hdGlvbiBvciBmaWx0ZXJpbmdcclxuICAgICAgKHBpbm5lZFJvd0lkcyAhPSBudWxsID8gcGlubmVkUm93SWRzIDogW10pLm1hcChyb3dJZCA9PiB7XHJcbiAgICAgICAgY29uc3Qgcm93ID0gdGFibGUuZ2V0Um93KHJvd0lkLCB0cnVlKTtcclxuICAgICAgICByZXR1cm4gcm93LmdldElzQWxsUGFyZW50c0V4cGFuZGVkKCkgPyByb3cgOiBudWxsO1xyXG4gICAgICB9KSA6XHJcbiAgICAgIC8vZWxzZSBnZXQgb25seSB2aXNpYmxlIHJvd3MgdGhhdCBhcmUgcGlubmVkXHJcbiAgICAgIChwaW5uZWRSb3dJZHMgIT0gbnVsbCA/IHBpbm5lZFJvd0lkcyA6IFtdKS5tYXAocm93SWQgPT4gdmlzaWJsZVJvd3MuZmluZChyb3cgPT4gcm93LmlkID09PSByb3dJZCkpO1xyXG4gICAgICByZXR1cm4gcm93cy5maWx0ZXIoQm9vbGVhbikubWFwKGQgPT4gKHtcclxuICAgICAgICAuLi5kLFxyXG4gICAgICAgIHBvc2l0aW9uXHJcbiAgICAgIH0pKTtcclxuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnX2dldFBpbm5lZFJvd3MnKSk7XHJcbiAgICB0YWJsZS5nZXRUb3BSb3dzID0gKCkgPT4gdGFibGUuX2dldFBpbm5lZFJvd3MoJ3RvcCcpO1xyXG4gICAgdGFibGUuZ2V0Qm90dG9tUm93cyA9ICgpID0+IHRhYmxlLl9nZXRQaW5uZWRSb3dzKCdib3R0b20nKTtcclxuICAgIHRhYmxlLmdldENlbnRlclJvd3MgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3MsIHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZy50b3AsIHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZy5ib3R0b21dLCAoYWxsUm93cywgdG9wLCBib3R0b20pID0+IHtcclxuICAgICAgY29uc3QgdG9wQW5kQm90dG9tID0gbmV3IFNldChbLi4uKHRvcCAhPSBudWxsID8gdG9wIDogW10pLCAuLi4oYm90dG9tICE9IG51bGwgPyBib3R0b20gOiBbXSldKTtcclxuICAgICAgcmV0dXJuIGFsbFJvd3MuZmlsdGVyKGQgPT4gIXRvcEFuZEJvdHRvbS5oYXMoZC5pZCkpO1xyXG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRDZW50ZXJSb3dzJykpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vXHJcblxyXG5jb25zdCBSb3dTZWxlY3Rpb24gPSB7XHJcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByb3dTZWxlY3Rpb246IHt9LFxyXG4gICAgICAuLi5zdGF0ZVxyXG4gICAgfTtcclxuICB9LFxyXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBvblJvd1NlbGVjdGlvbkNoYW5nZTogbWFrZVN0YXRlVXBkYXRlcigncm93U2VsZWN0aW9uJywgdGFibGUpLFxyXG4gICAgICBlbmFibGVSb3dTZWxlY3Rpb246IHRydWUsXHJcbiAgICAgIGVuYWJsZU11bHRpUm93U2VsZWN0aW9uOiB0cnVlLFxyXG4gICAgICBlbmFibGVTdWJSb3dTZWxlY3Rpb246IHRydWVcclxuICAgICAgLy8gZW5hYmxlR3JvdXBpbmdSb3dTZWxlY3Rpb246IGZhbHNlLFxyXG4gICAgICAvLyBpc0FkZGl0aXZlU2VsZWN0RXZlbnQ6IChlOiB1bmtub3duKSA9PiAhIWUubWV0YUtleSxcclxuICAgICAgLy8gaXNJbmNsdXNpdmVTZWxlY3RFdmVudDogKGU6IHVua25vd24pID0+ICEhZS5zaGlmdEtleSxcclxuICAgIH07XHJcbiAgfSxcclxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xyXG4gICAgdGFibGUuc2V0Um93U2VsZWN0aW9uID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uUm93U2VsZWN0aW9uQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uUm93U2VsZWN0aW9uQ2hhbmdlKHVwZGF0ZXIpO1xyXG4gICAgdGFibGUucmVzZXRSb3dTZWxlY3Rpb24gPSBkZWZhdWx0U3RhdGUgPT4ge1xyXG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRyO1xyXG4gICAgICByZXR1cm4gdGFibGUuc2V0Um93U2VsZWN0aW9uKGRlZmF1bHRTdGF0ZSA/IHt9IDogKF90YWJsZSRpbml0aWFsU3RhdGUkciA9IHRhYmxlLmluaXRpYWxTdGF0ZS5yb3dTZWxlY3Rpb24pICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJHIgOiB7fSk7XHJcbiAgICB9O1xyXG4gICAgdGFibGUudG9nZ2xlQWxsUm93c1NlbGVjdGVkID0gdmFsdWUgPT4ge1xyXG4gICAgICB0YWJsZS5zZXRSb3dTZWxlY3Rpb24ob2xkID0+IHtcclxuICAgICAgICB2YWx1ZSA9IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6ICF0YWJsZS5nZXRJc0FsbFJvd3NTZWxlY3RlZCgpO1xyXG4gICAgICAgIGNvbnN0IHJvd1NlbGVjdGlvbiA9IHtcclxuICAgICAgICAgIC4uLm9sZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcHJlR3JvdXBlZEZsYXRSb3dzID0gdGFibGUuZ2V0UHJlR3JvdXBlZFJvd01vZGVsKCkuZmxhdFJvd3M7XHJcblxyXG4gICAgICAgIC8vIFdlIGRvbid0IHVzZSBgbXV0YXRlUm93SXNTZWxlY3RlZGAgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cclxuICAgICAgICAvLyBBbGwgb2YgdGhlIHJvd3MgYXJlIGZsYXQgYWxyZWFkeSwgc28gaXQgd291bGRuJ3QgYmUgd29ydGggaXRcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgIHByZUdyb3VwZWRGbGF0Um93cy5mb3JFYWNoKHJvdyA9PiB7XHJcbiAgICAgICAgICAgIGlmICghcm93LmdldENhblNlbGVjdCgpKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJvd1NlbGVjdGlvbltyb3cuaWRdID0gdHJ1ZTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwcmVHcm91cGVkRmxhdFJvd3MuZm9yRWFjaChyb3cgPT4ge1xyXG4gICAgICAgICAgICBkZWxldGUgcm93U2VsZWN0aW9uW3Jvdy5pZF07XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJvd1NlbGVjdGlvbjtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgdGFibGUudG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZCA9IHZhbHVlID0+IHRhYmxlLnNldFJvd1NlbGVjdGlvbihvbGQgPT4ge1xyXG4gICAgICBjb25zdCByZXNvbHZlZFZhbHVlID0gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyA/IHZhbHVlIDogIXRhYmxlLmdldElzQWxsUGFnZVJvd3NTZWxlY3RlZCgpO1xyXG4gICAgICBjb25zdCByb3dTZWxlY3Rpb24gPSB7XHJcbiAgICAgICAgLi4ub2xkXHJcbiAgICAgIH07XHJcbiAgICAgIHRhYmxlLmdldFJvd01vZGVsKCkucm93cy5mb3JFYWNoKHJvdyA9PiB7XHJcbiAgICAgICAgbXV0YXRlUm93SXNTZWxlY3RlZChyb3dTZWxlY3Rpb24sIHJvdy5pZCwgcmVzb2x2ZWRWYWx1ZSwgdHJ1ZSwgdGFibGUpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHJvd1NlbGVjdGlvbjtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGFkZFJvd1NlbGVjdGlvblJhbmdlOiByb3dJZCA9PiB7XHJcbiAgICAvLyAgIGNvbnN0IHtcclxuICAgIC8vICAgICByb3dzLFxyXG4gICAgLy8gICAgIHJvd3NCeUlkLFxyXG4gICAgLy8gICAgIG9wdGlvbnM6IHsgc2VsZWN0R3JvdXBpbmdSb3dzLCBzZWxlY3RTdWJSb3dzIH0sXHJcbiAgICAvLyAgIH0gPSB0YWJsZVxyXG5cclxuICAgIC8vICAgY29uc3QgZmluZFNlbGVjdGVkUm93ID0gKHJvd3M6IFJvd1tdKSA9PiB7XHJcbiAgICAvLyAgICAgbGV0IGZvdW5kXHJcbiAgICAvLyAgICAgcm93cy5maW5kKGQgPT4ge1xyXG4gICAgLy8gICAgICAgaWYgKGQuZ2V0SXNTZWxlY3RlZCgpKSB7XHJcbiAgICAvLyAgICAgICAgIGZvdW5kID0gZFxyXG4gICAgLy8gICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgLy8gICAgICAgfVxyXG4gICAgLy8gICAgICAgY29uc3Qgc3ViRm91bmQgPSBmaW5kU2VsZWN0ZWRSb3coZC5zdWJSb3dzIHx8IFtdKVxyXG4gICAgLy8gICAgICAgaWYgKHN1YkZvdW5kKSB7XHJcbiAgICAvLyAgICAgICAgIGZvdW5kID0gc3ViRm91bmRcclxuICAgIC8vICAgICAgICAgcmV0dXJuIHRydWVcclxuICAgIC8vICAgICAgIH1cclxuICAgIC8vICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgLy8gICAgIH0pXHJcbiAgICAvLyAgICAgcmV0dXJuIGZvdW5kXHJcbiAgICAvLyAgIH1cclxuXHJcbiAgICAvLyAgIGNvbnN0IGZpcnN0Um93ID0gZmluZFNlbGVjdGVkUm93KHJvd3MpIHx8IHJvd3NbMF1cclxuICAgIC8vICAgY29uc3QgbGFzdFJvdyA9IHJvd3NCeUlkW3Jvd0lkXVxyXG5cclxuICAgIC8vICAgbGV0IGluY2x1ZGUgPSBmYWxzZVxyXG4gICAgLy8gICBjb25zdCBzZWxlY3RlZFJvd0lkcyA9IHt9XHJcblxyXG4gICAgLy8gICBjb25zdCBhZGRSb3cgPSAocm93OiBSb3cpID0+IHtcclxuICAgIC8vICAgICBtdXRhdGVSb3dJc1NlbGVjdGVkKHNlbGVjdGVkUm93SWRzLCByb3cuaWQsIHRydWUsIHtcclxuICAgIC8vICAgICAgIHJvd3NCeUlkLFxyXG4gICAgLy8gICAgICAgc2VsZWN0R3JvdXBpbmdSb3dzOiBzZWxlY3RHcm91cGluZ1Jvd3MhLFxyXG4gICAgLy8gICAgICAgc2VsZWN0U3ViUm93czogc2VsZWN0U3ViUm93cyEsXHJcbiAgICAvLyAgICAgfSlcclxuICAgIC8vICAgfVxyXG5cclxuICAgIC8vICAgdGFibGUucm93cy5mb3JFYWNoKHJvdyA9PiB7XHJcbiAgICAvLyAgICAgY29uc3QgaXNGaXJzdFJvdyA9IHJvdy5pZCA9PT0gZmlyc3RSb3cuaWRcclxuICAgIC8vICAgICBjb25zdCBpc0xhc3RSb3cgPSByb3cuaWQgPT09IGxhc3RSb3cuaWRcclxuXHJcbiAgICAvLyAgICAgaWYgKGlzRmlyc3RSb3cgfHwgaXNMYXN0Um93KSB7XHJcbiAgICAvLyAgICAgICBpZiAoIWluY2x1ZGUpIHtcclxuICAgIC8vICAgICAgICAgaW5jbHVkZSA9IHRydWVcclxuICAgIC8vICAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZSkge1xyXG4gICAgLy8gICAgICAgICBhZGRSb3cocm93KVxyXG4gICAgLy8gICAgICAgICBpbmNsdWRlID0gZmFsc2VcclxuICAgIC8vICAgICAgIH1cclxuICAgIC8vICAgICB9XHJcblxyXG4gICAgLy8gICAgIGlmIChpbmNsdWRlKSB7XHJcbiAgICAvLyAgICAgICBhZGRSb3cocm93KVxyXG4gICAgLy8gICAgIH1cclxuICAgIC8vICAgfSlcclxuXHJcbiAgICAvLyAgIHRhYmxlLnNldFJvd1NlbGVjdGlvbihzZWxlY3RlZFJvd0lkcylcclxuICAgIC8vIH0sXHJcbiAgICB0YWJsZS5nZXRQcmVTZWxlY3RlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0Q29yZVJvd01vZGVsKCk7XHJcbiAgICB0YWJsZS5nZXRTZWxlY3RlZFJvd01vZGVsID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5yb3dTZWxlY3Rpb24sIHRhYmxlLmdldENvcmVSb3dNb2RlbCgpXSwgKHJvd1NlbGVjdGlvbiwgcm93TW9kZWwpID0+IHtcclxuICAgICAgaWYgKCFPYmplY3Qua2V5cyhyb3dTZWxlY3Rpb24pLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICByb3dzOiBbXSxcclxuICAgICAgICAgIGZsYXRSb3dzOiBbXSxcclxuICAgICAgICAgIHJvd3NCeUlkOiB7fVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNlbGVjdFJvd3NGbih0YWJsZSwgcm93TW9kZWwpO1xyXG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0U2VsZWN0ZWRSb3dNb2RlbCcpKTtcclxuICAgIHRhYmxlLmdldEZpbHRlcmVkU2VsZWN0ZWRSb3dNb2RlbCA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkucm93U2VsZWN0aW9uLCB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCldLCAocm93U2VsZWN0aW9uLCByb3dNb2RlbCkgPT4ge1xyXG4gICAgICBpZiAoIU9iamVjdC5rZXlzKHJvd1NlbGVjdGlvbikubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHJvd3M6IFtdLFxyXG4gICAgICAgICAgZmxhdFJvd3M6IFtdLFxyXG4gICAgICAgICAgcm93c0J5SWQ6IHt9XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc2VsZWN0Um93c0ZuKHRhYmxlLCByb3dNb2RlbCk7XHJcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRGaWx0ZXJlZFNlbGVjdGVkUm93TW9kZWwnKSk7XHJcbiAgICB0YWJsZS5nZXRHcm91cGVkU2VsZWN0ZWRSb3dNb2RlbCA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkucm93U2VsZWN0aW9uLCB0YWJsZS5nZXRTb3J0ZWRSb3dNb2RlbCgpXSwgKHJvd1NlbGVjdGlvbiwgcm93TW9kZWwpID0+IHtcclxuICAgICAgaWYgKCFPYmplY3Qua2V5cyhyb3dTZWxlY3Rpb24pLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICByb3dzOiBbXSxcclxuICAgICAgICAgIGZsYXRSb3dzOiBbXSxcclxuICAgICAgICAgIHJvd3NCeUlkOiB7fVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNlbGVjdFJvd3NGbih0YWJsZSwgcm93TW9kZWwpO1xyXG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0R3JvdXBlZFNlbGVjdGVkUm93TW9kZWwnKSk7XHJcblxyXG4gICAgLy8vXHJcblxyXG4gICAgLy8gZ2V0R3JvdXBpbmdSb3dDYW5TZWxlY3Q6IHJvd0lkID0+IHtcclxuICAgIC8vICAgY29uc3Qgcm93ID0gdGFibGUuZ2V0Um93KHJvd0lkKVxyXG5cclxuICAgIC8vICAgaWYgKCFyb3cpIHtcclxuICAgIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoKVxyXG4gICAgLy8gICB9XHJcblxyXG4gICAgLy8gICBpZiAodHlwZW9mIHRhYmxlLm9wdGlvbnMuZW5hYmxlR3JvdXBpbmdSb3dTZWxlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcclxuICAgIC8vICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5lbmFibGVHcm91cGluZ1Jvd1NlbGVjdGlvbihyb3cpXHJcbiAgICAvLyAgIH1cclxuXHJcbiAgICAvLyAgIHJldHVybiB0YWJsZS5vcHRpb25zLmVuYWJsZUdyb3VwaW5nUm93U2VsZWN0aW9uID8/IGZhbHNlXHJcbiAgICAvLyB9LFxyXG5cclxuICAgIHRhYmxlLmdldElzQWxsUm93c1NlbGVjdGVkID0gKCkgPT4ge1xyXG4gICAgICBjb25zdCBwcmVHcm91cGVkRmxhdFJvd3MgPSB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCkuZmxhdFJvd3M7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICByb3dTZWxlY3Rpb25cclxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCk7XHJcbiAgICAgIGxldCBpc0FsbFJvd3NTZWxlY3RlZCA9IEJvb2xlYW4ocHJlR3JvdXBlZEZsYXRSb3dzLmxlbmd0aCAmJiBPYmplY3Qua2V5cyhyb3dTZWxlY3Rpb24pLmxlbmd0aCk7XHJcbiAgICAgIGlmIChpc0FsbFJvd3NTZWxlY3RlZCkge1xyXG4gICAgICAgIGlmIChwcmVHcm91cGVkRmxhdFJvd3Muc29tZShyb3cgPT4gcm93LmdldENhblNlbGVjdCgpICYmICFyb3dTZWxlY3Rpb25bcm93LmlkXSkpIHtcclxuICAgICAgICAgIGlzQWxsUm93c1NlbGVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBpc0FsbFJvd3NTZWxlY3RlZDtcclxuICAgIH07XHJcbiAgICB0YWJsZS5nZXRJc0FsbFBhZ2VSb3dzU2VsZWN0ZWQgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHBhZ2luYXRpb25GbGF0Um93cyA9IHRhYmxlLmdldFBhZ2luYXRpb25Sb3dNb2RlbCgpLmZsYXRSb3dzLmZpbHRlcihyb3cgPT4gcm93LmdldENhblNlbGVjdCgpKTtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIHJvd1NlbGVjdGlvblxyXG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKTtcclxuICAgICAgbGV0IGlzQWxsUGFnZVJvd3NTZWxlY3RlZCA9ICEhcGFnaW5hdGlvbkZsYXRSb3dzLmxlbmd0aDtcclxuICAgICAgaWYgKGlzQWxsUGFnZVJvd3NTZWxlY3RlZCAmJiBwYWdpbmF0aW9uRmxhdFJvd3Muc29tZShyb3cgPT4gIXJvd1NlbGVjdGlvbltyb3cuaWRdKSkge1xyXG4gICAgICAgIGlzQWxsUGFnZVJvd3NTZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQ7XHJcbiAgICB9O1xyXG4gICAgdGFibGUuZ2V0SXNTb21lUm93c1NlbGVjdGVkID0gKCkgPT4ge1xyXG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJHJvd1NlO1xyXG4gICAgICBjb25zdCB0b3RhbFNlbGVjdGVkID0gT2JqZWN0LmtleXMoKF90YWJsZSRnZXRTdGF0ZSRyb3dTZSA9IHRhYmxlLmdldFN0YXRlKCkucm93U2VsZWN0aW9uKSAhPSBudWxsID8gX3RhYmxlJGdldFN0YXRlJHJvd1NlIDoge30pLmxlbmd0aDtcclxuICAgICAgcmV0dXJuIHRvdGFsU2VsZWN0ZWQgPiAwICYmIHRvdGFsU2VsZWN0ZWQgPCB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCkuZmxhdFJvd3MubGVuZ3RoO1xyXG4gICAgfTtcclxuICAgIHRhYmxlLmdldElzU29tZVBhZ2VSb3dzU2VsZWN0ZWQgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHBhZ2luYXRpb25GbGF0Um93cyA9IHRhYmxlLmdldFBhZ2luYXRpb25Sb3dNb2RlbCgpLmZsYXRSb3dzO1xyXG4gICAgICByZXR1cm4gdGFibGUuZ2V0SXNBbGxQYWdlUm93c1NlbGVjdGVkKCkgPyBmYWxzZSA6IHBhZ2luYXRpb25GbGF0Um93cy5maWx0ZXIocm93ID0+IHJvdy5nZXRDYW5TZWxlY3QoKSkuc29tZShkID0+IGQuZ2V0SXNTZWxlY3RlZCgpIHx8IGQuZ2V0SXNTb21lU2VsZWN0ZWQoKSk7XHJcbiAgICB9O1xyXG4gICAgdGFibGUuZ2V0VG9nZ2xlQWxsUm93c1NlbGVjdGVkSGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgcmV0dXJuIGUgPT4ge1xyXG4gICAgICAgIHRhYmxlLnRvZ2dsZUFsbFJvd3NTZWxlY3RlZChlLnRhcmdldC5jaGVja2VkKTtcclxuICAgICAgfTtcclxuICAgIH07XHJcbiAgICB0YWJsZS5nZXRUb2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkSGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgcmV0dXJuIGUgPT4ge1xyXG4gICAgICAgIHRhYmxlLnRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWQoZS50YXJnZXQuY2hlY2tlZCk7XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgY3JlYXRlUm93OiAocm93LCB0YWJsZSkgPT4ge1xyXG4gICAgcm93LnRvZ2dsZVNlbGVjdGVkID0gKHZhbHVlLCBvcHRzKSA9PiB7XHJcbiAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSByb3cuZ2V0SXNTZWxlY3RlZCgpO1xyXG4gICAgICB0YWJsZS5zZXRSb3dTZWxlY3Rpb24ob2xkID0+IHtcclxuICAgICAgICB2YXIgX29wdHMkc2VsZWN0Q2hpbGRyZW47XHJcbiAgICAgICAgdmFsdWUgPSB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnID8gdmFsdWUgOiAhaXNTZWxlY3RlZDtcclxuICAgICAgICBpZiAocm93LmdldENhblNlbGVjdCgpICYmIGlzU2VsZWN0ZWQgPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICByZXR1cm4gb2xkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzZWxlY3RlZFJvd0lkcyA9IHtcclxuICAgICAgICAgIC4uLm9sZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbXV0YXRlUm93SXNTZWxlY3RlZChzZWxlY3RlZFJvd0lkcywgcm93LmlkLCB2YWx1ZSwgKF9vcHRzJHNlbGVjdENoaWxkcmVuID0gb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5zZWxlY3RDaGlsZHJlbikgIT0gbnVsbCA/IF9vcHRzJHNlbGVjdENoaWxkcmVuIDogdHJ1ZSwgdGFibGUpO1xyXG4gICAgICAgIHJldHVybiBzZWxlY3RlZFJvd0lkcztcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcm93LmdldElzU2VsZWN0ZWQgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICByb3dTZWxlY3Rpb25cclxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCk7XHJcbiAgICAgIHJldHVybiBpc1Jvd1NlbGVjdGVkKHJvdywgcm93U2VsZWN0aW9uKTtcclxuICAgIH07XHJcbiAgICByb3cuZ2V0SXNTb21lU2VsZWN0ZWQgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICByb3dTZWxlY3Rpb25cclxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCk7XHJcbiAgICAgIHJldHVybiBpc1N1YlJvd1NlbGVjdGVkKHJvdywgcm93U2VsZWN0aW9uKSA9PT0gJ3NvbWUnO1xyXG4gICAgfTtcclxuICAgIHJvdy5nZXRJc0FsbFN1YlJvd3NTZWxlY3RlZCA9ICgpID0+IHtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIHJvd1NlbGVjdGlvblxyXG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKTtcclxuICAgICAgcmV0dXJuIGlzU3ViUm93U2VsZWN0ZWQocm93LCByb3dTZWxlY3Rpb24pID09PSAnYWxsJztcclxuICAgIH07XHJcbiAgICByb3cuZ2V0Q2FuU2VsZWN0ID0gKCkgPT4ge1xyXG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZW5hYmxlO1xyXG4gICAgICBpZiAodHlwZW9mIHRhYmxlLm9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uKHJvdyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZVJvd1NlbGVjdGlvbikgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWU7XHJcbiAgICB9O1xyXG4gICAgcm93LmdldENhblNlbGVjdFN1YlJvd3MgPSAoKSA9PiB7XHJcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRlbmFibGUyO1xyXG4gICAgICBpZiAodHlwZW9mIHRhYmxlLm9wdGlvbnMuZW5hYmxlU3ViUm93U2VsZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuZW5hYmxlU3ViUm93U2VsZWN0aW9uKHJvdyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRlbmFibGUyID0gdGFibGUub3B0aW9ucy5lbmFibGVTdWJSb3dTZWxlY3Rpb24pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUyIDogdHJ1ZTtcclxuICAgIH07XHJcbiAgICByb3cuZ2V0Q2FuTXVsdGlTZWxlY3QgPSAoKSA9PiB7XHJcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRlbmFibGUzO1xyXG4gICAgICBpZiAodHlwZW9mIHRhYmxlLm9wdGlvbnMuZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5lbmFibGVNdWx0aVJvd1NlbGVjdGlvbihyb3cpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZW5hYmxlMyA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb24pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUzIDogdHJ1ZTtcclxuICAgIH07XHJcbiAgICByb3cuZ2V0VG9nZ2xlU2VsZWN0ZWRIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICBjb25zdCBjYW5TZWxlY3QgPSByb3cuZ2V0Q2FuU2VsZWN0KCk7XHJcbiAgICAgIHJldHVybiBlID0+IHtcclxuICAgICAgICB2YXIgX3RhcmdldDtcclxuICAgICAgICBpZiAoIWNhblNlbGVjdCkgcmV0dXJuO1xyXG4gICAgICAgIHJvdy50b2dnbGVTZWxlY3RlZCgoX3RhcmdldCA9IGUudGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX3RhcmdldC5jaGVja2VkKTtcclxuICAgICAgfTtcclxuICAgIH07XHJcbiAgfVxyXG59O1xyXG5jb25zdCBtdXRhdGVSb3dJc1NlbGVjdGVkID0gKHNlbGVjdGVkUm93SWRzLCBpZCwgdmFsdWUsIGluY2x1ZGVDaGlsZHJlbiwgdGFibGUpID0+IHtcclxuICB2YXIgX3JvdyRzdWJSb3dzO1xyXG4gIGNvbnN0IHJvdyA9IHRhYmxlLmdldFJvdyhpZCwgdHJ1ZSk7XHJcblxyXG4gIC8vIGNvbnN0IGlzR3JvdXBlZCA9IHJvdy5nZXRJc0dyb3VwZWQoKVxyXG5cclxuICAvLyBpZiAoIC8vIFRPRE86IGVuZm9yY2UgZ3JvdXBpbmcgcm93IHNlbGVjdGlvbiBydWxlc1xyXG4gIC8vICAgIWlzR3JvdXBlZCB8fFxyXG4gIC8vICAgKGlzR3JvdXBlZCAmJiB0YWJsZS5vcHRpb25zLmVuYWJsZUdyb3VwaW5nUm93U2VsZWN0aW9uKVxyXG4gIC8vICkge1xyXG4gIGlmICh2YWx1ZSkge1xyXG4gICAgaWYgKCFyb3cuZ2V0Q2FuTXVsdGlTZWxlY3QoKSkge1xyXG4gICAgICBPYmplY3Qua2V5cyhzZWxlY3RlZFJvd0lkcykuZm9yRWFjaChrZXkgPT4gZGVsZXRlIHNlbGVjdGVkUm93SWRzW2tleV0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHJvdy5nZXRDYW5TZWxlY3QoKSkge1xyXG4gICAgICBzZWxlY3RlZFJvd0lkc1tpZF0gPSB0cnVlO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBkZWxldGUgc2VsZWN0ZWRSb3dJZHNbaWRdO1xyXG4gIH1cclxuICAvLyB9XHJcblxyXG4gIGlmIChpbmNsdWRlQ2hpbGRyZW4gJiYgKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGggJiYgcm93LmdldENhblNlbGVjdFN1YlJvd3MoKSkge1xyXG4gICAgcm93LnN1YlJvd3MuZm9yRWFjaChyb3cgPT4gbXV0YXRlUm93SXNTZWxlY3RlZChzZWxlY3RlZFJvd0lkcywgcm93LmlkLCB2YWx1ZSwgaW5jbHVkZUNoaWxkcmVuLCB0YWJsZSkpO1xyXG4gIH1cclxufTtcclxuZnVuY3Rpb24gc2VsZWN0Um93c0ZuKHRhYmxlLCByb3dNb2RlbCkge1xyXG4gIGNvbnN0IHJvd1NlbGVjdGlvbiA9IHRhYmxlLmdldFN0YXRlKCkucm93U2VsZWN0aW9uO1xyXG4gIGNvbnN0IG5ld1NlbGVjdGVkRmxhdFJvd3MgPSBbXTtcclxuICBjb25zdCBuZXdTZWxlY3RlZFJvd3NCeUlkID0ge307XHJcblxyXG4gIC8vIEZpbHRlcnMgdG9wIGxldmVsIGFuZCBuZXN0ZWQgcm93c1xyXG4gIGNvbnN0IHJlY3Vyc2VSb3dzID0gZnVuY3Rpb24gKHJvd3MsIGRlcHRoKSB7XHJcbiAgICByZXR1cm4gcm93cy5tYXAocm93ID0+IHtcclxuICAgICAgdmFyIF9yb3ckc3ViUm93czI7XHJcbiAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBpc1Jvd1NlbGVjdGVkKHJvdywgcm93U2VsZWN0aW9uKTtcclxuICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcclxuICAgICAgICBuZXdTZWxlY3RlZEZsYXRSb3dzLnB1c2gocm93KTtcclxuICAgICAgICBuZXdTZWxlY3RlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKChfcm93JHN1YlJvd3MyID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzMi5sZW5ndGgpIHtcclxuICAgICAgICByb3cgPSB7XHJcbiAgICAgICAgICAuLi5yb3csXHJcbiAgICAgICAgICBzdWJSb3dzOiByZWN1cnNlUm93cyhyb3cuc3ViUm93cylcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc1NlbGVjdGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHJvdztcclxuICAgICAgfVxyXG4gICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xyXG4gIH07XHJcbiAgcmV0dXJuIHtcclxuICAgIHJvd3M6IHJlY3Vyc2VSb3dzKHJvd01vZGVsLnJvd3MpLFxyXG4gICAgZmxhdFJvd3M6IG5ld1NlbGVjdGVkRmxhdFJvd3MsXHJcbiAgICByb3dzQnlJZDogbmV3U2VsZWN0ZWRSb3dzQnlJZFxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gaXNSb3dTZWxlY3RlZChyb3csIHNlbGVjdGlvbikge1xyXG4gIHZhciBfc2VsZWN0aW9uJHJvdyRpZDtcclxuICByZXR1cm4gKF9zZWxlY3Rpb24kcm93JGlkID0gc2VsZWN0aW9uW3Jvdy5pZF0pICE9IG51bGwgPyBfc2VsZWN0aW9uJHJvdyRpZCA6IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGlzU3ViUm93U2VsZWN0ZWQocm93LCBzZWxlY3Rpb24sIHRhYmxlKSB7XHJcbiAgdmFyIF9yb3ckc3ViUm93czM7XHJcbiAgaWYgKCEoKF9yb3ckc3ViUm93czMgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MzLmxlbmd0aCkpIHJldHVybiBmYWxzZTtcclxuICBsZXQgYWxsQ2hpbGRyZW5TZWxlY3RlZCA9IHRydWU7XHJcbiAgbGV0IHNvbWVTZWxlY3RlZCA9IGZhbHNlO1xyXG4gIHJvdy5zdWJSb3dzLmZvckVhY2goc3ViUm93ID0+IHtcclxuICAgIC8vIEJhaWwgb3V0IGVhcmx5IGlmIHdlIGtub3cgYm90aCBvZiB0aGVzZVxyXG4gICAgaWYgKHNvbWVTZWxlY3RlZCAmJiAhYWxsQ2hpbGRyZW5TZWxlY3RlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoc3ViUm93LmdldENhblNlbGVjdCgpKSB7XHJcbiAgICAgIGlmIChpc1Jvd1NlbGVjdGVkKHN1YlJvdywgc2VsZWN0aW9uKSkge1xyXG4gICAgICAgIHNvbWVTZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWxsQ2hpbGRyZW5TZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgcm93IHNlbGVjdGlvbiBvZiBuZXN0ZWQgc3Vicm93c1xyXG4gICAgaWYgKHN1YlJvdy5zdWJSb3dzICYmIHN1YlJvdy5zdWJSb3dzLmxlbmd0aCkge1xyXG4gICAgICBjb25zdCBzdWJSb3dDaGlsZHJlblNlbGVjdGVkID0gaXNTdWJSb3dTZWxlY3RlZChzdWJSb3csIHNlbGVjdGlvbik7XHJcbiAgICAgIGlmIChzdWJSb3dDaGlsZHJlblNlbGVjdGVkID09PSAnYWxsJykge1xyXG4gICAgICAgIHNvbWVTZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSBpZiAoc3ViUm93Q2hpbGRyZW5TZWxlY3RlZCA9PT0gJ3NvbWUnKSB7XHJcbiAgICAgICAgc29tZVNlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICBhbGxDaGlsZHJlblNlbGVjdGVkID0gZmFsc2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWxsQ2hpbGRyZW5TZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIGFsbENoaWxkcmVuU2VsZWN0ZWQgPyAnYWxsJyA6IHNvbWVTZWxlY3RlZCA/ICdzb21lJyA6IGZhbHNlO1xyXG59XHJcblxyXG5jb25zdCByZVNwbGl0QWxwaGFOdW1lcmljID0gLyhbMC05XSspL2dtO1xyXG5jb25zdCBhbHBoYW51bWVyaWMgPSAocm93QSwgcm93QiwgY29sdW1uSWQpID0+IHtcclxuICByZXR1cm4gY29tcGFyZUFscGhhbnVtZXJpYyh0b1N0cmluZyhyb3dBLmdldFZhbHVlKGNvbHVtbklkKSkudG9Mb3dlckNhc2UoKSwgdG9TdHJpbmcocm93Qi5nZXRWYWx1ZShjb2x1bW5JZCkpLnRvTG93ZXJDYXNlKCkpO1xyXG59O1xyXG5jb25zdCBhbHBoYW51bWVyaWNDYXNlU2Vuc2l0aXZlID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XHJcbiAgcmV0dXJuIGNvbXBhcmVBbHBoYW51bWVyaWModG9TdHJpbmcocm93QS5nZXRWYWx1ZShjb2x1bW5JZCkpLCB0b1N0cmluZyhyb3dCLmdldFZhbHVlKGNvbHVtbklkKSkpO1xyXG59O1xyXG5cclxuLy8gVGhlIHRleHQgZmlsdGVyIGlzIG1vcmUgYmFzaWMgKGxlc3MgbnVtZXJpYyBzdXBwb3J0KVxyXG4vLyBidXQgaXMgbXVjaCBmYXN0ZXJcclxuY29uc3QgdGV4dCA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xyXG4gIHJldHVybiBjb21wYXJlQmFzaWModG9TdHJpbmcocm93QS5nZXRWYWx1ZShjb2x1bW5JZCkpLnRvTG93ZXJDYXNlKCksIHRvU3RyaW5nKHJvd0IuZ2V0VmFsdWUoY29sdW1uSWQpKS50b0xvd2VyQ2FzZSgpKTtcclxufTtcclxuXHJcbi8vIFRoZSB0ZXh0IGZpbHRlciBpcyBtb3JlIGJhc2ljIChsZXNzIG51bWVyaWMgc3VwcG9ydClcclxuLy8gYnV0IGlzIG11Y2ggZmFzdGVyXHJcbmNvbnN0IHRleHRDYXNlU2Vuc2l0aXZlID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XHJcbiAgcmV0dXJuIGNvbXBhcmVCYXNpYyh0b1N0cmluZyhyb3dBLmdldFZhbHVlKGNvbHVtbklkKSksIHRvU3RyaW5nKHJvd0IuZ2V0VmFsdWUoY29sdW1uSWQpKSk7XHJcbn07XHJcbmNvbnN0IGRhdGV0aW1lID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XHJcbiAgY29uc3QgYSA9IHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpO1xyXG4gIGNvbnN0IGIgPSByb3dCLmdldFZhbHVlKGNvbHVtbklkKTtcclxuXHJcbiAgLy8gQ2FuIGhhbmRsZSBudWxsaXNoIHZhbHVlc1xyXG4gIC8vIFVzZSA+IGFuZCA8IGJlY2F1c2UgPT0gKGFuZCA9PT0pIGRvZXNuJ3Qgd29yayB3aXRoXHJcbiAgLy8gRGF0ZSBvYmplY3RzICh3b3VsZCByZXF1aXJlIGNhbGxpbmcgZ2V0VGltZSgpKS5cclxuICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XHJcbn07XHJcbmNvbnN0IGJhc2ljID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XHJcbiAgcmV0dXJuIGNvbXBhcmVCYXNpYyhyb3dBLmdldFZhbHVlKGNvbHVtbklkKSwgcm93Qi5nZXRWYWx1ZShjb2x1bW5JZCkpO1xyXG59O1xyXG5cclxuLy8gVXRpbHNcclxuXHJcbmZ1bmN0aW9uIGNvbXBhcmVCYXNpYyhhLCBiKSB7XHJcbiAgcmV0dXJuIGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTE7XHJcbn1cclxuZnVuY3Rpb24gdG9TdHJpbmcoYSkge1xyXG4gIGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicpIHtcclxuICAgIGlmIChpc05hTihhKSB8fCBhID09PSBJbmZpbml0eSB8fCBhID09PSAtSW5maW5pdHkpIHtcclxuICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0cmluZyhhKTtcclxuICB9XHJcbiAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIGE7XHJcbiAgfVxyXG4gIHJldHVybiAnJztcclxufVxyXG5cclxuLy8gTWl4ZWQgc29ydGluZyBpcyBzbG93LCBidXQgdmVyeSBpbmNsdXNpdmUgb2YgbWFueSBlZGdlIGNhc2VzLlxyXG4vLyBJdCBoYW5kbGVzIG51bWJlcnMsIG1peGVkIGFscGhhbnVtZXJpYyBjb21iaW5hdGlvbnMsIGFuZCBldmVuXHJcbi8vIG51bGwsIHVuZGVmaW5lZCwgYW5kIEluZmluaXR5XHJcbmZ1bmN0aW9uIGNvbXBhcmVBbHBoYW51bWVyaWMoYVN0ciwgYlN0cikge1xyXG4gIC8vIFNwbGl0IG9uIG51bWJlciBncm91cHMsIGJ1dCBrZWVwIHRoZSBkZWxpbWl0ZXJcclxuICAvLyBUaGVuIHJlbW92ZSBmYWxzZXkgc3BsaXQgdmFsdWVzXHJcbiAgY29uc3QgYSA9IGFTdHIuc3BsaXQocmVTcGxpdEFscGhhTnVtZXJpYykuZmlsdGVyKEJvb2xlYW4pO1xyXG4gIGNvbnN0IGIgPSBiU3RyLnNwbGl0KHJlU3BsaXRBbHBoYU51bWVyaWMpLmZpbHRlcihCb29sZWFuKTtcclxuXHJcbiAgLy8gV2hpbGVcclxuICB3aGlsZSAoYS5sZW5ndGggJiYgYi5sZW5ndGgpIHtcclxuICAgIGNvbnN0IGFhID0gYS5zaGlmdCgpO1xyXG4gICAgY29uc3QgYmIgPSBiLnNoaWZ0KCk7XHJcbiAgICBjb25zdCBhbiA9IHBhcnNlSW50KGFhLCAxMCk7XHJcbiAgICBjb25zdCBibiA9IHBhcnNlSW50KGJiLCAxMCk7XHJcbiAgICBjb25zdCBjb21ibyA9IFthbiwgYm5dLnNvcnQoKTtcclxuXHJcbiAgICAvLyBCb3RoIGFyZSBzdHJpbmdcclxuICAgIGlmIChpc05hTihjb21ib1swXSkpIHtcclxuICAgICAgaWYgKGFhID4gYmIpIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYmIgPiBhYSkge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgICAgfVxyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBPbmUgaXMgYSBzdHJpbmcsIG9uZSBpcyBhIG51bWJlclxyXG4gICAgaWYgKGlzTmFOKGNvbWJvWzFdKSkge1xyXG4gICAgICByZXR1cm4gaXNOYU4oYW4pID8gLTEgOiAxO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEJvdGggYXJlIG51bWJlcnNcclxuICAgIGlmIChhbiA+IGJuKSB7XHJcbiAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgaWYgKGJuID4gYW4pIHtcclxuICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcclxufVxyXG5cclxuLy8gRXhwb3J0c1xyXG5cclxuY29uc3Qgc29ydGluZ0ZucyA9IHtcclxuICBhbHBoYW51bWVyaWMsXHJcbiAgYWxwaGFudW1lcmljQ2FzZVNlbnNpdGl2ZSxcclxuICB0ZXh0LFxyXG4gIHRleHRDYXNlU2Vuc2l0aXZlLFxyXG4gIGRhdGV0aW1lLFxyXG4gIGJhc2ljXHJcbn07XHJcblxyXG4vL1xyXG5cclxuY29uc3QgUm93U29ydGluZyA9IHtcclxuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHNvcnRpbmc6IFtdLFxyXG4gICAgICAuLi5zdGF0ZVxyXG4gICAgfTtcclxuICB9LFxyXG4gIGdldERlZmF1bHRDb2x1bW5EZWY6ICgpID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHNvcnRpbmdGbjogJ2F1dG8nLFxyXG4gICAgICBzb3J0VW5kZWZpbmVkOiAxXHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG9uU29ydGluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignc29ydGluZycsIHRhYmxlKSxcclxuICAgICAgaXNNdWx0aVNvcnRFdmVudDogZSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGUuc2hpZnRLZXk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSxcclxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XHJcbiAgICBjb2x1bW4uZ2V0QXV0b1NvcnRpbmdGbiA9ICgpID0+IHtcclxuICAgICAgY29uc3QgZmlyc3RSb3dzID0gdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpLmZsYXRSb3dzLnNsaWNlKDEwKTtcclxuICAgICAgbGV0IGlzU3RyaW5nID0gZmFsc2U7XHJcbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIGZpcnN0Um93cykge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gcm93ID09IG51bGwgPyB2b2lkIDAgOiByb3cuZ2V0VmFsdWUoY29sdW1uLmlkKTtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0ZV0nKSB7XHJcbiAgICAgICAgICByZXR1cm4gc29ydGluZ0Zucy5kYXRldGltZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIGlzU3RyaW5nID0gdHJ1ZTtcclxuICAgICAgICAgIGlmICh2YWx1ZS5zcGxpdChyZVNwbGl0QWxwaGFOdW1lcmljKS5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzb3J0aW5nRm5zLmFscGhhbnVtZXJpYztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzU3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHNvcnRpbmdGbnMudGV4dDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc29ydGluZ0Zucy5iYXNpYztcclxuICAgIH07XHJcbiAgICBjb2x1bW4uZ2V0QXV0b1NvcnREaXIgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGZpcnN0Um93ID0gdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpLmZsYXRSb3dzWzBdO1xyXG4gICAgICBjb25zdCB2YWx1ZSA9IGZpcnN0Um93ID09IG51bGwgPyB2b2lkIDAgOiBmaXJzdFJvdy5nZXRWYWx1ZShjb2x1bW4uaWQpO1xyXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiAnYXNjJztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gJ2Rlc2MnO1xyXG4gICAgfTtcclxuICAgIGNvbHVtbi5nZXRTb3J0aW5nRm4gPSAoKSA9PiB7XHJcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRzb3J0aW4sIF90YWJsZSRvcHRpb25zJHNvcnRpbjI7XHJcbiAgICAgIGlmICghY29sdW1uKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oY29sdW1uLmNvbHVtbkRlZi5zb3J0aW5nRm4pID8gY29sdW1uLmNvbHVtbkRlZi5zb3J0aW5nRm4gOiBjb2x1bW4uY29sdW1uRGVmLnNvcnRpbmdGbiA9PT0gJ2F1dG8nID8gY29sdW1uLmdldEF1dG9Tb3J0aW5nRm4oKSA6IChfdGFibGUkb3B0aW9ucyRzb3J0aW4gPSAoX3RhYmxlJG9wdGlvbnMkc29ydGluMiA9IHRhYmxlLm9wdGlvbnMuc29ydGluZ0ZucykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRvcHRpb25zJHNvcnRpbjJbY29sdW1uLmNvbHVtbkRlZi5zb3J0aW5nRm5dKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkc29ydGluIDogc29ydGluZ0Zuc1tjb2x1bW4uY29sdW1uRGVmLnNvcnRpbmdGbl07XHJcbiAgICB9O1xyXG4gICAgY29sdW1uLnRvZ2dsZVNvcnRpbmcgPSAoZGVzYywgbXVsdGkpID0+IHtcclxuICAgICAgLy8gaWYgKGNvbHVtbi5jb2x1bW5zLmxlbmd0aCkge1xyXG4gICAgICAvLyAgIGNvbHVtbi5jb2x1bW5zLmZvckVhY2goKGMsIGkpID0+IHtcclxuICAgICAgLy8gICAgIGlmIChjLmlkKSB7XHJcbiAgICAgIC8vICAgICAgIHRhYmxlLnRvZ2dsZUNvbHVtblNvcnRpbmcoYy5pZCwgdW5kZWZpbmVkLCBtdWx0aSB8fCAhIWkpXHJcbiAgICAgIC8vICAgICB9XHJcbiAgICAgIC8vICAgfSlcclxuICAgICAgLy8gICByZXR1cm5cclxuICAgICAgLy8gfVxyXG5cclxuICAgICAgLy8gdGhpcyBuZWVkcyB0byBiZSBvdXRzaWRlIG9mIHRhYmxlLnNldFNvcnRpbmcgdG8gYmUgaW4gc3luYyB3aXRoIHJlcmVuZGVyXHJcbiAgICAgIGNvbnN0IG5leHRTb3J0aW5nT3JkZXIgPSBjb2x1bW4uZ2V0TmV4dFNvcnRpbmdPcmRlcigpO1xyXG4gICAgICBjb25zdCBoYXNNYW51YWxWYWx1ZSA9IHR5cGVvZiBkZXNjICE9PSAndW5kZWZpbmVkJyAmJiBkZXNjICE9PSBudWxsO1xyXG4gICAgICB0YWJsZS5zZXRTb3J0aW5nKG9sZCA9PiB7XHJcbiAgICAgICAgLy8gRmluZCBhbnkgZXhpc3Rpbmcgc29ydGluZyBmb3IgdGhpcyBjb2x1bW5cclxuICAgICAgICBjb25zdCBleGlzdGluZ1NvcnRpbmcgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKTtcclxuICAgICAgICBjb25zdCBleGlzdGluZ0luZGV4ID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKTtcclxuICAgICAgICBsZXQgbmV3U29ydGluZyA9IFtdO1xyXG5cclxuICAgICAgICAvLyBXaGF0IHNob3VsZCB3ZSBkbyB3aXRoIHRoaXMgc29ydCBhY3Rpb24/XHJcbiAgICAgICAgbGV0IHNvcnRBY3Rpb247XHJcbiAgICAgICAgbGV0IG5leHREZXNjID0gaGFzTWFudWFsVmFsdWUgPyBkZXNjIDogbmV4dFNvcnRpbmdPcmRlciA9PT0gJ2Rlc2MnO1xyXG5cclxuICAgICAgICAvLyBNdWx0aS1tb2RlXHJcbiAgICAgICAgaWYgKG9sZCAhPSBudWxsICYmIG9sZC5sZW5ndGggJiYgY29sdW1uLmdldENhbk11bHRpU29ydCgpICYmIG11bHRpKSB7XHJcbiAgICAgICAgICBpZiAoZXhpc3RpbmdTb3J0aW5nKSB7XHJcbiAgICAgICAgICAgIHNvcnRBY3Rpb24gPSAndG9nZ2xlJztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNvcnRBY3Rpb24gPSAnYWRkJztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gTm9ybWFsIG1vZGVcclxuICAgICAgICAgIGlmIChvbGQgIT0gbnVsbCAmJiBvbGQubGVuZ3RoICYmIGV4aXN0aW5nSW5kZXggIT09IG9sZC5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIHNvcnRBY3Rpb24gPSAncmVwbGFjZSc7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nU29ydGluZykge1xyXG4gICAgICAgICAgICBzb3J0QWN0aW9uID0gJ3RvZ2dsZSc7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzb3J0QWN0aW9uID0gJ3JlcGxhY2UnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIHRvZ2dsZSBzdGF0ZXMgdGhhdCB3aWxsIHJlbW92ZSB0aGUgc29ydGluZ1xyXG4gICAgICAgIGlmIChzb3J0QWN0aW9uID09PSAndG9nZ2xlJykge1xyXG4gICAgICAgICAgLy8gSWYgd2UgYXJlIFwiYWN0dWFsbHlcIiB0b2dnbGluZyAobm90IGEgbWFudWFsIHNldCB2YWx1ZSksIHNob3VsZCB3ZSByZW1vdmUgdGhlIHNvcnRpbmc/XHJcbiAgICAgICAgICBpZiAoIWhhc01hbnVhbFZhbHVlKSB7XHJcbiAgICAgICAgICAgIC8vIElzIG91ciBpbnRlbnRpb24gdG8gcmVtb3ZlP1xyXG4gICAgICAgICAgICBpZiAoIW5leHRTb3J0aW5nT3JkZXIpIHtcclxuICAgICAgICAgICAgICBzb3J0QWN0aW9uID0gJ3JlbW92ZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNvcnRBY3Rpb24gPT09ICdhZGQnKSB7XHJcbiAgICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkbWF4TXVsO1xyXG4gICAgICAgICAgbmV3U29ydGluZyA9IFsuLi5vbGQsIHtcclxuICAgICAgICAgICAgaWQ6IGNvbHVtbi5pZCxcclxuICAgICAgICAgICAgZGVzYzogbmV4dERlc2NcclxuICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgLy8gVGFrZSBsYXRlc3QgbiBjb2x1bW5zXHJcbiAgICAgICAgICBuZXdTb3J0aW5nLnNwbGljZSgwLCBuZXdTb3J0aW5nLmxlbmd0aCAtICgoX3RhYmxlJG9wdGlvbnMkbWF4TXVsID0gdGFibGUub3B0aW9ucy5tYXhNdWx0aVNvcnRDb2xDb3VudCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJG1heE11bCA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzb3J0QWN0aW9uID09PSAndG9nZ2xlJykge1xyXG4gICAgICAgICAgLy8gVGhpcyBmbGlwcyAob3Igc2V0cykgdGhlXHJcbiAgICAgICAgICBuZXdTb3J0aW5nID0gb2xkLm1hcChkID0+IHtcclxuICAgICAgICAgICAgaWYgKGQuaWQgPT09IGNvbHVtbi5pZCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAuLi5kLFxyXG4gICAgICAgICAgICAgICAgZGVzYzogbmV4dERlc2NcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzb3J0QWN0aW9uID09PSAncmVtb3ZlJykge1xyXG4gICAgICAgICAgbmV3U29ydGluZyA9IG9sZC5maWx0ZXIoZCA9PiBkLmlkICE9PSBjb2x1bW4uaWQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuZXdTb3J0aW5nID0gW3tcclxuICAgICAgICAgICAgaWQ6IGNvbHVtbi5pZCxcclxuICAgICAgICAgICAgZGVzYzogbmV4dERlc2NcclxuICAgICAgICAgIH1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3U29ydGluZztcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgY29sdW1uLmdldEZpcnN0U29ydERpciA9ICgpID0+IHtcclxuICAgICAgdmFyIF9yZWYsIF9jb2x1bW4kY29sdW1uRGVmJHNvcjtcclxuICAgICAgY29uc3Qgc29ydERlc2NGaXJzdCA9IChfcmVmID0gKF9jb2x1bW4kY29sdW1uRGVmJHNvciA9IGNvbHVtbi5jb2x1bW5EZWYuc29ydERlc2NGaXJzdCkgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJHNvciA6IHRhYmxlLm9wdGlvbnMuc29ydERlc2NGaXJzdCkgIT0gbnVsbCA/IF9yZWYgOiBjb2x1bW4uZ2V0QXV0b1NvcnREaXIoKSA9PT0gJ2Rlc2MnO1xyXG4gICAgICByZXR1cm4gc29ydERlc2NGaXJzdCA/ICdkZXNjJyA6ICdhc2MnO1xyXG4gICAgfTtcclxuICAgIGNvbHVtbi5nZXROZXh0U29ydGluZ09yZGVyID0gbXVsdGkgPT4ge1xyXG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZW5hYmxlLCBfdGFibGUkb3B0aW9ucyRlbmFibGUyO1xyXG4gICAgICBjb25zdCBmaXJzdFNvcnREaXJlY3Rpb24gPSBjb2x1bW4uZ2V0Rmlyc3RTb3J0RGlyKCk7XHJcbiAgICAgIGNvbnN0IGlzU29ydGVkID0gY29sdW1uLmdldElzU29ydGVkKCk7XHJcbiAgICAgIGlmICghaXNTb3J0ZWQpIHtcclxuICAgICAgICByZXR1cm4gZmlyc3RTb3J0RGlyZWN0aW9uO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc1NvcnRlZCAhPT0gZmlyc3RTb3J0RGlyZWN0aW9uICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVTb3J0aW5nUmVtb3ZhbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWUpICYmIChcclxuICAgICAgLy8gSWYgZW5hYmxlU29ydFJlbW92ZSwgZW5hYmxlIGluIGdlbmVyYWxcclxuICAgICAgbXVsdGkgPyAoX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlTXVsdGlSZW1vdmUpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUyIDogdHJ1ZSA6IHRydWUpIC8vIElmIG11bHRpLCBkb24ndCBhbGxvdyBpZiBlbmFibGVNdWx0aVJlbW92ZSkpXHJcbiAgICAgICkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaXNTb3J0ZWQgPT09ICdkZXNjJyA/ICdhc2MnIDogJ2Rlc2MnO1xyXG4gICAgfTtcclxuICAgIGNvbHVtbi5nZXRDYW5Tb3J0ID0gKCkgPT4ge1xyXG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hLCBfdGFibGUkb3B0aW9ucyRlbmFibGUzO1xyXG4gICAgICByZXR1cm4gKChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZVNvcnRpbmcpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZTMgPSB0YWJsZS5vcHRpb25zLmVuYWJsZVNvcnRpbmcpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUzIDogdHJ1ZSkgJiYgISFjb2x1bW4uYWNjZXNzb3JGbjtcclxuICAgIH07XHJcbiAgICBjb2x1bW4uZ2V0Q2FuTXVsdGlTb3J0ID0gKCkgPT4ge1xyXG4gICAgICB2YXIgX3JlZjIsIF9jb2x1bW4kY29sdW1uRGVmJGVuYTI7XHJcbiAgICAgIHJldHVybiAoX3JlZjIgPSAoX2NvbHVtbiRjb2x1bW5EZWYkZW5hMiA9IGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlTXVsdGlTb3J0KSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hMiA6IHRhYmxlLm9wdGlvbnMuZW5hYmxlTXVsdGlTb3J0KSAhPSBudWxsID8gX3JlZjIgOiAhIWNvbHVtbi5hY2Nlc3NvckZuO1xyXG4gICAgfTtcclxuICAgIGNvbHVtbi5nZXRJc1NvcnRlZCA9ICgpID0+IHtcclxuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRzb3J0aTtcclxuICAgICAgY29uc3QgY29sdW1uU29ydCA9IChfdGFibGUkZ2V0U3RhdGUkc29ydGkgPSB0YWJsZS5nZXRTdGF0ZSgpLnNvcnRpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkc29ydGkuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCk7XHJcbiAgICAgIHJldHVybiAhY29sdW1uU29ydCA/IGZhbHNlIDogY29sdW1uU29ydC5kZXNjID8gJ2Rlc2MnIDogJ2FzYyc7XHJcbiAgICB9O1xyXG4gICAgY29sdW1uLmdldFNvcnRJbmRleCA9ICgpID0+IHtcclxuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRzb3J0aTIsIF90YWJsZSRnZXRTdGF0ZSRzb3J0aTM7XHJcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFN0YXRlJHNvcnRpMiA9IChfdGFibGUkZ2V0U3RhdGUkc29ydGkzID0gdGFibGUuZ2V0U3RhdGUoKS5zb3J0aW5nKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFN0YXRlJHNvcnRpMy5maW5kSW5kZXgoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpKSAhPSBudWxsID8gX3RhYmxlJGdldFN0YXRlJHNvcnRpMiA6IC0xO1xyXG4gICAgfTtcclxuICAgIGNvbHVtbi5jbGVhclNvcnRpbmcgPSAoKSA9PiB7XHJcbiAgICAgIC8vY2xlYXIgc29ydGluZyBmb3IganVzdCAxIGNvbHVtblxyXG4gICAgICB0YWJsZS5zZXRTb3J0aW5nKG9sZCA9PiBvbGQgIT0gbnVsbCAmJiBvbGQubGVuZ3RoID8gb2xkLmZpbHRlcihkID0+IGQuaWQgIT09IGNvbHVtbi5pZCkgOiBbXSk7XHJcbiAgICB9O1xyXG4gICAgY29sdW1uLmdldFRvZ2dsZVNvcnRpbmdIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICBjb25zdCBjYW5Tb3J0ID0gY29sdW1uLmdldENhblNvcnQoKTtcclxuICAgICAgcmV0dXJuIGUgPT4ge1xyXG4gICAgICAgIGlmICghY2FuU29ydCkgcmV0dXJuO1xyXG4gICAgICAgIGUucGVyc2lzdCA9PSBudWxsIHx8IGUucGVyc2lzdCgpO1xyXG4gICAgICAgIGNvbHVtbi50b2dnbGVTb3J0aW5nID09IG51bGwgfHwgY29sdW1uLnRvZ2dsZVNvcnRpbmcodW5kZWZpbmVkLCBjb2x1bW4uZ2V0Q2FuTXVsdGlTb3J0KCkgPyB0YWJsZS5vcHRpb25zLmlzTXVsdGlTb3J0RXZlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMuaXNNdWx0aVNvcnRFdmVudChlKSA6IGZhbHNlKTtcclxuICAgICAgfTtcclxuICAgIH07XHJcbiAgfSxcclxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xyXG4gICAgdGFibGUuc2V0U29ydGluZyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vblNvcnRpbmdDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Tb3J0aW5nQ2hhbmdlKHVwZGF0ZXIpO1xyXG4gICAgdGFibGUucmVzZXRTb3J0aW5nID0gZGVmYXVsdFN0YXRlID0+IHtcclxuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkcywgX3RhYmxlJGluaXRpYWxTdGF0ZTtcclxuICAgICAgdGFibGUuc2V0U29ydGluZyhkZWZhdWx0U3RhdGUgPyBbXSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJHMgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZSA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUuc29ydGluZykgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkcyA6IFtdKTtcclxuICAgIH07XHJcbiAgICB0YWJsZS5nZXRQcmVTb3J0ZWRSb3dNb2RlbCA9ICgpID0+IHRhYmxlLmdldEdyb3VwZWRSb3dNb2RlbCgpO1xyXG4gICAgdGFibGUuZ2V0U29ydGVkUm93TW9kZWwgPSAoKSA9PiB7XHJcbiAgICAgIGlmICghdGFibGUuX2dldFNvcnRlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0U29ydGVkUm93TW9kZWwpIHtcclxuICAgICAgICB0YWJsZS5fZ2V0U29ydGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldFNvcnRlZFJvd01vZGVsKHRhYmxlKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxTb3J0aW5nIHx8ICF0YWJsZS5fZ2V0U29ydGVkUm93TW9kZWwpIHtcclxuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlU29ydGVkUm93TW9kZWwoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGFibGUuX2dldFNvcnRlZFJvd01vZGVsKCk7XHJcbiAgICB9O1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGJ1aWx0SW5GZWF0dXJlcyA9IFtIZWFkZXJzLCBDb2x1bW5WaXNpYmlsaXR5LCBDb2x1bW5PcmRlcmluZywgQ29sdW1uUGlubmluZywgQ29sdW1uRmFjZXRpbmcsIENvbHVtbkZpbHRlcmluZywgR2xvYmFsRmFjZXRpbmcsXHJcbi8vZGVwZW5kcyBvbiBDb2x1bW5GYWNldGluZ1xyXG5HbG9iYWxGaWx0ZXJpbmcsXHJcbi8vZGVwZW5kcyBvbiBDb2x1bW5GaWx0ZXJpbmdcclxuUm93U29ydGluZywgQ29sdW1uR3JvdXBpbmcsXHJcbi8vZGVwZW5kcyBvbiBSb3dTb3J0aW5nXHJcblJvd0V4cGFuZGluZywgUm93UGFnaW5hdGlvbiwgUm93UGlubmluZywgUm93U2VsZWN0aW9uLCBDb2x1bW5TaXppbmddO1xyXG5cclxuLy9cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlKG9wdGlvbnMpIHtcclxuICB2YXIgX29wdGlvbnMkX2ZlYXR1cmVzLCBfb3B0aW9ucyRpbml0aWFsU3RhdGU7XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKG9wdGlvbnMuZGVidWdBbGwgfHwgb3B0aW9ucy5kZWJ1Z1RhYmxlKSkge1xyXG4gICAgY29uc29sZS5pbmZvKCdDcmVhdGluZyBUYWJsZSBJbnN0YW5jZS4uLicpO1xyXG4gIH1cclxuICBjb25zdCBfZmVhdHVyZXMgPSBbLi4uYnVpbHRJbkZlYXR1cmVzLCAuLi4oKF9vcHRpb25zJF9mZWF0dXJlcyA9IG9wdGlvbnMuX2ZlYXR1cmVzKSAhPSBudWxsID8gX29wdGlvbnMkX2ZlYXR1cmVzIDogW10pXTtcclxuICBsZXQgdGFibGUgPSB7XHJcbiAgICBfZmVhdHVyZXNcclxuICB9O1xyXG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0gdGFibGUuX2ZlYXR1cmVzLnJlZHVjZSgob2JqLCBmZWF0dXJlKSA9PiB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvYmosIGZlYXR1cmUuZ2V0RGVmYXVsdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGZlYXR1cmUuZ2V0RGVmYXVsdE9wdGlvbnModGFibGUpKTtcclxuICB9LCB7fSk7XHJcbiAgY29uc3QgbWVyZ2VPcHRpb25zID0gb3B0aW9ucyA9PiB7XHJcbiAgICBpZiAodGFibGUub3B0aW9ucy5tZXJnZU9wdGlvbnMpIHtcclxuICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMubWVyZ2VPcHRpb25zKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxyXG4gICAgICAuLi5vcHRpb25zXHJcbiAgICB9O1xyXG4gIH07XHJcbiAgY29uc3QgY29yZUluaXRpYWxTdGF0ZSA9IHt9O1xyXG4gIGxldCBpbml0aWFsU3RhdGUgPSB7XHJcbiAgICAuLi5jb3JlSW5pdGlhbFN0YXRlLFxyXG4gICAgLi4uKChfb3B0aW9ucyRpbml0aWFsU3RhdGUgPSBvcHRpb25zLmluaXRpYWxTdGF0ZSkgIT0gbnVsbCA/IF9vcHRpb25zJGluaXRpYWxTdGF0ZSA6IHt9KVxyXG4gIH07XHJcbiAgdGFibGUuX2ZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XHJcbiAgICB2YXIgX2ZlYXR1cmUkZ2V0SW5pdGlhbFN0O1xyXG4gICAgaW5pdGlhbFN0YXRlID0gKF9mZWF0dXJlJGdldEluaXRpYWxTdCA9IGZlYXR1cmUuZ2V0SW5pdGlhbFN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmZWF0dXJlLmdldEluaXRpYWxTdGF0ZShpbml0aWFsU3RhdGUpKSAhPSBudWxsID8gX2ZlYXR1cmUkZ2V0SW5pdGlhbFN0IDogaW5pdGlhbFN0YXRlO1xyXG4gIH0pO1xyXG4gIGNvbnN0IHF1ZXVlZCA9IFtdO1xyXG4gIGxldCBxdWV1ZWRUaW1lb3V0ID0gZmFsc2U7XHJcbiAgY29uc3QgY29yZUluc3RhbmNlID0ge1xyXG4gICAgX2ZlYXR1cmVzLFxyXG4gICAgb3B0aW9uczoge1xyXG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcclxuICAgICAgLi4ub3B0aW9uc1xyXG4gICAgfSxcclxuICAgIGluaXRpYWxTdGF0ZSxcclxuICAgIF9xdWV1ZTogY2IgPT4ge1xyXG4gICAgICBxdWV1ZWQucHVzaChjYik7XHJcbiAgICAgIGlmICghcXVldWVkVGltZW91dCkge1xyXG4gICAgICAgIHF1ZXVlZFRpbWVvdXQgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyBTY2hlZHVsZSBhIG1pY3JvdGFzayB0byBydW4gdGhlIHF1ZXVlZCBjYWxsYmFja3MgYWZ0ZXJcclxuICAgICAgICAvLyB0aGUgY3VycmVudCBjYWxsIHN0YWNrIChyZW5kZXIsIGV0YykgaGFzIGZpbmlzaGVkLlxyXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgd2hpbGUgKHF1ZXVlZC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcXVldWVkLnNoaWZ0KCkoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHF1ZXVlZFRpbWVvdXQgPSBmYWxzZTtcclxuICAgICAgICB9KS5jYXRjaChlcnJvciA9PiBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJlc2V0OiAoKSA9PiB7XHJcbiAgICAgIHRhYmxlLnNldFN0YXRlKHRhYmxlLmluaXRpYWxTdGF0ZSk7XHJcbiAgICB9LFxyXG4gICAgc2V0T3B0aW9uczogdXBkYXRlciA9PiB7XHJcbiAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIHRhYmxlLm9wdGlvbnMpO1xyXG4gICAgICB0YWJsZS5vcHRpb25zID0gbWVyZ2VPcHRpb25zKG5ld09wdGlvbnMpO1xyXG4gICAgfSxcclxuICAgIGdldFN0YXRlOiAoKSA9PiB7XHJcbiAgICAgIHJldHVybiB0YWJsZS5vcHRpb25zLnN0YXRlO1xyXG4gICAgfSxcclxuICAgIHNldFN0YXRlOiB1cGRhdGVyID0+IHtcclxuICAgICAgdGFibGUub3B0aW9ucy5vblN0YXRlQ2hhbmdlID09IG51bGwgfHwgdGFibGUub3B0aW9ucy5vblN0YXRlQ2hhbmdlKHVwZGF0ZXIpO1xyXG4gICAgfSxcclxuICAgIF9nZXRSb3dJZDogKHJvdywgaW5kZXgsIHBhcmVudCkgPT4ge1xyXG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZ2V0Um93O1xyXG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGdldFJvdyA9IHRhYmxlLm9wdGlvbnMuZ2V0Um93SWQgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMuZ2V0Um93SWQocm93LCBpbmRleCwgcGFyZW50KSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGdldFJvdyA6IGAke3BhcmVudCA/IFtwYXJlbnQuaWQsIGluZGV4XS5qb2luKCcuJykgOiBpbmRleH1gO1xyXG4gICAgfSxcclxuICAgIGdldENvcmVSb3dNb2RlbDogKCkgPT4ge1xyXG4gICAgICBpZiAoIXRhYmxlLl9nZXRDb3JlUm93TW9kZWwpIHtcclxuICAgICAgICB0YWJsZS5fZ2V0Q29yZVJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRDb3JlUm93TW9kZWwodGFibGUpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0Q29yZVJvd01vZGVsKCk7XHJcbiAgICB9LFxyXG4gICAgLy8gVGhlIGZpbmFsIGNhbGxzIHN0YXJ0IGF0IHRoZSBib3R0b20gb2YgdGhlIG1vZGVsLFxyXG4gICAgLy8gZXhwYW5kZWQgcm93cywgd2hpY2ggdGhlbiB3b3JrIHRoZWlyIHdheSB1cFxyXG5cclxuICAgIGdldFJvd01vZGVsOiAoKSA9PiB7XHJcbiAgICAgIHJldHVybiB0YWJsZS5nZXRQYWdpbmF0aW9uUm93TW9kZWwoKTtcclxuICAgIH0sXHJcbiAgICAvL2luIG5leHQgdmVyc2lvbiwgd2Ugc2hvdWxkIGp1c3QgcGFzcyBpbiB0aGUgcm93IG1vZGVsIGFzIHRoZSBvcHRpb25hbCAybmQgYXJnXHJcbiAgICBnZXRSb3c6IChpZCwgc2VhcmNoQWxsKSA9PiB7XHJcbiAgICAgIGxldCByb3cgPSAoc2VhcmNoQWxsID8gdGFibGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCkgOiB0YWJsZS5nZXRSb3dNb2RlbCgpKS5yb3dzQnlJZFtpZF07XHJcbiAgICAgIGlmICghcm93KSB7XHJcbiAgICAgICAgcm93ID0gdGFibGUuZ2V0Q29yZVJvd01vZGVsKCkucm93c0J5SWRbaWRdO1xyXG4gICAgICAgIGlmICghcm93KSB7XHJcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGdldFJvdyBjb3VsZCBub3QgZmluZCByb3cgd2l0aCBJRDogJHtpZH1gKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcm93O1xyXG4gICAgfSxcclxuICAgIF9nZXREZWZhdWx0Q29sdW1uRGVmOiBtZW1vKCgpID0+IFt0YWJsZS5vcHRpb25zLmRlZmF1bHRDb2x1bW5dLCBkZWZhdWx0Q29sdW1uID0+IHtcclxuICAgICAgdmFyIF9kZWZhdWx0Q29sdW1uO1xyXG4gICAgICBkZWZhdWx0Q29sdW1uID0gKF9kZWZhdWx0Q29sdW1uID0gZGVmYXVsdENvbHVtbikgIT0gbnVsbCA/IF9kZWZhdWx0Q29sdW1uIDoge307XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaGVhZGVyOiBwcm9wcyA9PiB7XHJcbiAgICAgICAgICBjb25zdCByZXNvbHZlZENvbHVtbkRlZiA9IHByb3BzLmhlYWRlci5jb2x1bW4uY29sdW1uRGVmO1xyXG4gICAgICAgICAgaWYgKHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yS2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvcktleTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChyZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvckZuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZENvbHVtbkRlZi5pZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gZm9vdGVyOiBwcm9wcyA9PiBwcm9wcy5oZWFkZXIuY29sdW1uLmlkLFxyXG4gICAgICAgIGNlbGw6IHByb3BzID0+IHtcclxuICAgICAgICAgIHZhciBfcHJvcHMkcmVuZGVyVmFsdWUkdG8sIF9wcm9wcyRyZW5kZXJWYWx1ZTtcclxuICAgICAgICAgIHJldHVybiAoX3Byb3BzJHJlbmRlclZhbHVlJHRvID0gKF9wcm9wcyRyZW5kZXJWYWx1ZSA9IHByb3BzLnJlbmRlclZhbHVlKCkpID09IG51bGwgfHwgX3Byb3BzJHJlbmRlclZhbHVlLnRvU3RyaW5nID09IG51bGwgPyB2b2lkIDAgOiBfcHJvcHMkcmVuZGVyVmFsdWUudG9TdHJpbmcoKSkgIT0gbnVsbCA/IF9wcm9wcyRyZW5kZXJWYWx1ZSR0byA6IG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAuLi50YWJsZS5fZmVhdHVyZXMucmVkdWNlKChvYmosIGZlYXR1cmUpID0+IHtcclxuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9iaiwgZmVhdHVyZS5nZXREZWZhdWx0Q29sdW1uRGVmID09IG51bGwgPyB2b2lkIDAgOiBmZWF0dXJlLmdldERlZmF1bHRDb2x1bW5EZWYoKSk7XHJcbiAgICAgICAgfSwge30pLFxyXG4gICAgICAgIC4uLmRlZmF1bHRDb2x1bW5cclxuICAgICAgfTtcclxuICAgIH0sIGdldE1lbW9PcHRpb25zKG9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnX2dldERlZmF1bHRDb2x1bW5EZWYnKSksXHJcbiAgICBfZ2V0Q29sdW1uRGVmczogKCkgPT4gdGFibGUub3B0aW9ucy5jb2x1bW5zLFxyXG4gICAgZ2V0QWxsQ29sdW1uczogbWVtbygoKSA9PiBbdGFibGUuX2dldENvbHVtbkRlZnMoKV0sIGNvbHVtbkRlZnMgPT4ge1xyXG4gICAgICBjb25zdCByZWN1cnNlQ29sdW1ucyA9IGZ1bmN0aW9uIChjb2x1bW5EZWZzLCBwYXJlbnQsIGRlcHRoKSB7XHJcbiAgICAgICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcclxuICAgICAgICAgIGRlcHRoID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbHVtbkRlZnMubWFwKGNvbHVtbkRlZiA9PiB7XHJcbiAgICAgICAgICBjb25zdCBjb2x1bW4gPSBjcmVhdGVDb2x1bW4odGFibGUsIGNvbHVtbkRlZiwgZGVwdGgsIHBhcmVudCk7XHJcbiAgICAgICAgICBjb25zdCBncm91cGluZ0NvbHVtbkRlZiA9IGNvbHVtbkRlZjtcclxuICAgICAgICAgIGNvbHVtbi5jb2x1bW5zID0gZ3JvdXBpbmdDb2x1bW5EZWYuY29sdW1ucyA/IHJlY3Vyc2VDb2x1bW5zKGdyb3VwaW5nQ29sdW1uRGVmLmNvbHVtbnMsIGNvbHVtbiwgZGVwdGggKyAxKSA6IFtdO1xyXG4gICAgICAgICAgcmV0dXJuIGNvbHVtbjtcclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIHJlY3Vyc2VDb2x1bW5zKGNvbHVtbkRlZnMpO1xyXG4gICAgfSwgZ2V0TWVtb09wdGlvbnMob3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRBbGxDb2x1bW5zJykpLFxyXG4gICAgZ2V0QWxsRmxhdENvbHVtbnM6IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKV0sIGFsbENvbHVtbnMgPT4ge1xyXG4gICAgICByZXR1cm4gYWxsQ29sdW1ucy5mbGF0TWFwKGNvbHVtbiA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGNvbHVtbi5nZXRGbGF0Q29sdW1ucygpO1xyXG4gICAgICB9KTtcclxuICAgIH0sIGdldE1lbW9PcHRpb25zKG9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0QWxsRmxhdENvbHVtbnMnKSksXHJcbiAgICBfZ2V0QWxsRmxhdENvbHVtbnNCeUlkOiBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxGbGF0Q29sdW1ucygpXSwgZmxhdENvbHVtbnMgPT4ge1xyXG4gICAgICByZXR1cm4gZmxhdENvbHVtbnMucmVkdWNlKChhY2MsIGNvbHVtbikgPT4ge1xyXG4gICAgICAgIGFjY1tjb2x1bW4uaWRdID0gY29sdW1uO1xyXG4gICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgIH0sIHt9KTtcclxuICAgIH0sIGdldE1lbW9PcHRpb25zKG9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0QWxsRmxhdENvbHVtbnNCeUlkJykpLFxyXG4gICAgZ2V0QWxsTGVhZkNvbHVtbnM6IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKSwgdGFibGUuX2dldE9yZGVyQ29sdW1uc0ZuKCldLCAoYWxsQ29sdW1ucywgb3JkZXJDb2x1bW5zKSA9PiB7XHJcbiAgICAgIGxldCBsZWFmQ29sdW1ucyA9IGFsbENvbHVtbnMuZmxhdE1hcChjb2x1bW4gPT4gY29sdW1uLmdldExlYWZDb2x1bW5zKCkpO1xyXG4gICAgICByZXR1cm4gb3JkZXJDb2x1bW5zKGxlYWZDb2x1bW5zKTtcclxuICAgIH0sIGdldE1lbW9PcHRpb25zKG9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0QWxsTGVhZkNvbHVtbnMnKSksXHJcbiAgICBnZXRDb2x1bW46IGNvbHVtbklkID0+IHtcclxuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuX2dldEFsbEZsYXRDb2x1bW5zQnlJZCgpW2NvbHVtbklkXTtcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbHVtbikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFtUYWJsZV0gQ29sdW1uIHdpdGggaWQgJyR7Y29sdW1uSWR9JyBkb2VzIG5vdCBleGlzdC5gKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY29sdW1uO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgT2JqZWN0LmFzc2lnbih0YWJsZSwgY29yZUluc3RhbmNlKTtcclxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGFibGUuX2ZlYXR1cmVzLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgY29uc3QgZmVhdHVyZSA9IHRhYmxlLl9mZWF0dXJlc1tpbmRleF07XHJcbiAgICBmZWF0dXJlID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVUYWJsZSA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlVGFibGUodGFibGUpO1xyXG4gIH1cclxuICByZXR1cm4gdGFibGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldENvcmVSb3dNb2RlbCgpIHtcclxuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUub3B0aW9ucy5kYXRhXSwgZGF0YSA9PiB7XHJcbiAgICBjb25zdCByb3dNb2RlbCA9IHtcclxuICAgICAgcm93czogW10sXHJcbiAgICAgIGZsYXRSb3dzOiBbXSxcclxuICAgICAgcm93c0J5SWQ6IHt9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgYWNjZXNzUm93cyA9IGZ1bmN0aW9uIChvcmlnaW5hbFJvd3MsIGRlcHRoLCBwYXJlbnRSb3cpIHtcclxuICAgICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcclxuICAgICAgICBkZXB0aCA9IDA7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgcm93cyA9IFtdO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yaWdpbmFsUm93cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIC8vIFRoaXMgY291bGQgYmUgYW4gZXhwZW5zaXZlIGNoZWNrIGF0IHNjYWxlLCBzbyB3ZSBzaG91bGQgbW92ZSBpdCBzb21ld2hlcmUgZWxzZSwgYnV0IHdoZXJlP1xyXG4gICAgICAgIC8vIGlmICghaWQpIHtcclxuICAgICAgICAvLyAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgLy8gICAgIHRocm93IG5ldyBFcnJvcihgZ2V0Um93SWQgZXhwZWN0ZWQgYW4gSUQsIGJ1dCBnb3QgJHtpZH1gKVxyXG4gICAgICAgIC8vICAgfVxyXG4gICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgLy8gTWFrZSB0aGUgcm93XHJcbiAgICAgICAgY29uc3Qgcm93ID0gY3JlYXRlUm93KHRhYmxlLCB0YWJsZS5fZ2V0Um93SWQob3JpZ2luYWxSb3dzW2ldLCBpLCBwYXJlbnRSb3cpLCBvcmlnaW5hbFJvd3NbaV0sIGksIGRlcHRoLCB1bmRlZmluZWQsIHBhcmVudFJvdyA9PSBudWxsID8gdm9pZCAwIDogcGFyZW50Um93LmlkKTtcclxuXHJcbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiBldmVyeSByb3cgaW4gYSBmbGF0IGFycmF5XHJcbiAgICAgICAgcm93TW9kZWwuZmxhdFJvd3MucHVzaChyb3cpO1xyXG4gICAgICAgIC8vIEFsc28ga2VlcCB0cmFjayBvZiBldmVyeSByb3cgYnkgaXRzIElEXHJcbiAgICAgICAgcm93TW9kZWwucm93c0J5SWRbcm93LmlkXSA9IHJvdztcclxuICAgICAgICAvLyBQdXNoIHRhYmxlIHJvdyBpbnRvIHBhcmVudFxyXG4gICAgICAgIHJvd3MucHVzaChyb3cpO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIG9yaWdpbmFsIHN1YnJvd3NcclxuICAgICAgICBpZiAodGFibGUub3B0aW9ucy5nZXRTdWJSb3dzKSB7XHJcbiAgICAgICAgICB2YXIgX3JvdyRvcmlnaW5hbFN1YlJvd3M7XHJcbiAgICAgICAgICByb3cub3JpZ2luYWxTdWJSb3dzID0gdGFibGUub3B0aW9ucy5nZXRTdWJSb3dzKG9yaWdpbmFsUm93c1tpXSwgaSk7XHJcblxyXG4gICAgICAgICAgLy8gVGhlbiByZWN1cnNpdmVseSBhY2Nlc3MgdGhlbVxyXG4gICAgICAgICAgaWYgKChfcm93JG9yaWdpbmFsU3ViUm93cyA9IHJvdy5vcmlnaW5hbFN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRvcmlnaW5hbFN1YlJvd3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJvdy5zdWJSb3dzID0gYWNjZXNzUm93cyhyb3cub3JpZ2luYWxTdWJSb3dzLCBkZXB0aCArIDEsIHJvdyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByb3dzO1xyXG4gICAgfTtcclxuICAgIHJvd01vZGVsLnJvd3MgPSBhY2Nlc3NSb3dzKGRhdGEpO1xyXG4gICAgcmV0dXJuIHJvd01vZGVsO1xyXG4gIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldFJvd01vZGVsJywgKCkgPT4gdGFibGUuX2F1dG9SZXNldFBhZ2VJbmRleCgpKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEV4cGFuZGVkUm93TW9kZWwoKSB7XHJcbiAgcmV0dXJuIHRhYmxlID0+IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQsIHRhYmxlLmdldFByZUV4cGFuZGVkUm93TW9kZWwoKSwgdGFibGUub3B0aW9ucy5wYWdpbmF0ZUV4cGFuZGVkUm93c10sIChleHBhbmRlZCwgcm93TW9kZWwsIHBhZ2luYXRlRXhwYW5kZWRSb3dzKSA9PiB7XHJcbiAgICBpZiAoIXJvd01vZGVsLnJvd3MubGVuZ3RoIHx8IGV4cGFuZGVkICE9PSB0cnVlICYmICFPYmplY3Qua2V5cyhleHBhbmRlZCAhPSBudWxsID8gZXhwYW5kZWQgOiB7fSkubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiByb3dNb2RlbDtcclxuICAgIH1cclxuICAgIGlmICghcGFnaW5hdGVFeHBhbmRlZFJvd3MpIHtcclxuICAgICAgLy8gT25seSBleHBhbmQgcm93cyBhdCB0aGlzIHBvaW50IGlmIHRoZXkgYXJlIGJlaW5nIHBhZ2luYXRlZFxyXG4gICAgICByZXR1cm4gcm93TW9kZWw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXhwYW5kUm93cyhyb3dNb2RlbCk7XHJcbiAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0RXhwYW5kZWRSb3dNb2RlbCcpKTtcclxufVxyXG5mdW5jdGlvbiBleHBhbmRSb3dzKHJvd01vZGVsKSB7XHJcbiAgY29uc3QgZXhwYW5kZWRSb3dzID0gW107XHJcbiAgY29uc3QgaGFuZGxlUm93ID0gcm93ID0+IHtcclxuICAgIHZhciBfcm93JHN1YlJvd3M7XHJcbiAgICBleHBhbmRlZFJvd3MucHVzaChyb3cpO1xyXG4gICAgaWYgKChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MubGVuZ3RoICYmIHJvdy5nZXRJc0V4cGFuZGVkKCkpIHtcclxuICAgICAgcm93LnN1YlJvd3MuZm9yRWFjaChoYW5kbGVSb3cpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgcm93TW9kZWwucm93cy5mb3JFYWNoKGhhbmRsZVJvdyk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJvd3M6IGV4cGFuZGVkUm93cyxcclxuICAgIGZsYXRSb3dzOiByb3dNb2RlbC5mbGF0Um93cyxcclxuICAgIHJvd3NCeUlkOiByb3dNb2RlbC5yb3dzQnlJZFxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMoKSB7XHJcbiAgcmV0dXJuICh0YWJsZSwgY29sdW1uSWQpID0+IG1lbW8oKCkgPT4ge1xyXG4gICAgdmFyIF90YWJsZSRnZXRDb2x1bW47XHJcbiAgICByZXR1cm4gWyhfdGFibGUkZ2V0Q29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRDb2x1bW4uZ2V0RmFjZXRlZFJvd01vZGVsKCldO1xyXG4gIH0sIGZhY2V0ZWRSb3dNb2RlbCA9PiB7XHJcbiAgICB2YXIgX2ZhY2V0ZWRSb3dNb2RlbCRmbGF0O1xyXG4gICAgaWYgKCFmYWNldGVkUm93TW9kZWwpIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBmaXJzdFZhbHVlID0gKF9mYWNldGVkUm93TW9kZWwkZmxhdCA9IGZhY2V0ZWRSb3dNb2RlbC5mbGF0Um93c1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mYWNldGVkUm93TW9kZWwkZmxhdC5nZXRVbmlxdWVWYWx1ZXMoY29sdW1uSWQpO1xyXG4gICAgaWYgKHR5cGVvZiBmaXJzdFZhbHVlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgbGV0IGZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSBbZmlyc3RWYWx1ZSwgZmlyc3RWYWx1ZV07XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZhY2V0ZWRSb3dNb2RlbC5mbGF0Um93cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCB2YWx1ZXMgPSBmYWNldGVkUm93TW9kZWwuZmxhdFJvd3NbaV0uZ2V0VW5pcXVlVmFsdWVzKGNvbHVtbklkKTtcclxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tqXTtcclxuICAgICAgICBpZiAodmFsdWUgPCBmYWNldGVkTWluTWF4VmFsdWVzWzBdKSB7XHJcbiAgICAgICAgICBmYWNldGVkTWluTWF4VmFsdWVzWzBdID0gdmFsdWU7XHJcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA+IGZhY2V0ZWRNaW5NYXhWYWx1ZXNbMV0pIHtcclxuICAgICAgICAgIGZhY2V0ZWRNaW5NYXhWYWx1ZXNbMV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWNldGVkTWluTWF4VmFsdWVzO1xyXG4gIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldEZhY2V0ZWRNaW5NYXhWYWx1ZXMnKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbHRlclJvd3Mocm93cywgZmlsdGVyUm93SW1wbCwgdGFibGUpIHtcclxuICBpZiAodGFibGUub3B0aW9ucy5maWx0ZXJGcm9tTGVhZlJvd3MpIHtcclxuICAgIHJldHVybiBmaWx0ZXJSb3dNb2RlbEZyb21MZWFmcyhyb3dzLCBmaWx0ZXJSb3dJbXBsLCB0YWJsZSk7XHJcbiAgfVxyXG4gIHJldHVybiBmaWx0ZXJSb3dNb2RlbEZyb21Sb290KHJvd3MsIGZpbHRlclJvd0ltcGwsIHRhYmxlKTtcclxufVxyXG5mdW5jdGlvbiBmaWx0ZXJSb3dNb2RlbEZyb21MZWFmcyhyb3dzVG9GaWx0ZXIsIGZpbHRlclJvdywgdGFibGUpIHtcclxuICB2YXIgX3RhYmxlJG9wdGlvbnMkbWF4TGVhO1xyXG4gIGNvbnN0IG5ld0ZpbHRlcmVkRmxhdFJvd3MgPSBbXTtcclxuICBjb25zdCBuZXdGaWx0ZXJlZFJvd3NCeUlkID0ge307XHJcbiAgY29uc3QgbWF4RGVwdGggPSAoX3RhYmxlJG9wdGlvbnMkbWF4TGVhID0gdGFibGUub3B0aW9ucy5tYXhMZWFmUm93RmlsdGVyRGVwdGgpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRtYXhMZWEgOiAxMDA7XHJcbiAgY29uc3QgcmVjdXJzZUZpbHRlclJvd3MgPSBmdW5jdGlvbiAocm93c1RvRmlsdGVyLCBkZXB0aCkge1xyXG4gICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcclxuICAgICAgZGVwdGggPSAwO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgcm93cyA9IFtdO1xyXG5cclxuICAgIC8vIEZpbHRlciBmcm9tIGNoaWxkcmVuIHVwIGZpcnN0XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3NUb0ZpbHRlci5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgX3JvdyRzdWJSb3dzO1xyXG4gICAgICBsZXQgcm93ID0gcm93c1RvRmlsdGVyW2ldO1xyXG4gICAgICBjb25zdCBuZXdSb3cgPSBjcmVhdGVSb3codGFibGUsIHJvdy5pZCwgcm93Lm9yaWdpbmFsLCByb3cuaW5kZXgsIHJvdy5kZXB0aCwgdW5kZWZpbmVkLCByb3cucGFyZW50SWQpO1xyXG4gICAgICBuZXdSb3cuY29sdW1uRmlsdGVycyA9IHJvdy5jb2x1bW5GaWx0ZXJzO1xyXG4gICAgICBpZiAoKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGggJiYgZGVwdGggPCBtYXhEZXB0aCkge1xyXG4gICAgICAgIG5ld1Jvdy5zdWJSb3dzID0gcmVjdXJzZUZpbHRlclJvd3Mocm93LnN1YlJvd3MsIGRlcHRoICsgMSk7XHJcbiAgICAgICAgcm93ID0gbmV3Um93O1xyXG4gICAgICAgIGlmIChmaWx0ZXJSb3cocm93KSAmJiAhbmV3Um93LnN1YlJvd3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICByb3dzLnB1c2gocm93KTtcclxuICAgICAgICAgIG5ld0ZpbHRlcmVkUm93c0J5SWRbcm93LmlkXSA9IHJvdztcclxuICAgICAgICAgIG5ld0ZpbHRlcmVkRmxhdFJvd3MucHVzaChyb3cpO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmaWx0ZXJSb3cocm93KSB8fCBuZXdSb3cuc3ViUm93cy5sZW5ndGgpIHtcclxuICAgICAgICAgIHJvd3MucHVzaChyb3cpO1xyXG4gICAgICAgICAgbmV3RmlsdGVyZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xyXG4gICAgICAgICAgbmV3RmlsdGVyZWRGbGF0Um93cy5wdXNoKHJvdyk7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcm93ID0gbmV3Um93O1xyXG4gICAgICAgIGlmIChmaWx0ZXJSb3cocm93KSkge1xyXG4gICAgICAgICAgcm93cy5wdXNoKHJvdyk7XHJcbiAgICAgICAgICBuZXdGaWx0ZXJlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XHJcbiAgICAgICAgICBuZXdGaWx0ZXJlZEZsYXRSb3dzLnB1c2gocm93KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByb3dzO1xyXG4gIH07XHJcbiAgcmV0dXJuIHtcclxuICAgIHJvd3M6IHJlY3Vyc2VGaWx0ZXJSb3dzKHJvd3NUb0ZpbHRlciksXHJcbiAgICBmbGF0Um93czogbmV3RmlsdGVyZWRGbGF0Um93cyxcclxuICAgIHJvd3NCeUlkOiBuZXdGaWx0ZXJlZFJvd3NCeUlkXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBmaWx0ZXJSb3dNb2RlbEZyb21Sb290KHJvd3NUb0ZpbHRlciwgZmlsdGVyUm93LCB0YWJsZSkge1xyXG4gIHZhciBfdGFibGUkb3B0aW9ucyRtYXhMZWEyO1xyXG4gIGNvbnN0IG5ld0ZpbHRlcmVkRmxhdFJvd3MgPSBbXTtcclxuICBjb25zdCBuZXdGaWx0ZXJlZFJvd3NCeUlkID0ge307XHJcbiAgY29uc3QgbWF4RGVwdGggPSAoX3RhYmxlJG9wdGlvbnMkbWF4TGVhMiA9IHRhYmxlLm9wdGlvbnMubWF4TGVhZlJvd0ZpbHRlckRlcHRoKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkbWF4TGVhMiA6IDEwMDtcclxuXHJcbiAgLy8gRmlsdGVycyB0b3AgbGV2ZWwgYW5kIG5lc3RlZCByb3dzXHJcbiAgY29uc3QgcmVjdXJzZUZpbHRlclJvd3MgPSBmdW5jdGlvbiAocm93c1RvRmlsdGVyLCBkZXB0aCkge1xyXG4gICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcclxuICAgICAgZGVwdGggPSAwO1xyXG4gICAgfVxyXG4gICAgLy8gRmlsdGVyIGZyb20gcGFyZW50cyBkb3dud2FyZCBmaXJzdFxyXG5cclxuICAgIGNvbnN0IHJvd3MgPSBbXTtcclxuXHJcbiAgICAvLyBBcHBseSB0aGUgZmlsdGVyIHRvIGFueSBzdWJSb3dzXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3NUb0ZpbHRlci5sZW5ndGg7IGkrKykge1xyXG4gICAgICBsZXQgcm93ID0gcm93c1RvRmlsdGVyW2ldO1xyXG4gICAgICBjb25zdCBwYXNzID0gZmlsdGVyUm93KHJvdyk7XHJcbiAgICAgIGlmIChwYXNzKSB7XHJcbiAgICAgICAgdmFyIF9yb3ckc3ViUm93czI7XHJcbiAgICAgICAgaWYgKChfcm93JHN1YlJvd3MyID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzMi5sZW5ndGggJiYgZGVwdGggPCBtYXhEZXB0aCkge1xyXG4gICAgICAgICAgY29uc3QgbmV3Um93ID0gY3JlYXRlUm93KHRhYmxlLCByb3cuaWQsIHJvdy5vcmlnaW5hbCwgcm93LmluZGV4LCByb3cuZGVwdGgsIHVuZGVmaW5lZCwgcm93LnBhcmVudElkKTtcclxuICAgICAgICAgIG5ld1Jvdy5zdWJSb3dzID0gcmVjdXJzZUZpbHRlclJvd3Mocm93LnN1YlJvd3MsIGRlcHRoICsgMSk7XHJcbiAgICAgICAgICByb3cgPSBuZXdSb3c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJvd3MucHVzaChyb3cpO1xyXG4gICAgICAgIG5ld0ZpbHRlcmVkRmxhdFJvd3MucHVzaChyb3cpO1xyXG4gICAgICAgIG5ld0ZpbHRlcmVkUm93c0J5SWRbcm93LmlkXSA9IHJvdztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJvd3M7XHJcbiAgfTtcclxuICByZXR1cm4ge1xyXG4gICAgcm93czogcmVjdXJzZUZpbHRlclJvd3Mocm93c1RvRmlsdGVyKSxcclxuICAgIGZsYXRSb3dzOiBuZXdGaWx0ZXJlZEZsYXRSb3dzLFxyXG4gICAgcm93c0J5SWQ6IG5ld0ZpbHRlcmVkUm93c0J5SWRcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRGYWNldGVkUm93TW9kZWwoKSB7XHJcbiAgcmV0dXJuICh0YWJsZSwgY29sdW1uSWQpID0+IG1lbW8oKCkgPT4gW3RhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5GaWx0ZXJzLCB0YWJsZS5nZXRTdGF0ZSgpLmdsb2JhbEZpbHRlciwgdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpXSwgKHByZVJvd01vZGVsLCBjb2x1bW5GaWx0ZXJzLCBnbG9iYWxGaWx0ZXIpID0+IHtcclxuICAgIGlmICghcHJlUm93TW9kZWwucm93cy5sZW5ndGggfHwgIShjb2x1bW5GaWx0ZXJzICE9IG51bGwgJiYgY29sdW1uRmlsdGVycy5sZW5ndGgpICYmICFnbG9iYWxGaWx0ZXIpIHtcclxuICAgICAgcmV0dXJuIHByZVJvd01vZGVsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZmlsdGVyYWJsZUlkcyA9IFsuLi5jb2x1bW5GaWx0ZXJzLm1hcChkID0+IGQuaWQpLmZpbHRlcihkID0+IGQgIT09IGNvbHVtbklkKSwgZ2xvYmFsRmlsdGVyID8gJ19fZ2xvYmFsX18nIDogdW5kZWZpbmVkXS5maWx0ZXIoQm9vbGVhbik7XHJcbiAgICBjb25zdCBmaWx0ZXJSb3dzSW1wbCA9IHJvdyA9PiB7XHJcbiAgICAgIC8vIEhvcml6b250YWxseSBmaWx0ZXIgcm93cyB0aHJvdWdoIGVhY2ggY29sdW1uXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyYWJsZUlkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChyb3cuY29sdW1uRmlsdGVyc1tmaWx0ZXJhYmxlSWRzW2ldXSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZpbHRlclJvd3MocHJlUm93TW9kZWwucm93cywgZmlsdGVyUm93c0ltcGwsIHRhYmxlKTtcclxuICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRGYWNldGVkUm93TW9kZWwnKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMoKSB7XHJcbiAgcmV0dXJuICh0YWJsZSwgY29sdW1uSWQpID0+IG1lbW8oKCkgPT4ge1xyXG4gICAgdmFyIF90YWJsZSRnZXRDb2x1bW47XHJcbiAgICByZXR1cm4gWyhfdGFibGUkZ2V0Q29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRDb2x1bW4uZ2V0RmFjZXRlZFJvd01vZGVsKCldO1xyXG4gIH0sIGZhY2V0ZWRSb3dNb2RlbCA9PiB7XHJcbiAgICBpZiAoIWZhY2V0ZWRSb3dNb2RlbCkgcmV0dXJuIG5ldyBNYXAoKTtcclxuICAgIGxldCBmYWNldGVkVW5pcXVlVmFsdWVzID0gbmV3IE1hcCgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWNldGVkUm93TW9kZWwuZmxhdFJvd3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgdmFsdWVzID0gZmFjZXRlZFJvd01vZGVsLmZsYXRSb3dzW2ldLmdldFVuaXF1ZVZhbHVlcyhjb2x1bW5JZCk7XHJcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbal07XHJcbiAgICAgICAgaWYgKGZhY2V0ZWRVbmlxdWVWYWx1ZXMuaGFzKHZhbHVlKSkge1xyXG4gICAgICAgICAgdmFyIF9mYWNldGVkVW5pcXVlVmFsdWVzJDtcclxuICAgICAgICAgIGZhY2V0ZWRVbmlxdWVWYWx1ZXMuc2V0KHZhbHVlLCAoKF9mYWNldGVkVW5pcXVlVmFsdWVzJCA9IGZhY2V0ZWRVbmlxdWVWYWx1ZXMuZ2V0KHZhbHVlKSkgIT0gbnVsbCA/IF9mYWNldGVkVW5pcXVlVmFsdWVzJCA6IDApICsgMSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZhY2V0ZWRVbmlxdWVWYWx1ZXMuc2V0KHZhbHVlLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWNldGVkVW5pcXVlVmFsdWVzO1xyXG4gIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgYGdldEZhY2V0ZWRVbmlxdWVWYWx1ZXNfJHtjb2x1bW5JZH1gKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEZpbHRlcmVkUm93TW9kZWwoKSB7XHJcbiAgcmV0dXJuIHRhYmxlID0+IG1lbW8oKCkgPT4gW3RhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5GaWx0ZXJzLCB0YWJsZS5nZXRTdGF0ZSgpLmdsb2JhbEZpbHRlcl0sIChyb3dNb2RlbCwgY29sdW1uRmlsdGVycywgZ2xvYmFsRmlsdGVyKSA9PiB7XHJcbiAgICBpZiAoIXJvd01vZGVsLnJvd3MubGVuZ3RoIHx8ICEoY29sdW1uRmlsdGVycyAhPSBudWxsICYmIGNvbHVtbkZpbHRlcnMubGVuZ3RoKSAmJiAhZ2xvYmFsRmlsdGVyKSB7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93TW9kZWwuZmxhdFJvd3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICByb3dNb2RlbC5mbGF0Um93c1tpXS5jb2x1bW5GaWx0ZXJzID0ge307XHJcbiAgICAgICAgcm93TW9kZWwuZmxhdFJvd3NbaV0uY29sdW1uRmlsdGVyc01ldGEgPSB7fTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcm93TW9kZWw7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXNvbHZlZENvbHVtbkZpbHRlcnMgPSBbXTtcclxuICAgIGNvbnN0IHJlc29sdmVkR2xvYmFsRmlsdGVycyA9IFtdO1xyXG4gICAgKGNvbHVtbkZpbHRlcnMgIT0gbnVsbCA/IGNvbHVtbkZpbHRlcnMgOiBbXSkuZm9yRWFjaChkID0+IHtcclxuICAgICAgdmFyIF9maWx0ZXJGbiRyZXNvbHZlRmlsdDtcclxuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGQuaWQpO1xyXG4gICAgICBpZiAoIWNvbHVtbikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBmaWx0ZXJGbiA9IGNvbHVtbi5nZXRGaWx0ZXJGbigpO1xyXG4gICAgICBpZiAoIWZpbHRlckZuKSB7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGZpbmQgYSB2YWxpZCAnY29sdW1uLmZpbHRlckZuJyBmb3IgY29sdW1uIHdpdGggdGhlIElEOiAke2NvbHVtbi5pZH0uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICByZXNvbHZlZENvbHVtbkZpbHRlcnMucHVzaCh7XHJcbiAgICAgICAgaWQ6IGQuaWQsXHJcbiAgICAgICAgZmlsdGVyRm4sXHJcbiAgICAgICAgcmVzb2x2ZWRWYWx1ZTogKF9maWx0ZXJGbiRyZXNvbHZlRmlsdCA9IGZpbHRlckZuLnJlc29sdmVGaWx0ZXJWYWx1ZSA9PSBudWxsID8gdm9pZCAwIDogZmlsdGVyRm4ucmVzb2x2ZUZpbHRlclZhbHVlKGQudmFsdWUpKSAhPSBudWxsID8gX2ZpbHRlckZuJHJlc29sdmVGaWx0IDogZC52YWx1ZVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgY29uc3QgZmlsdGVyYWJsZUlkcyA9IGNvbHVtbkZpbHRlcnMubWFwKGQgPT4gZC5pZCk7XHJcbiAgICBjb25zdCBnbG9iYWxGaWx0ZXJGbiA9IHRhYmxlLmdldEdsb2JhbEZpbHRlckZuKCk7XHJcbiAgICBjb25zdCBnbG9iYWxseUZpbHRlcmFibGVDb2x1bW5zID0gdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKS5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5nZXRDYW5HbG9iYWxGaWx0ZXIoKSk7XHJcbiAgICBpZiAoZ2xvYmFsRmlsdGVyICYmIGdsb2JhbEZpbHRlckZuICYmIGdsb2JhbGx5RmlsdGVyYWJsZUNvbHVtbnMubGVuZ3RoKSB7XHJcbiAgICAgIGZpbHRlcmFibGVJZHMucHVzaCgnX19nbG9iYWxfXycpO1xyXG4gICAgICBnbG9iYWxseUZpbHRlcmFibGVDb2x1bW5zLmZvckVhY2goY29sdW1uID0+IHtcclxuICAgICAgICB2YXIgX2dsb2JhbEZpbHRlckZuJHJlc29sO1xyXG4gICAgICAgIHJlc29sdmVkR2xvYmFsRmlsdGVycy5wdXNoKHtcclxuICAgICAgICAgIGlkOiBjb2x1bW4uaWQsXHJcbiAgICAgICAgICBmaWx0ZXJGbjogZ2xvYmFsRmlsdGVyRm4sXHJcbiAgICAgICAgICByZXNvbHZlZFZhbHVlOiAoX2dsb2JhbEZpbHRlckZuJHJlc29sID0gZ2xvYmFsRmlsdGVyRm4ucmVzb2x2ZUZpbHRlclZhbHVlID09IG51bGwgPyB2b2lkIDAgOiBnbG9iYWxGaWx0ZXJGbi5yZXNvbHZlRmlsdGVyVmFsdWUoZ2xvYmFsRmlsdGVyKSkgIT0gbnVsbCA/IF9nbG9iYWxGaWx0ZXJGbiRyZXNvbCA6IGdsb2JhbEZpbHRlclxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGxldCBjdXJyZW50Q29sdW1uRmlsdGVyO1xyXG4gICAgbGV0IGN1cnJlbnRHbG9iYWxGaWx0ZXI7XHJcblxyXG4gICAgLy8gRmxhZyB0aGUgcHJlZmlsdGVyZWQgcm93IG1vZGVsIHdpdGggZWFjaCBmaWx0ZXIgc3RhdGVcclxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93TW9kZWwuZmxhdFJvd3MubGVuZ3RoOyBqKyspIHtcclxuICAgICAgY29uc3Qgcm93ID0gcm93TW9kZWwuZmxhdFJvd3Nbal07XHJcbiAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzID0ge307XHJcbiAgICAgIGlmIChyZXNvbHZlZENvbHVtbkZpbHRlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNvbHZlZENvbHVtbkZpbHRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGN1cnJlbnRDb2x1bW5GaWx0ZXIgPSByZXNvbHZlZENvbHVtbkZpbHRlcnNbaV07XHJcbiAgICAgICAgICBjb25zdCBpZCA9IGN1cnJlbnRDb2x1bW5GaWx0ZXIuaWQ7XHJcblxyXG4gICAgICAgICAgLy8gVGFnIHRoZSByb3cgd2l0aCB0aGUgY29sdW1uIGZpbHRlciBzdGF0ZVxyXG4gICAgICAgICAgcm93LmNvbHVtbkZpbHRlcnNbaWRdID0gY3VycmVudENvbHVtbkZpbHRlci5maWx0ZXJGbihyb3csIGlkLCBjdXJyZW50Q29sdW1uRmlsdGVyLnJlc29sdmVkVmFsdWUsIGZpbHRlck1ldGEgPT4ge1xyXG4gICAgICAgICAgICByb3cuY29sdW1uRmlsdGVyc01ldGFbaWRdID0gZmlsdGVyTWV0YTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAocmVzb2x2ZWRHbG9iYWxGaWx0ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzb2x2ZWRHbG9iYWxGaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBjdXJyZW50R2xvYmFsRmlsdGVyID0gcmVzb2x2ZWRHbG9iYWxGaWx0ZXJzW2ldO1xyXG4gICAgICAgICAgY29uc3QgaWQgPSBjdXJyZW50R2xvYmFsRmlsdGVyLmlkO1xyXG4gICAgICAgICAgLy8gVGFnIHRoZSByb3cgd2l0aCB0aGUgZmlyc3QgdHJ1dGh5IGdsb2JhbCBmaWx0ZXIgc3RhdGVcclxuICAgICAgICAgIGlmIChjdXJyZW50R2xvYmFsRmlsdGVyLmZpbHRlckZuKHJvdywgaWQsIGN1cnJlbnRHbG9iYWxGaWx0ZXIucmVzb2x2ZWRWYWx1ZSwgZmlsdGVyTWV0YSA9PiB7XHJcbiAgICAgICAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzTWV0YVtpZF0gPSBmaWx0ZXJNZXRhO1xyXG4gICAgICAgICAgfSkpIHtcclxuICAgICAgICAgICAgcm93LmNvbHVtbkZpbHRlcnMuX19nbG9iYWxfXyA9IHRydWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocm93LmNvbHVtbkZpbHRlcnMuX19nbG9iYWxfXyAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgcm93LmNvbHVtbkZpbHRlcnMuX19nbG9iYWxfXyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgZmlsdGVyUm93c0ltcGwgPSByb3cgPT4ge1xyXG4gICAgICAvLyBIb3Jpem9udGFsbHkgZmlsdGVyIHJvd3MgdGhyb3VnaCBlYWNoIGNvbHVtblxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcmFibGVJZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAocm93LmNvbHVtbkZpbHRlcnNbZmlsdGVyYWJsZUlkc1tpXV0gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBGaWx0ZXIgZmluYWwgcm93cyB1c2luZyBhbGwgb2YgdGhlIGFjdGl2ZSBmaWx0ZXJzXHJcbiAgICByZXR1cm4gZmlsdGVyUm93cyhyb3dNb2RlbC5yb3dzLCBmaWx0ZXJSb3dzSW1wbCwgdGFibGUpO1xyXG4gIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldEZpbHRlcmVkUm93TW9kZWwnLCAoKSA9PiB0YWJsZS5fYXV0b1Jlc2V0UGFnZUluZGV4KCkpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0R3JvdXBlZFJvd01vZGVsKCkge1xyXG4gIHJldHVybiB0YWJsZSA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLmdyb3VwaW5nLCB0YWJsZS5nZXRQcmVHcm91cGVkUm93TW9kZWwoKV0sIChncm91cGluZywgcm93TW9kZWwpID0+IHtcclxuICAgIGlmICghcm93TW9kZWwucm93cy5sZW5ndGggfHwgIWdyb3VwaW5nLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gcm93TW9kZWw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmlsdGVyIHRoZSBncm91cGluZyBsaXN0IGRvd24gdG8gY29sdW1ucyB0aGF0IGV4aXN0XHJcbiAgICBjb25zdCBleGlzdGluZ0dyb3VwaW5nID0gZ3JvdXBpbmcuZmlsdGVyKGNvbHVtbklkID0+IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCkpO1xyXG4gICAgY29uc3QgZ3JvdXBlZEZsYXRSb3dzID0gW107XHJcbiAgICBjb25zdCBncm91cGVkUm93c0J5SWQgPSB7fTtcclxuICAgIC8vIGNvbnN0IG9ubHlHcm91cGVkRmxhdFJvd3M6IFJvd1tdID0gW107XHJcbiAgICAvLyBjb25zdCBvbmx5R3JvdXBlZFJvd3NCeUlkOiBSZWNvcmQ8Um93SWQsIFJvdz4gPSB7fTtcclxuICAgIC8vIGNvbnN0IG5vbkdyb3VwZWRGbGF0Um93czogUm93W10gPSBbXTtcclxuICAgIC8vIGNvbnN0IG5vbkdyb3VwZWRSb3dzQnlJZDogUmVjb3JkPFJvd0lkLCBSb3c+ID0ge307XHJcblxyXG4gICAgLy8gUmVjdXJzaXZlbHkgZ3JvdXAgdGhlIGRhdGFcclxuICAgIGNvbnN0IGdyb3VwVXBSZWN1cnNpdmVseSA9IGZ1bmN0aW9uIChyb3dzLCBkZXB0aCwgcGFyZW50SWQpIHtcclxuICAgICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcclxuICAgICAgICBkZXB0aCA9IDA7XHJcbiAgICAgIH1cclxuICAgICAgLy8gR3JvdXBpbmcgZGVwdGggaGFzIGJlZW4gYmVlbiBtZXRcclxuICAgICAgLy8gU3RvcCBncm91cGluZyBhbmQgc2ltcGx5IHJld3JpdGUgdGhkIGRlcHRoIGFuZCByb3cgcmVsYXRpb25zaGlwc1xyXG4gICAgICBpZiAoZGVwdGggPj0gZXhpc3RpbmdHcm91cGluZy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gcm93cy5tYXAocm93ID0+IHtcclxuICAgICAgICAgIHJvdy5kZXB0aCA9IGRlcHRoO1xyXG4gICAgICAgICAgZ3JvdXBlZEZsYXRSb3dzLnB1c2gocm93KTtcclxuICAgICAgICAgIGdyb3VwZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xyXG4gICAgICAgICAgaWYgKHJvdy5zdWJSb3dzKSB7XHJcbiAgICAgICAgICAgIHJvdy5zdWJSb3dzID0gZ3JvdXBVcFJlY3Vyc2l2ZWx5KHJvdy5zdWJSb3dzLCBkZXB0aCArIDEsIHJvdy5pZCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gcm93O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGNvbHVtbklkID0gZXhpc3RpbmdHcm91cGluZ1tkZXB0aF07XHJcblxyXG4gICAgICAvLyBHcm91cCB0aGUgcm93cyB0b2dldGhlciBmb3IgdGhpcyBsZXZlbFxyXG4gICAgICBjb25zdCByb3dHcm91cHNNYXAgPSBncm91cEJ5KHJvd3MsIGNvbHVtbklkKTtcclxuXHJcbiAgICAgIC8vIFBlZm9ybSBhZ2dyZWdhdGlvbnMgZm9yIGVhY2ggZ3JvdXBcclxuICAgICAgY29uc3QgYWdncmVnYXRlZEdyb3VwZWRSb3dzID0gQXJyYXkuZnJvbShyb3dHcm91cHNNYXAuZW50cmllcygpKS5tYXAoKF9yZWYsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgbGV0IFtncm91cGluZ1ZhbHVlLCBncm91cGVkUm93c10gPSBfcmVmO1xyXG4gICAgICAgIGxldCBpZCA9IGAke2NvbHVtbklkfToke2dyb3VwaW5nVmFsdWV9YDtcclxuICAgICAgICBpZCA9IHBhcmVudElkID8gYCR7cGFyZW50SWR9PiR7aWR9YCA6IGlkO1xyXG5cclxuICAgICAgICAvLyBGaXJzdCwgUmVjdXJzZSB0byBncm91cCBzdWIgcm93cyBiZWZvcmUgYWdncmVnYXRpb25cclxuICAgICAgICBjb25zdCBzdWJSb3dzID0gZ3JvdXBVcFJlY3Vyc2l2ZWx5KGdyb3VwZWRSb3dzLCBkZXB0aCArIDEsIGlkKTtcclxuXHJcbiAgICAgICAgLy8gRmxhdHRlbiB0aGUgbGVhZiByb3dzIG9mIHRoZSByb3dzIGluIHRoaXMgZ3JvdXBcclxuICAgICAgICBjb25zdCBsZWFmUm93cyA9IGRlcHRoID8gZmxhdHRlbkJ5KGdyb3VwZWRSb3dzLCByb3cgPT4gcm93LnN1YlJvd3MpIDogZ3JvdXBlZFJvd3M7XHJcbiAgICAgICAgY29uc3Qgcm93ID0gY3JlYXRlUm93KHRhYmxlLCBpZCwgbGVhZlJvd3NbMF0ub3JpZ2luYWwsIGluZGV4LCBkZXB0aCwgdW5kZWZpbmVkLCBwYXJlbnRJZCk7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihyb3csIHtcclxuICAgICAgICAgIGdyb3VwaW5nQ29sdW1uSWQ6IGNvbHVtbklkLFxyXG4gICAgICAgICAgZ3JvdXBpbmdWYWx1ZSxcclxuICAgICAgICAgIHN1YlJvd3MsXHJcbiAgICAgICAgICBsZWFmUm93cyxcclxuICAgICAgICAgIGdldFZhbHVlOiBjb2x1bW5JZCA9PiB7XHJcbiAgICAgICAgICAgIC8vIERvbid0IGFnZ3JlZ2F0ZSBjb2x1bW5zIHRoYXQgYXJlIGluIHRoZSBncm91cGluZ1xyXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdHcm91cGluZy5pbmNsdWRlcyhjb2x1bW5JZCkpIHtcclxuICAgICAgICAgICAgICBpZiAocm93Ll92YWx1ZXNDYWNoZS5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKGdyb3VwZWRSb3dzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2dyb3VwZWRSb3dzJDAkZ2V0VmFsO1xyXG4gICAgICAgICAgICAgICAgcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF0gPSAoX2dyb3VwZWRSb3dzJDAkZ2V0VmFsID0gZ3JvdXBlZFJvd3NbMF0uZ2V0VmFsdWUoY29sdW1uSWQpKSAhPSBudWxsID8gX2dyb3VwZWRSb3dzJDAkZ2V0VmFsIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZS5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZCkpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWdncmVnYXRlIHRoZSB2YWx1ZXNcclxuICAgICAgICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKTtcclxuICAgICAgICAgICAgY29uc3QgYWdncmVnYXRlRm4gPSBjb2x1bW4gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbHVtbi5nZXRBZ2dyZWdhdGlvbkZuKCk7XHJcbiAgICAgICAgICAgIGlmIChhZ2dyZWdhdGVGbikge1xyXG4gICAgICAgICAgICAgIHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZVtjb2x1bW5JZF0gPSBhZ2dyZWdhdGVGbihjb2x1bW5JZCwgbGVhZlJvd3MsIGdyb3VwZWRSb3dzKTtcclxuICAgICAgICAgICAgICByZXR1cm4gcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN1YlJvd3MuZm9yRWFjaChzdWJSb3cgPT4ge1xyXG4gICAgICAgICAgZ3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcclxuICAgICAgICAgIGdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xyXG4gICAgICAgICAgLy8gaWYgKHN1YlJvdy5nZXRJc0dyb3VwZWQ/LigpKSB7XHJcbiAgICAgICAgICAvLyAgIG9ubHlHcm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xyXG4gICAgICAgICAgLy8gICBvbmx5R3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XHJcbiAgICAgICAgICAvLyB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gICBub25Hcm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xyXG4gICAgICAgICAgLy8gICBub25Hcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcclxuICAgICAgICAgIC8vIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcm93O1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGFnZ3JlZ2F0ZWRHcm91cGVkUm93cztcclxuICAgIH07XHJcbiAgICBjb25zdCBncm91cGVkUm93cyA9IGdyb3VwVXBSZWN1cnNpdmVseShyb3dNb2RlbC5yb3dzLCAwKTtcclxuICAgIGdyb3VwZWRSb3dzLmZvckVhY2goc3ViUm93ID0+IHtcclxuICAgICAgZ3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcclxuICAgICAgZ3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XHJcbiAgICAgIC8vIGlmIChzdWJSb3cuZ2V0SXNHcm91cGVkPy4oKSkge1xyXG4gICAgICAvLyAgIG9ubHlHcm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xyXG4gICAgICAvLyAgIG9ubHlHcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcclxuICAgICAgLy8gfSBlbHNlIHtcclxuICAgICAgLy8gICBub25Hcm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xyXG4gICAgICAvLyAgIG5vbkdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xyXG4gICAgICAvLyB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJvd3M6IGdyb3VwZWRSb3dzLFxyXG4gICAgICBmbGF0Um93czogZ3JvdXBlZEZsYXRSb3dzLFxyXG4gICAgICByb3dzQnlJZDogZ3JvdXBlZFJvd3NCeUlkXHJcbiAgICB9O1xyXG4gIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldEdyb3VwZWRSb3dNb2RlbCcsICgpID0+IHtcclxuICAgIHRhYmxlLl9xdWV1ZSgoKSA9PiB7XHJcbiAgICAgIHRhYmxlLl9hdXRvUmVzZXRFeHBhbmRlZCgpO1xyXG4gICAgICB0YWJsZS5fYXV0b1Jlc2V0UGFnZUluZGV4KCk7XHJcbiAgICB9KTtcclxuICB9KSk7XHJcbn1cclxuZnVuY3Rpb24gZ3JvdXBCeShyb3dzLCBjb2x1bW5JZCkge1xyXG4gIGNvbnN0IGdyb3VwTWFwID0gbmV3IE1hcCgpO1xyXG4gIHJldHVybiByb3dzLnJlZHVjZSgobWFwLCByb3cpID0+IHtcclxuICAgIGNvbnN0IHJlc0tleSA9IGAke3Jvdy5nZXRHcm91cGluZ1ZhbHVlKGNvbHVtbklkKX1gO1xyXG4gICAgY29uc3QgcHJldmlvdXMgPSBtYXAuZ2V0KHJlc0tleSk7XHJcbiAgICBpZiAoIXByZXZpb3VzKSB7XHJcbiAgICAgIG1hcC5zZXQocmVzS2V5LCBbcm93XSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwcmV2aW91cy5wdXNoKHJvdyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWFwO1xyXG4gIH0sIGdyb3VwTWFwKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0UGFnaW5hdGlvblJvd01vZGVsKG9wdHMpIHtcclxuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5wYWdpbmF0aW9uLCB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwoKSwgdGFibGUub3B0aW9ucy5wYWdpbmF0ZUV4cGFuZGVkUm93cyA/IHVuZGVmaW5lZCA6IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWRdLCAocGFnaW5hdGlvbiwgcm93TW9kZWwpID0+IHtcclxuICAgIGlmICghcm93TW9kZWwucm93cy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIHJvd01vZGVsO1xyXG4gICAgfVxyXG4gICAgY29uc3Qge1xyXG4gICAgICBwYWdlU2l6ZSxcclxuICAgICAgcGFnZUluZGV4XHJcbiAgICB9ID0gcGFnaW5hdGlvbjtcclxuICAgIGxldCB7XHJcbiAgICAgIHJvd3MsXHJcbiAgICAgIGZsYXRSb3dzLFxyXG4gICAgICByb3dzQnlJZFxyXG4gICAgfSA9IHJvd01vZGVsO1xyXG4gICAgY29uc3QgcGFnZVN0YXJ0ID0gcGFnZVNpemUgKiBwYWdlSW5kZXg7XHJcbiAgICBjb25zdCBwYWdlRW5kID0gcGFnZVN0YXJ0ICsgcGFnZVNpemU7XHJcbiAgICByb3dzID0gcm93cy5zbGljZShwYWdlU3RhcnQsIHBhZ2VFbmQpO1xyXG4gICAgbGV0IHBhZ2luYXRlZFJvd01vZGVsO1xyXG4gICAgaWYgKCF0YWJsZS5vcHRpb25zLnBhZ2luYXRlRXhwYW5kZWRSb3dzKSB7XHJcbiAgICAgIHBhZ2luYXRlZFJvd01vZGVsID0gZXhwYW5kUm93cyh7XHJcbiAgICAgICAgcm93cyxcclxuICAgICAgICBmbGF0Um93cyxcclxuICAgICAgICByb3dzQnlJZFxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBhZ2luYXRlZFJvd01vZGVsID0ge1xyXG4gICAgICAgIHJvd3MsXHJcbiAgICAgICAgZmxhdFJvd3MsXHJcbiAgICAgICAgcm93c0J5SWRcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIHBhZ2luYXRlZFJvd01vZGVsLmZsYXRSb3dzID0gW107XHJcbiAgICBjb25zdCBoYW5kbGVSb3cgPSByb3cgPT4ge1xyXG4gICAgICBwYWdpbmF0ZWRSb3dNb2RlbC5mbGF0Um93cy5wdXNoKHJvdyk7XHJcbiAgICAgIGlmIChyb3cuc3ViUm93cy5sZW5ndGgpIHtcclxuICAgICAgICByb3cuc3ViUm93cy5mb3JFYWNoKGhhbmRsZVJvdyk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBwYWdpbmF0ZWRSb3dNb2RlbC5yb3dzLmZvckVhY2goaGFuZGxlUm93KTtcclxuICAgIHJldHVybiBwYWdpbmF0ZWRSb3dNb2RlbDtcclxuICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRQYWdpbmF0aW9uUm93TW9kZWwnKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFNvcnRlZFJvd01vZGVsKCkge1xyXG4gIHJldHVybiB0YWJsZSA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLnNvcnRpbmcsIHRhYmxlLmdldFByZVNvcnRlZFJvd01vZGVsKCldLCAoc29ydGluZywgcm93TW9kZWwpID0+IHtcclxuICAgIGlmICghcm93TW9kZWwucm93cy5sZW5ndGggfHwgIShzb3J0aW5nICE9IG51bGwgJiYgc29ydGluZy5sZW5ndGgpKSB7XHJcbiAgICAgIHJldHVybiByb3dNb2RlbDtcclxuICAgIH1cclxuICAgIGNvbnN0IHNvcnRpbmdTdGF0ZSA9IHRhYmxlLmdldFN0YXRlKCkuc29ydGluZztcclxuICAgIGNvbnN0IHNvcnRlZEZsYXRSb3dzID0gW107XHJcblxyXG4gICAgLy8gRmlsdGVyIG91dCBzb3J0aW5ncyB0aGF0IGNvcnJlc3BvbmQgdG8gbm9uIGV4aXN0aW5nIGNvbHVtbnNcclxuICAgIGNvbnN0IGF2YWlsYWJsZVNvcnRpbmcgPSBzb3J0aW5nU3RhdGUuZmlsdGVyKHNvcnQgPT4ge1xyXG4gICAgICB2YXIgX3RhYmxlJGdldENvbHVtbjtcclxuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0Q29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKHNvcnQuaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldENvbHVtbi5nZXRDYW5Tb3J0KCk7XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGNvbHVtbkluZm9CeUlkID0ge307XHJcbiAgICBhdmFpbGFibGVTb3J0aW5nLmZvckVhY2goc29ydEVudHJ5ID0+IHtcclxuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKHNvcnRFbnRyeS5pZCk7XHJcbiAgICAgIGlmICghY29sdW1uKSByZXR1cm47XHJcbiAgICAgIGNvbHVtbkluZm9CeUlkW3NvcnRFbnRyeS5pZF0gPSB7XHJcbiAgICAgICAgc29ydFVuZGVmaW5lZDogY29sdW1uLmNvbHVtbkRlZi5zb3J0VW5kZWZpbmVkLFxyXG4gICAgICAgIGludmVydFNvcnRpbmc6IGNvbHVtbi5jb2x1bW5EZWYuaW52ZXJ0U29ydGluZyxcclxuICAgICAgICBzb3J0aW5nRm46IGNvbHVtbi5nZXRTb3J0aW5nRm4oKVxyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBzb3J0RGF0YSA9IHJvd3MgPT4ge1xyXG4gICAgICAvLyBUaGlzIHdpbGwgYWxzbyBwZXJmb3JtIGEgc3RhYmxlIHNvcnRpbmcgdXNpbmcgdGhlIHJvdyBpbmRleFxyXG4gICAgICAvLyBpZiBuZWVkZWQuXHJcbiAgICAgIGNvbnN0IHNvcnRlZERhdGEgPSByb3dzLm1hcChyb3cgPT4gKHtcclxuICAgICAgICAuLi5yb3dcclxuICAgICAgfSkpO1xyXG4gICAgICBzb3J0ZWREYXRhLnNvcnQoKHJvd0EsIHJvd0IpID0+IHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF2YWlsYWJsZVNvcnRpbmcubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgIHZhciBfc29ydEVudHJ5JGRlc2M7XHJcbiAgICAgICAgICBjb25zdCBzb3J0RW50cnkgPSBhdmFpbGFibGVTb3J0aW5nW2ldO1xyXG4gICAgICAgICAgY29uc3QgY29sdW1uSW5mbyA9IGNvbHVtbkluZm9CeUlkW3NvcnRFbnRyeS5pZF07XHJcbiAgICAgICAgICBjb25zdCBpc0Rlc2MgPSAoX3NvcnRFbnRyeSRkZXNjID0gc29ydEVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiBzb3J0RW50cnkuZGVzYykgIT0gbnVsbCA/IF9zb3J0RW50cnkkZGVzYyA6IGZhbHNlO1xyXG4gICAgICAgICAgbGV0IHNvcnRJbnQgPSAwO1xyXG5cclxuICAgICAgICAgIC8vIEFsbCBzb3J0aW5nIGludHMgc2hvdWxkIGFsd2F5cyByZXR1cm4gaW4gYXNjZW5kaW5nIG9yZGVyXHJcbiAgICAgICAgICBpZiAoY29sdW1uSW5mby5zb3J0VW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFWYWx1ZSA9IHJvd0EuZ2V0VmFsdWUoc29ydEVudHJ5LmlkKTtcclxuICAgICAgICAgICAgY29uc3QgYlZhbHVlID0gcm93Qi5nZXRWYWx1ZShzb3J0RW50cnkuaWQpO1xyXG4gICAgICAgICAgICBjb25zdCBhVW5kZWZpbmVkID0gYVZhbHVlID09PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGJVbmRlZmluZWQgPSBiVmFsdWUgPT09IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYgKGFVbmRlZmluZWQgfHwgYlVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgIHNvcnRJbnQgPSBhVW5kZWZpbmVkICYmIGJVbmRlZmluZWQgPyAwIDogYVVuZGVmaW5lZCA/IGNvbHVtbkluZm8uc29ydFVuZGVmaW5lZCA6IC1jb2x1bW5JbmZvLnNvcnRVbmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChzb3J0SW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHNvcnRJbnQgPSBjb2x1bW5JbmZvLnNvcnRpbmdGbihyb3dBLCByb3dCLCBzb3J0RW50cnkuaWQpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIElmIHNvcnRpbmcgaXMgbm9uLXplcm8sIHRha2UgY2FyZSBvZiBkZXNjIGFuZCBpbnZlcnNpb25cclxuICAgICAgICAgIGlmIChzb3J0SW50ICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0Rlc2MpIHtcclxuICAgICAgICAgICAgICBzb3J0SW50ICo9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb2x1bW5JbmZvLmludmVydFNvcnRpbmcpIHtcclxuICAgICAgICAgICAgICBzb3J0SW50ICo9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzb3J0SW50O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcm93QS5pbmRleCAtIHJvd0IuaW5kZXg7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gSWYgdGhlcmUgYXJlIHN1Yi1yb3dzLCBzb3J0IHRoZW1cclxuICAgICAgc29ydGVkRGF0YS5mb3JFYWNoKHJvdyA9PiB7XHJcbiAgICAgICAgdmFyIF9yb3ckc3ViUm93cztcclxuICAgICAgICBzb3J0ZWRGbGF0Um93cy5wdXNoKHJvdyk7XHJcbiAgICAgICAgaWYgKChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICByb3cuc3ViUm93cyA9IHNvcnREYXRhKHJvdy5zdWJSb3dzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gc29ydGVkRGF0YTtcclxuICAgIH07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByb3dzOiBzb3J0RGF0YShyb3dNb2RlbC5yb3dzKSxcclxuICAgICAgZmxhdFJvd3M6IHNvcnRlZEZsYXRSb3dzLFxyXG4gICAgICByb3dzQnlJZDogcm93TW9kZWwucm93c0J5SWRcclxuICAgIH07XHJcbiAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0U29ydGVkUm93TW9kZWwnLCAoKSA9PiB0YWJsZS5fYXV0b1Jlc2V0UGFnZUluZGV4KCkpKTtcclxufVxyXG5cclxuZXhwb3J0IHsgQ29sdW1uRmFjZXRpbmcsIENvbHVtbkZpbHRlcmluZywgQ29sdW1uR3JvdXBpbmcsIENvbHVtbk9yZGVyaW5nLCBDb2x1bW5QaW5uaW5nLCBDb2x1bW5TaXppbmcsIENvbHVtblZpc2liaWxpdHksIEdsb2JhbEZhY2V0aW5nLCBHbG9iYWxGaWx0ZXJpbmcsIEhlYWRlcnMsIFJvd0V4cGFuZGluZywgUm93UGFnaW5hdGlvbiwgUm93UGlubmluZywgUm93U2VsZWN0aW9uLCBSb3dTb3J0aW5nLCBfZ2V0VmlzaWJsZUxlYWZDb2x1bW5zLCBhZ2dyZWdhdGlvbkZucywgYnVpbGRIZWFkZXJHcm91cHMsIGNyZWF0ZUNlbGwsIGNyZWF0ZUNvbHVtbiwgY3JlYXRlQ29sdW1uSGVscGVyLCBjcmVhdGVSb3csIGNyZWF0ZVRhYmxlLCBkZWZhdWx0Q29sdW1uU2l6aW5nLCBleHBhbmRSb3dzLCBmaWx0ZXJGbnMsIGZsYXR0ZW5CeSwgZnVuY3Rpb25hbFVwZGF0ZSwgZ2V0Q29yZVJvd01vZGVsLCBnZXRFeHBhbmRlZFJvd01vZGVsLCBnZXRGYWNldGVkTWluTWF4VmFsdWVzLCBnZXRGYWNldGVkUm93TW9kZWwsIGdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMsIGdldEZpbHRlcmVkUm93TW9kZWwsIGdldEdyb3VwZWRSb3dNb2RlbCwgZ2V0TWVtb09wdGlvbnMsIGdldFBhZ2luYXRpb25Sb3dNb2RlbCwgZ2V0U29ydGVkUm93TW9kZWwsIGlzRnVuY3Rpb24sIGlzTnVtYmVyQXJyYXksIGlzUm93U2VsZWN0ZWQsIGlzU3ViUm93U2VsZWN0ZWQsIG1ha2VTdGF0ZVVwZGF0ZXIsIG1lbW8sIG5vb3AsIG9yZGVyQ29sdW1ucywgcGFzc2l2ZUV2ZW50U3VwcG9ydGVkLCByZVNwbGl0QWxwaGFOdW1lcmljLCBzZWxlY3RSb3dzRm4sIHNob3VsZEF1dG9SZW1vdmVGaWx0ZXIsIHNvcnRpbmdGbnMgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs\n");

/***/ })

};
;