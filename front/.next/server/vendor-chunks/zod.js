"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/zod";
exports.ids = ["vendor-chunks/zod"];
exports.modules = {

/***/ "(ssr)/./node_modules/zod/lib/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/zod/lib/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BRAND: () => (/* binding */ BRAND),\n/* harmony export */   DIRTY: () => (/* binding */ DIRTY),\n/* harmony export */   EMPTY_PATH: () => (/* binding */ EMPTY_PATH),\n/* harmony export */   INVALID: () => (/* binding */ INVALID),\n/* harmony export */   NEVER: () => (/* binding */ NEVER),\n/* harmony export */   OK: () => (/* binding */ OK),\n/* harmony export */   ParseStatus: () => (/* binding */ ParseStatus),\n/* harmony export */   Schema: () => (/* binding */ ZodType),\n/* harmony export */   ZodAny: () => (/* binding */ ZodAny),\n/* harmony export */   ZodArray: () => (/* binding */ ZodArray),\n/* harmony export */   ZodBigInt: () => (/* binding */ ZodBigInt),\n/* harmony export */   ZodBoolean: () => (/* binding */ ZodBoolean),\n/* harmony export */   ZodBranded: () => (/* binding */ ZodBranded),\n/* harmony export */   ZodCatch: () => (/* binding */ ZodCatch),\n/* harmony export */   ZodDate: () => (/* binding */ ZodDate),\n/* harmony export */   ZodDefault: () => (/* binding */ ZodDefault),\n/* harmony export */   ZodDiscriminatedUnion: () => (/* binding */ ZodDiscriminatedUnion),\n/* harmony export */   ZodEffects: () => (/* binding */ ZodEffects),\n/* harmony export */   ZodEnum: () => (/* binding */ ZodEnum),\n/* harmony export */   ZodError: () => (/* binding */ ZodError),\n/* harmony export */   ZodFirstPartyTypeKind: () => (/* binding */ ZodFirstPartyTypeKind),\n/* harmony export */   ZodFunction: () => (/* binding */ ZodFunction),\n/* harmony export */   ZodIntersection: () => (/* binding */ ZodIntersection),\n/* harmony export */   ZodIssueCode: () => (/* binding */ ZodIssueCode),\n/* harmony export */   ZodLazy: () => (/* binding */ ZodLazy),\n/* harmony export */   ZodLiteral: () => (/* binding */ ZodLiteral),\n/* harmony export */   ZodMap: () => (/* binding */ ZodMap),\n/* harmony export */   ZodNaN: () => (/* binding */ ZodNaN),\n/* harmony export */   ZodNativeEnum: () => (/* binding */ ZodNativeEnum),\n/* harmony export */   ZodNever: () => (/* binding */ ZodNever),\n/* harmony export */   ZodNull: () => (/* binding */ ZodNull),\n/* harmony export */   ZodNullable: () => (/* binding */ ZodNullable),\n/* harmony export */   ZodNumber: () => (/* binding */ ZodNumber),\n/* harmony export */   ZodObject: () => (/* binding */ ZodObject),\n/* harmony export */   ZodOptional: () => (/* binding */ ZodOptional),\n/* harmony export */   ZodParsedType: () => (/* binding */ ZodParsedType),\n/* harmony export */   ZodPipeline: () => (/* binding */ ZodPipeline),\n/* harmony export */   ZodPromise: () => (/* binding */ ZodPromise),\n/* harmony export */   ZodReadonly: () => (/* binding */ ZodReadonly),\n/* harmony export */   ZodRecord: () => (/* binding */ ZodRecord),\n/* harmony export */   ZodSchema: () => (/* binding */ ZodType),\n/* harmony export */   ZodSet: () => (/* binding */ ZodSet),\n/* harmony export */   ZodString: () => (/* binding */ ZodString),\n/* harmony export */   ZodSymbol: () => (/* binding */ ZodSymbol),\n/* harmony export */   ZodTransformer: () => (/* binding */ ZodEffects),\n/* harmony export */   ZodTuple: () => (/* binding */ ZodTuple),\n/* harmony export */   ZodType: () => (/* binding */ ZodType),\n/* harmony export */   ZodUndefined: () => (/* binding */ ZodUndefined),\n/* harmony export */   ZodUnion: () => (/* binding */ ZodUnion),\n/* harmony export */   ZodUnknown: () => (/* binding */ ZodUnknown),\n/* harmony export */   ZodVoid: () => (/* binding */ ZodVoid),\n/* harmony export */   addIssueToContext: () => (/* binding */ addIssueToContext),\n/* harmony export */   any: () => (/* binding */ anyType),\n/* harmony export */   array: () => (/* binding */ arrayType),\n/* harmony export */   bigint: () => (/* binding */ bigIntType),\n/* harmony export */   boolean: () => (/* binding */ booleanType),\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   custom: () => (/* binding */ custom),\n/* harmony export */   date: () => (/* binding */ dateType),\n/* harmony export */   \"default\": () => (/* binding */ z),\n/* harmony export */   defaultErrorMap: () => (/* binding */ errorMap),\n/* harmony export */   discriminatedUnion: () => (/* binding */ discriminatedUnionType),\n/* harmony export */   effect: () => (/* binding */ effectsType),\n/* harmony export */   \"enum\": () => (/* binding */ enumType),\n/* harmony export */   \"function\": () => (/* binding */ functionType),\n/* harmony export */   getErrorMap: () => (/* binding */ getErrorMap),\n/* harmony export */   getParsedType: () => (/* binding */ getParsedType),\n/* harmony export */   \"instanceof\": () => (/* binding */ instanceOfType),\n/* harmony export */   intersection: () => (/* binding */ intersectionType),\n/* harmony export */   isAborted: () => (/* binding */ isAborted),\n/* harmony export */   isAsync: () => (/* binding */ isAsync),\n/* harmony export */   isDirty: () => (/* binding */ isDirty),\n/* harmony export */   isValid: () => (/* binding */ isValid),\n/* harmony export */   late: () => (/* binding */ late),\n/* harmony export */   lazy: () => (/* binding */ lazyType),\n/* harmony export */   literal: () => (/* binding */ literalType),\n/* harmony export */   makeIssue: () => (/* binding */ makeIssue),\n/* harmony export */   map: () => (/* binding */ mapType),\n/* harmony export */   nan: () => (/* binding */ nanType),\n/* harmony export */   nativeEnum: () => (/* binding */ nativeEnumType),\n/* harmony export */   never: () => (/* binding */ neverType),\n/* harmony export */   \"null\": () => (/* binding */ nullType),\n/* harmony export */   nullable: () => (/* binding */ nullableType),\n/* harmony export */   number: () => (/* binding */ numberType),\n/* harmony export */   object: () => (/* binding */ objectType),\n/* harmony export */   objectUtil: () => (/* binding */ objectUtil),\n/* harmony export */   oboolean: () => (/* binding */ oboolean),\n/* harmony export */   onumber: () => (/* binding */ onumber),\n/* harmony export */   optional: () => (/* binding */ optionalType),\n/* harmony export */   ostring: () => (/* binding */ ostring),\n/* harmony export */   pipeline: () => (/* binding */ pipelineType),\n/* harmony export */   preprocess: () => (/* binding */ preprocessType),\n/* harmony export */   promise: () => (/* binding */ promiseType),\n/* harmony export */   quotelessJson: () => (/* binding */ quotelessJson),\n/* harmony export */   record: () => (/* binding */ recordType),\n/* harmony export */   set: () => (/* binding */ setType),\n/* harmony export */   setErrorMap: () => (/* binding */ setErrorMap),\n/* harmony export */   strictObject: () => (/* binding */ strictObjectType),\n/* harmony export */   string: () => (/* binding */ stringType),\n/* harmony export */   symbol: () => (/* binding */ symbolType),\n/* harmony export */   transformer: () => (/* binding */ effectsType),\n/* harmony export */   tuple: () => (/* binding */ tupleType),\n/* harmony export */   undefined: () => (/* binding */ undefinedType),\n/* harmony export */   union: () => (/* binding */ unionType),\n/* harmony export */   unknown: () => (/* binding */ unknownType),\n/* harmony export */   util: () => (/* binding */ util),\n/* harmony export */   \"void\": () => (/* binding */ voidType),\n/* harmony export */   z: () => (/* binding */ z)\n/* harmony export */ });\nvar util;\r\n(function (util) {\r\n    util.assertEqual = (val) => val;\r\n    function assertIs(_arg) { }\r\n    util.assertIs = assertIs;\r\n    function assertNever(_x) {\r\n        throw new Error();\r\n    }\r\n    util.assertNever = assertNever;\r\n    util.arrayToEnum = (items) => {\r\n        const obj = {};\r\n        for (const item of items) {\r\n            obj[item] = item;\r\n        }\r\n        return obj;\r\n    };\r\n    util.getValidEnumValues = (obj) => {\r\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\r\n        const filtered = {};\r\n        for (const k of validKeys) {\r\n            filtered[k] = obj[k];\r\n        }\r\n        return util.objectValues(filtered);\r\n    };\r\n    util.objectValues = (obj) => {\r\n        return util.objectKeys(obj).map(function (e) {\r\n            return obj[e];\r\n        });\r\n    };\r\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\r\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\r\n        : (object) => {\r\n            const keys = [];\r\n            for (const key in object) {\r\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\r\n                    keys.push(key);\r\n                }\r\n            }\r\n            return keys;\r\n        };\r\n    util.find = (arr, checker) => {\r\n        for (const item of arr) {\r\n            if (checker(item))\r\n                return item;\r\n        }\r\n        return undefined;\r\n    };\r\n    util.isInteger = typeof Number.isInteger === \"function\"\r\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\r\n        : (val) => typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\r\n    function joinValues(array, separator = \" | \") {\r\n        return array\r\n            .map((val) => (typeof val === \"string\" ? `'${val}'` : val))\r\n            .join(separator);\r\n    }\r\n    util.joinValues = joinValues;\r\n    util.jsonStringifyReplacer = (_, value) => {\r\n        if (typeof value === \"bigint\") {\r\n            return value.toString();\r\n        }\r\n        return value;\r\n    };\r\n})(util || (util = {}));\r\nvar objectUtil;\r\n(function (objectUtil) {\r\n    objectUtil.mergeShapes = (first, second) => {\r\n        return {\r\n            ...first,\r\n            ...second, // second overwrites first\r\n        };\r\n    };\r\n})(objectUtil || (objectUtil = {}));\r\nconst ZodParsedType = util.arrayToEnum([\r\n    \"string\",\r\n    \"nan\",\r\n    \"number\",\r\n    \"integer\",\r\n    \"float\",\r\n    \"boolean\",\r\n    \"date\",\r\n    \"bigint\",\r\n    \"symbol\",\r\n    \"function\",\r\n    \"undefined\",\r\n    \"null\",\r\n    \"array\",\r\n    \"object\",\r\n    \"unknown\",\r\n    \"promise\",\r\n    \"void\",\r\n    \"never\",\r\n    \"map\",\r\n    \"set\",\r\n]);\r\nconst getParsedType = (data) => {\r\n    const t = typeof data;\r\n    switch (t) {\r\n        case \"undefined\":\r\n            return ZodParsedType.undefined;\r\n        case \"string\":\r\n            return ZodParsedType.string;\r\n        case \"number\":\r\n            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\r\n        case \"boolean\":\r\n            return ZodParsedType.boolean;\r\n        case \"function\":\r\n            return ZodParsedType.function;\r\n        case \"bigint\":\r\n            return ZodParsedType.bigint;\r\n        case \"symbol\":\r\n            return ZodParsedType.symbol;\r\n        case \"object\":\r\n            if (Array.isArray(data)) {\r\n                return ZodParsedType.array;\r\n            }\r\n            if (data === null) {\r\n                return ZodParsedType.null;\r\n            }\r\n            if (data.then &&\r\n                typeof data.then === \"function\" &&\r\n                data.catch &&\r\n                typeof data.catch === \"function\") {\r\n                return ZodParsedType.promise;\r\n            }\r\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\r\n                return ZodParsedType.map;\r\n            }\r\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\r\n                return ZodParsedType.set;\r\n            }\r\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\r\n                return ZodParsedType.date;\r\n            }\r\n            return ZodParsedType.object;\r\n        default:\r\n            return ZodParsedType.unknown;\r\n    }\r\n};\r\n\r\nconst ZodIssueCode = util.arrayToEnum([\r\n    \"invalid_type\",\r\n    \"invalid_literal\",\r\n    \"custom\",\r\n    \"invalid_union\",\r\n    \"invalid_union_discriminator\",\r\n    \"invalid_enum_value\",\r\n    \"unrecognized_keys\",\r\n    \"invalid_arguments\",\r\n    \"invalid_return_type\",\r\n    \"invalid_date\",\r\n    \"invalid_string\",\r\n    \"too_small\",\r\n    \"too_big\",\r\n    \"invalid_intersection_types\",\r\n    \"not_multiple_of\",\r\n    \"not_finite\",\r\n]);\r\nconst quotelessJson = (obj) => {\r\n    const json = JSON.stringify(obj, null, 2);\r\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\r\n};\r\nclass ZodError extends Error {\r\n    constructor(issues) {\r\n        super();\r\n        this.issues = [];\r\n        this.addIssue = (sub) => {\r\n            this.issues = [...this.issues, sub];\r\n        };\r\n        this.addIssues = (subs = []) => {\r\n            this.issues = [...this.issues, ...subs];\r\n        };\r\n        const actualProto = new.target.prototype;\r\n        if (Object.setPrototypeOf) {\r\n            // eslint-disable-next-line ban/ban\r\n            Object.setPrototypeOf(this, actualProto);\r\n        }\r\n        else {\r\n            this.__proto__ = actualProto;\r\n        }\r\n        this.name = \"ZodError\";\r\n        this.issues = issues;\r\n    }\r\n    get errors() {\r\n        return this.issues;\r\n    }\r\n    format(_mapper) {\r\n        const mapper = _mapper ||\r\n            function (issue) {\r\n                return issue.message;\r\n            };\r\n        const fieldErrors = { _errors: [] };\r\n        const processError = (error) => {\r\n            for (const issue of error.issues) {\r\n                if (issue.code === \"invalid_union\") {\r\n                    issue.unionErrors.map(processError);\r\n                }\r\n                else if (issue.code === \"invalid_return_type\") {\r\n                    processError(issue.returnTypeError);\r\n                }\r\n                else if (issue.code === \"invalid_arguments\") {\r\n                    processError(issue.argumentsError);\r\n                }\r\n                else if (issue.path.length === 0) {\r\n                    fieldErrors._errors.push(mapper(issue));\r\n                }\r\n                else {\r\n                    let curr = fieldErrors;\r\n                    let i = 0;\r\n                    while (i < issue.path.length) {\r\n                        const el = issue.path[i];\r\n                        const terminal = i === issue.path.length - 1;\r\n                        if (!terminal) {\r\n                            curr[el] = curr[el] || { _errors: [] };\r\n                            // if (typeof el === \"string\") {\r\n                            //   curr[el] = curr[el] || { _errors: [] };\r\n                            // } else if (typeof el === \"number\") {\r\n                            //   const errorArray: any = [];\r\n                            //   errorArray._errors = [];\r\n                            //   curr[el] = curr[el] || errorArray;\r\n                            // }\r\n                        }\r\n                        else {\r\n                            curr[el] = curr[el] || { _errors: [] };\r\n                            curr[el]._errors.push(mapper(issue));\r\n                        }\r\n                        curr = curr[el];\r\n                        i++;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        processError(this);\r\n        return fieldErrors;\r\n    }\r\n    toString() {\r\n        return this.message;\r\n    }\r\n    get message() {\r\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\r\n    }\r\n    get isEmpty() {\r\n        return this.issues.length === 0;\r\n    }\r\n    flatten(mapper = (issue) => issue.message) {\r\n        const fieldErrors = {};\r\n        const formErrors = [];\r\n        for (const sub of this.issues) {\r\n            if (sub.path.length > 0) {\r\n                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\r\n                fieldErrors[sub.path[0]].push(mapper(sub));\r\n            }\r\n            else {\r\n                formErrors.push(mapper(sub));\r\n            }\r\n        }\r\n        return { formErrors, fieldErrors };\r\n    }\r\n    get formErrors() {\r\n        return this.flatten();\r\n    }\r\n}\r\nZodError.create = (issues) => {\r\n    const error = new ZodError(issues);\r\n    return error;\r\n};\r\n\r\nconst errorMap = (issue, _ctx) => {\r\n    let message;\r\n    switch (issue.code) {\r\n        case ZodIssueCode.invalid_type:\r\n            if (issue.received === ZodParsedType.undefined) {\r\n                message = \"Required\";\r\n            }\r\n            else {\r\n                message = `Expected ${issue.expected}, received ${issue.received}`;\r\n            }\r\n            break;\r\n        case ZodIssueCode.invalid_literal:\r\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\r\n            break;\r\n        case ZodIssueCode.unrecognized_keys:\r\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\r\n            break;\r\n        case ZodIssueCode.invalid_union:\r\n            message = `Invalid input`;\r\n            break;\r\n        case ZodIssueCode.invalid_union_discriminator:\r\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\r\n            break;\r\n        case ZodIssueCode.invalid_enum_value:\r\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\r\n            break;\r\n        case ZodIssueCode.invalid_arguments:\r\n            message = `Invalid function arguments`;\r\n            break;\r\n        case ZodIssueCode.invalid_return_type:\r\n            message = `Invalid function return type`;\r\n            break;\r\n        case ZodIssueCode.invalid_date:\r\n            message = `Invalid date`;\r\n            break;\r\n        case ZodIssueCode.invalid_string:\r\n            if (typeof issue.validation === \"object\") {\r\n                if (\"includes\" in issue.validation) {\r\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\r\n                    if (typeof issue.validation.position === \"number\") {\r\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\r\n                    }\r\n                }\r\n                else if (\"startsWith\" in issue.validation) {\r\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\r\n                }\r\n                else if (\"endsWith\" in issue.validation) {\r\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\r\n                }\r\n                else {\r\n                    util.assertNever(issue.validation);\r\n                }\r\n            }\r\n            else if (issue.validation !== \"regex\") {\r\n                message = `Invalid ${issue.validation}`;\r\n            }\r\n            else {\r\n                message = \"Invalid\";\r\n            }\r\n            break;\r\n        case ZodIssueCode.too_small:\r\n            if (issue.type === \"array\")\r\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\r\n            else if (issue.type === \"string\")\r\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\r\n            else if (issue.type === \"number\")\r\n                message = `Number must be ${issue.exact\r\n                    ? `exactly equal to `\r\n                    : issue.inclusive\r\n                        ? `greater than or equal to `\r\n                        : `greater than `}${issue.minimum}`;\r\n            else if (issue.type === \"date\")\r\n                message = `Date must be ${issue.exact\r\n                    ? `exactly equal to `\r\n                    : issue.inclusive\r\n                        ? `greater than or equal to `\r\n                        : `greater than `}${new Date(Number(issue.minimum))}`;\r\n            else\r\n                message = \"Invalid input\";\r\n            break;\r\n        case ZodIssueCode.too_big:\r\n            if (issue.type === \"array\")\r\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\r\n            else if (issue.type === \"string\")\r\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\r\n            else if (issue.type === \"number\")\r\n                message = `Number must be ${issue.exact\r\n                    ? `exactly`\r\n                    : issue.inclusive\r\n                        ? `less than or equal to`\r\n                        : `less than`} ${issue.maximum}`;\r\n            else if (issue.type === \"bigint\")\r\n                message = `BigInt must be ${issue.exact\r\n                    ? `exactly`\r\n                    : issue.inclusive\r\n                        ? `less than or equal to`\r\n                        : `less than`} ${issue.maximum}`;\r\n            else if (issue.type === \"date\")\r\n                message = `Date must be ${issue.exact\r\n                    ? `exactly`\r\n                    : issue.inclusive\r\n                        ? `smaller than or equal to`\r\n                        : `smaller than`} ${new Date(Number(issue.maximum))}`;\r\n            else\r\n                message = \"Invalid input\";\r\n            break;\r\n        case ZodIssueCode.custom:\r\n            message = `Invalid input`;\r\n            break;\r\n        case ZodIssueCode.invalid_intersection_types:\r\n            message = `Intersection results could not be merged`;\r\n            break;\r\n        case ZodIssueCode.not_multiple_of:\r\n            message = `Number must be a multiple of ${issue.multipleOf}`;\r\n            break;\r\n        case ZodIssueCode.not_finite:\r\n            message = \"Number must be finite\";\r\n            break;\r\n        default:\r\n            message = _ctx.defaultError;\r\n            util.assertNever(issue);\r\n    }\r\n    return { message };\r\n};\r\n\r\nlet overrideErrorMap = errorMap;\r\nfunction setErrorMap(map) {\r\n    overrideErrorMap = map;\r\n}\r\nfunction getErrorMap() {\r\n    return overrideErrorMap;\r\n}\r\n\r\nconst makeIssue = (params) => {\r\n    const { data, path, errorMaps, issueData } = params;\r\n    const fullPath = [...path, ...(issueData.path || [])];\r\n    const fullIssue = {\r\n        ...issueData,\r\n        path: fullPath,\r\n    };\r\n    let errorMessage = \"\";\r\n    const maps = errorMaps\r\n        .filter((m) => !!m)\r\n        .slice()\r\n        .reverse();\r\n    for (const map of maps) {\r\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\r\n    }\r\n    return {\r\n        ...issueData,\r\n        path: fullPath,\r\n        message: issueData.message || errorMessage,\r\n    };\r\n};\r\nconst EMPTY_PATH = [];\r\nfunction addIssueToContext(ctx, issueData) {\r\n    const issue = makeIssue({\r\n        issueData: issueData,\r\n        data: ctx.data,\r\n        path: ctx.path,\r\n        errorMaps: [\r\n            ctx.common.contextualErrorMap,\r\n            ctx.schemaErrorMap,\r\n            getErrorMap(),\r\n            errorMap, // then global default map\r\n        ].filter((x) => !!x),\r\n    });\r\n    ctx.common.issues.push(issue);\r\n}\r\nclass ParseStatus {\r\n    constructor() {\r\n        this.value = \"valid\";\r\n    }\r\n    dirty() {\r\n        if (this.value === \"valid\")\r\n            this.value = \"dirty\";\r\n    }\r\n    abort() {\r\n        if (this.value !== \"aborted\")\r\n            this.value = \"aborted\";\r\n    }\r\n    static mergeArray(status, results) {\r\n        const arrayValue = [];\r\n        for (const s of results) {\r\n            if (s.status === \"aborted\")\r\n                return INVALID;\r\n            if (s.status === \"dirty\")\r\n                status.dirty();\r\n            arrayValue.push(s.value);\r\n        }\r\n        return { status: status.value, value: arrayValue };\r\n    }\r\n    static async mergeObjectAsync(status, pairs) {\r\n        const syncPairs = [];\r\n        for (const pair of pairs) {\r\n            syncPairs.push({\r\n                key: await pair.key,\r\n                value: await pair.value,\r\n            });\r\n        }\r\n        return ParseStatus.mergeObjectSync(status, syncPairs);\r\n    }\r\n    static mergeObjectSync(status, pairs) {\r\n        const finalObject = {};\r\n        for (const pair of pairs) {\r\n            const { key, value } = pair;\r\n            if (key.status === \"aborted\")\r\n                return INVALID;\r\n            if (value.status === \"aborted\")\r\n                return INVALID;\r\n            if (key.status === \"dirty\")\r\n                status.dirty();\r\n            if (value.status === \"dirty\")\r\n                status.dirty();\r\n            if (key.value !== \"__proto__\" &&\r\n                (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\r\n                finalObject[key.value] = value.value;\r\n            }\r\n        }\r\n        return { status: status.value, value: finalObject };\r\n    }\r\n}\r\nconst INVALID = Object.freeze({\r\n    status: \"aborted\",\r\n});\r\nconst DIRTY = (value) => ({ status: \"dirty\", value });\r\nconst OK = (value) => ({ status: \"valid\", value });\r\nconst isAborted = (x) => x.status === \"aborted\";\r\nconst isDirty = (x) => x.status === \"dirty\";\r\nconst isValid = (x) => x.status === \"valid\";\r\nconst isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\r\n\r\nvar errorUtil;\r\n(function (errorUtil) {\r\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\r\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\r\n})(errorUtil || (errorUtil = {}));\r\n\r\nclass ParseInputLazyPath {\r\n    constructor(parent, value, path, key) {\r\n        this._cachedPath = [];\r\n        this.parent = parent;\r\n        this.data = value;\r\n        this._path = path;\r\n        this._key = key;\r\n    }\r\n    get path() {\r\n        if (!this._cachedPath.length) {\r\n            if (this._key instanceof Array) {\r\n                this._cachedPath.push(...this._path, ...this._key);\r\n            }\r\n            else {\r\n                this._cachedPath.push(...this._path, this._key);\r\n            }\r\n        }\r\n        return this._cachedPath;\r\n    }\r\n}\r\nconst handleResult = (ctx, result) => {\r\n    if (isValid(result)) {\r\n        return { success: true, data: result.value };\r\n    }\r\n    else {\r\n        if (!ctx.common.issues.length) {\r\n            throw new Error(\"Validation failed but no issues detected.\");\r\n        }\r\n        return {\r\n            success: false,\r\n            get error() {\r\n                if (this._error)\r\n                    return this._error;\r\n                const error = new ZodError(ctx.common.issues);\r\n                this._error = error;\r\n                return this._error;\r\n            },\r\n        };\r\n    }\r\n};\r\nfunction processCreateParams(params) {\r\n    if (!params)\r\n        return {};\r\n    const { errorMap, invalid_type_error, required_error, description } = params;\r\n    if (errorMap && (invalid_type_error || required_error)) {\r\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\r\n    }\r\n    if (errorMap)\r\n        return { errorMap: errorMap, description };\r\n    const customMap = (iss, ctx) => {\r\n        if (iss.code !== \"invalid_type\")\r\n            return { message: ctx.defaultError };\r\n        if (typeof ctx.data === \"undefined\") {\r\n            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };\r\n        }\r\n        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };\r\n    };\r\n    return { errorMap: customMap, description };\r\n}\r\nclass ZodType {\r\n    constructor(def) {\r\n        /** Alias of safeParseAsync */\r\n        this.spa = this.safeParseAsync;\r\n        this._def = def;\r\n        this.parse = this.parse.bind(this);\r\n        this.safeParse = this.safeParse.bind(this);\r\n        this.parseAsync = this.parseAsync.bind(this);\r\n        this.safeParseAsync = this.safeParseAsync.bind(this);\r\n        this.spa = this.spa.bind(this);\r\n        this.refine = this.refine.bind(this);\r\n        this.refinement = this.refinement.bind(this);\r\n        this.superRefine = this.superRefine.bind(this);\r\n        this.optional = this.optional.bind(this);\r\n        this.nullable = this.nullable.bind(this);\r\n        this.nullish = this.nullish.bind(this);\r\n        this.array = this.array.bind(this);\r\n        this.promise = this.promise.bind(this);\r\n        this.or = this.or.bind(this);\r\n        this.and = this.and.bind(this);\r\n        this.transform = this.transform.bind(this);\r\n        this.brand = this.brand.bind(this);\r\n        this.default = this.default.bind(this);\r\n        this.catch = this.catch.bind(this);\r\n        this.describe = this.describe.bind(this);\r\n        this.pipe = this.pipe.bind(this);\r\n        this.readonly = this.readonly.bind(this);\r\n        this.isNullable = this.isNullable.bind(this);\r\n        this.isOptional = this.isOptional.bind(this);\r\n    }\r\n    get description() {\r\n        return this._def.description;\r\n    }\r\n    _getType(input) {\r\n        return getParsedType(input.data);\r\n    }\r\n    _getOrReturnCtx(input, ctx) {\r\n        return (ctx || {\r\n            common: input.parent.common,\r\n            data: input.data,\r\n            parsedType: getParsedType(input.data),\r\n            schemaErrorMap: this._def.errorMap,\r\n            path: input.path,\r\n            parent: input.parent,\r\n        });\r\n    }\r\n    _processInputParams(input) {\r\n        return {\r\n            status: new ParseStatus(),\r\n            ctx: {\r\n                common: input.parent.common,\r\n                data: input.data,\r\n                parsedType: getParsedType(input.data),\r\n                schemaErrorMap: this._def.errorMap,\r\n                path: input.path,\r\n                parent: input.parent,\r\n            },\r\n        };\r\n    }\r\n    _parseSync(input) {\r\n        const result = this._parse(input);\r\n        if (isAsync(result)) {\r\n            throw new Error(\"Synchronous parse encountered promise.\");\r\n        }\r\n        return result;\r\n    }\r\n    _parseAsync(input) {\r\n        const result = this._parse(input);\r\n        return Promise.resolve(result);\r\n    }\r\n    parse(data, params) {\r\n        const result = this.safeParse(data, params);\r\n        if (result.success)\r\n            return result.data;\r\n        throw result.error;\r\n    }\r\n    safeParse(data, params) {\r\n        var _a;\r\n        const ctx = {\r\n            common: {\r\n                issues: [],\r\n                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,\r\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\r\n            },\r\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\r\n            schemaErrorMap: this._def.errorMap,\r\n            parent: null,\r\n            data,\r\n            parsedType: getParsedType(data),\r\n        };\r\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\r\n        return handleResult(ctx, result);\r\n    }\r\n    async parseAsync(data, params) {\r\n        const result = await this.safeParseAsync(data, params);\r\n        if (result.success)\r\n            return result.data;\r\n        throw result.error;\r\n    }\r\n    async safeParseAsync(data, params) {\r\n        const ctx = {\r\n            common: {\r\n                issues: [],\r\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\r\n                async: true,\r\n            },\r\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\r\n            schemaErrorMap: this._def.errorMap,\r\n            parent: null,\r\n            data,\r\n            parsedType: getParsedType(data),\r\n        };\r\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\r\n        const result = await (isAsync(maybeAsyncResult)\r\n            ? maybeAsyncResult\r\n            : Promise.resolve(maybeAsyncResult));\r\n        return handleResult(ctx, result);\r\n    }\r\n    refine(check, message) {\r\n        const getIssueProperties = (val) => {\r\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\r\n                return { message };\r\n            }\r\n            else if (typeof message === \"function\") {\r\n                return message(val);\r\n            }\r\n            else {\r\n                return message;\r\n            }\r\n        };\r\n        return this._refinement((val, ctx) => {\r\n            const result = check(val);\r\n            const setError = () => ctx.addIssue({\r\n                code: ZodIssueCode.custom,\r\n                ...getIssueProperties(val),\r\n            });\r\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\r\n                return result.then((data) => {\r\n                    if (!data) {\r\n                        setError();\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        return true;\r\n                    }\r\n                });\r\n            }\r\n            if (!result) {\r\n                setError();\r\n                return false;\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        });\r\n    }\r\n    refinement(check, refinementData) {\r\n        return this._refinement((val, ctx) => {\r\n            if (!check(val)) {\r\n                ctx.addIssue(typeof refinementData === \"function\"\r\n                    ? refinementData(val, ctx)\r\n                    : refinementData);\r\n                return false;\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        });\r\n    }\r\n    _refinement(refinement) {\r\n        return new ZodEffects({\r\n            schema: this,\r\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\r\n            effect: { type: \"refinement\", refinement },\r\n        });\r\n    }\r\n    superRefine(refinement) {\r\n        return this._refinement(refinement);\r\n    }\r\n    optional() {\r\n        return ZodOptional.create(this, this._def);\r\n    }\r\n    nullable() {\r\n        return ZodNullable.create(this, this._def);\r\n    }\r\n    nullish() {\r\n        return this.nullable().optional();\r\n    }\r\n    array() {\r\n        return ZodArray.create(this, this._def);\r\n    }\r\n    promise() {\r\n        return ZodPromise.create(this, this._def);\r\n    }\r\n    or(option) {\r\n        return ZodUnion.create([this, option], this._def);\r\n    }\r\n    and(incoming) {\r\n        return ZodIntersection.create(this, incoming, this._def);\r\n    }\r\n    transform(transform) {\r\n        return new ZodEffects({\r\n            ...processCreateParams(this._def),\r\n            schema: this,\r\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\r\n            effect: { type: \"transform\", transform },\r\n        });\r\n    }\r\n    default(def) {\r\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\r\n        return new ZodDefault({\r\n            ...processCreateParams(this._def),\r\n            innerType: this,\r\n            defaultValue: defaultValueFunc,\r\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\r\n        });\r\n    }\r\n    brand() {\r\n        return new ZodBranded({\r\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\r\n            type: this,\r\n            ...processCreateParams(this._def),\r\n        });\r\n    }\r\n    catch(def) {\r\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\r\n        return new ZodCatch({\r\n            ...processCreateParams(this._def),\r\n            innerType: this,\r\n            catchValue: catchValueFunc,\r\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\r\n        });\r\n    }\r\n    describe(description) {\r\n        const This = this.constructor;\r\n        return new This({\r\n            ...this._def,\r\n            description,\r\n        });\r\n    }\r\n    pipe(target) {\r\n        return ZodPipeline.create(this, target);\r\n    }\r\n    readonly() {\r\n        return ZodReadonly.create(this);\r\n    }\r\n    isOptional() {\r\n        return this.safeParse(undefined).success;\r\n    }\r\n    isNullable() {\r\n        return this.safeParse(null).success;\r\n    }\r\n}\r\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\r\nconst cuid2Regex = /^[a-z][a-z0-9]*$/;\r\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;\r\n// const uuidRegex =\r\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\r\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\r\n// from https://stackoverflow.com/a/46181/1550155\r\n// old version: too slow, didn't support unicode\r\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\r\n//old email regex\r\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\r\n// eslint-disable-next-line\r\n// const emailRegex =\r\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\r\n// const emailRegex =\r\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\r\n// const emailRegex =\r\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\r\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_+-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\r\n// const emailRegex =\r\n//   /^[a-z0-9.!#$%&â€™*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\r\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\r\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\r\nlet emojiRegex;\r\nconst ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;\r\nconst ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\r\n// Adapted from https://stackoverflow.com/a/3143231\r\nconst datetimeRegex = (args) => {\r\n    if (args.precision) {\r\n        if (args.offset) {\r\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${args.precision}}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\r\n        }\r\n        else {\r\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${args.precision}}Z$`);\r\n        }\r\n    }\r\n    else if (args.precision === 0) {\r\n        if (args.offset) {\r\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\r\n        }\r\n        else {\r\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}Z$`);\r\n        }\r\n    }\r\n    else {\r\n        if (args.offset) {\r\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\r\n        }\r\n        else {\r\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?Z$`);\r\n        }\r\n    }\r\n};\r\nfunction isValidIP(ip, version) {\r\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\r\n        return true;\r\n    }\r\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nclass ZodString extends ZodType {\r\n    _parse(input) {\r\n        if (this._def.coerce) {\r\n            input.data = String(input.data);\r\n        }\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.string) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.string,\r\n                received: ctx.parsedType,\r\n            }\r\n            //\r\n            );\r\n            return INVALID;\r\n        }\r\n        const status = new ParseStatus();\r\n        let ctx = undefined;\r\n        for (const check of this._def.checks) {\r\n            if (check.kind === \"min\") {\r\n                if (input.data.length < check.value) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_small,\r\n                        minimum: check.value,\r\n                        type: \"string\",\r\n                        inclusive: true,\r\n                        exact: false,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"max\") {\r\n                if (input.data.length > check.value) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_big,\r\n                        maximum: check.value,\r\n                        type: \"string\",\r\n                        inclusive: true,\r\n                        exact: false,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"length\") {\r\n                const tooBig = input.data.length > check.value;\r\n                const tooSmall = input.data.length < check.value;\r\n                if (tooBig || tooSmall) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    if (tooBig) {\r\n                        addIssueToContext(ctx, {\r\n                            code: ZodIssueCode.too_big,\r\n                            maximum: check.value,\r\n                            type: \"string\",\r\n                            inclusive: true,\r\n                            exact: true,\r\n                            message: check.message,\r\n                        });\r\n                    }\r\n                    else if (tooSmall) {\r\n                        addIssueToContext(ctx, {\r\n                            code: ZodIssueCode.too_small,\r\n                            minimum: check.value,\r\n                            type: \"string\",\r\n                            inclusive: true,\r\n                            exact: true,\r\n                            message: check.message,\r\n                        });\r\n                    }\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"email\") {\r\n                if (!emailRegex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"email\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"emoji\") {\r\n                if (!emojiRegex) {\r\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\r\n                }\r\n                if (!emojiRegex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"emoji\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"uuid\") {\r\n                if (!uuidRegex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"uuid\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"cuid\") {\r\n                if (!cuidRegex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"cuid\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"cuid2\") {\r\n                if (!cuid2Regex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"cuid2\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"ulid\") {\r\n                if (!ulidRegex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"ulid\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"url\") {\r\n                try {\r\n                    new URL(input.data);\r\n                }\r\n                catch (_a) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"url\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"regex\") {\r\n                check.regex.lastIndex = 0;\r\n                const testResult = check.regex.test(input.data);\r\n                if (!testResult) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"regex\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"trim\") {\r\n                input.data = input.data.trim();\r\n            }\r\n            else if (check.kind === \"includes\") {\r\n                if (!input.data.includes(check.value, check.position)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.invalid_string,\r\n                        validation: { includes: check.value, position: check.position },\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"toLowerCase\") {\r\n                input.data = input.data.toLowerCase();\r\n            }\r\n            else if (check.kind === \"toUpperCase\") {\r\n                input.data = input.data.toUpperCase();\r\n            }\r\n            else if (check.kind === \"startsWith\") {\r\n                if (!input.data.startsWith(check.value)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.invalid_string,\r\n                        validation: { startsWith: check.value },\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"endsWith\") {\r\n                if (!input.data.endsWith(check.value)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.invalid_string,\r\n                        validation: { endsWith: check.value },\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"datetime\") {\r\n                const regex = datetimeRegex(check);\r\n                if (!regex.test(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.invalid_string,\r\n                        validation: \"datetime\",\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"ip\") {\r\n                if (!isValidIP(input.data, check.version)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        validation: \"ip\",\r\n                        code: ZodIssueCode.invalid_string,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else {\r\n                util.assertNever(check);\r\n            }\r\n        }\r\n        return { status: status.value, value: input.data };\r\n    }\r\n    _regex(regex, validation, message) {\r\n        return this.refinement((data) => regex.test(data), {\r\n            validation,\r\n            code: ZodIssueCode.invalid_string,\r\n            ...errorUtil.errToObj(message),\r\n        });\r\n    }\r\n    _addCheck(check) {\r\n        return new ZodString({\r\n            ...this._def,\r\n            checks: [...this._def.checks, check],\r\n        });\r\n    }\r\n    email(message) {\r\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\r\n    }\r\n    url(message) {\r\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\r\n    }\r\n    emoji(message) {\r\n        return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\r\n    }\r\n    uuid(message) {\r\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\r\n    }\r\n    cuid(message) {\r\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\r\n    }\r\n    cuid2(message) {\r\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\r\n    }\r\n    ulid(message) {\r\n        return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\r\n    }\r\n    ip(options) {\r\n        return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\r\n    }\r\n    datetime(options) {\r\n        var _a;\r\n        if (typeof options === \"string\") {\r\n            return this._addCheck({\r\n                kind: \"datetime\",\r\n                precision: null,\r\n                offset: false,\r\n                message: options,\r\n            });\r\n        }\r\n        return this._addCheck({\r\n            kind: \"datetime\",\r\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\r\n            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,\r\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\r\n        });\r\n    }\r\n    regex(regex, message) {\r\n        return this._addCheck({\r\n            kind: \"regex\",\r\n            regex: regex,\r\n            ...errorUtil.errToObj(message),\r\n        });\r\n    }\r\n    includes(value, options) {\r\n        return this._addCheck({\r\n            kind: \"includes\",\r\n            value: value,\r\n            position: options === null || options === void 0 ? void 0 : options.position,\r\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\r\n        });\r\n    }\r\n    startsWith(value, message) {\r\n        return this._addCheck({\r\n            kind: \"startsWith\",\r\n            value: value,\r\n            ...errorUtil.errToObj(message),\r\n        });\r\n    }\r\n    endsWith(value, message) {\r\n        return this._addCheck({\r\n            kind: \"endsWith\",\r\n            value: value,\r\n            ...errorUtil.errToObj(message),\r\n        });\r\n    }\r\n    min(minLength, message) {\r\n        return this._addCheck({\r\n            kind: \"min\",\r\n            value: minLength,\r\n            ...errorUtil.errToObj(message),\r\n        });\r\n    }\r\n    max(maxLength, message) {\r\n        return this._addCheck({\r\n            kind: \"max\",\r\n            value: maxLength,\r\n            ...errorUtil.errToObj(message),\r\n        });\r\n    }\r\n    length(len, message) {\r\n        return this._addCheck({\r\n            kind: \"length\",\r\n            value: len,\r\n            ...errorUtil.errToObj(message),\r\n        });\r\n    }\r\n    /**\r\n     * @deprecated Use z.string().min(1) instead.\r\n     * @see {@link ZodString.min}\r\n     */\r\n    nonempty(message) {\r\n        return this.min(1, errorUtil.errToObj(message));\r\n    }\r\n    trim() {\r\n        return new ZodString({\r\n            ...this._def,\r\n            checks: [...this._def.checks, { kind: \"trim\" }],\r\n        });\r\n    }\r\n    toLowerCase() {\r\n        return new ZodString({\r\n            ...this._def,\r\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\r\n        });\r\n    }\r\n    toUpperCase() {\r\n        return new ZodString({\r\n            ...this._def,\r\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\r\n        });\r\n    }\r\n    get isDatetime() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\r\n    }\r\n    get isEmail() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\r\n    }\r\n    get isURL() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\r\n    }\r\n    get isEmoji() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\r\n    }\r\n    get isUUID() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\r\n    }\r\n    get isCUID() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\r\n    }\r\n    get isCUID2() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\r\n    }\r\n    get isULID() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\r\n    }\r\n    get isIP() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\r\n    }\r\n    get minLength() {\r\n        let min = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"min\") {\r\n                if (min === null || ch.value > min)\r\n                    min = ch.value;\r\n            }\r\n        }\r\n        return min;\r\n    }\r\n    get maxLength() {\r\n        let max = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"max\") {\r\n                if (max === null || ch.value < max)\r\n                    max = ch.value;\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n}\r\nZodString.create = (params) => {\r\n    var _a;\r\n    return new ZodString({\r\n        checks: [],\r\n        typeName: ZodFirstPartyTypeKind.ZodString,\r\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\r\nfunction floatSafeRemainder(val, step) {\r\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\r\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\r\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\r\n    const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\r\n    const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\r\n    return (valInt % stepInt) / Math.pow(10, decCount);\r\n}\r\nclass ZodNumber extends ZodType {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.min = this.gte;\r\n        this.max = this.lte;\r\n        this.step = this.multipleOf;\r\n    }\r\n    _parse(input) {\r\n        if (this._def.coerce) {\r\n            input.data = Number(input.data);\r\n        }\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.number) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.number,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        let ctx = undefined;\r\n        const status = new ParseStatus();\r\n        for (const check of this._def.checks) {\r\n            if (check.kind === \"int\") {\r\n                if (!util.isInteger(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.invalid_type,\r\n                        expected: \"integer\",\r\n                        received: \"float\",\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"min\") {\r\n                const tooSmall = check.inclusive\r\n                    ? input.data < check.value\r\n                    : input.data <= check.value;\r\n                if (tooSmall) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_small,\r\n                        minimum: check.value,\r\n                        type: \"number\",\r\n                        inclusive: check.inclusive,\r\n                        exact: false,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"max\") {\r\n                const tooBig = check.inclusive\r\n                    ? input.data > check.value\r\n                    : input.data >= check.value;\r\n                if (tooBig) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_big,\r\n                        maximum: check.value,\r\n                        type: \"number\",\r\n                        inclusive: check.inclusive,\r\n                        exact: false,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"multipleOf\") {\r\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.not_multiple_of,\r\n                        multipleOf: check.value,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"finite\") {\r\n                if (!Number.isFinite(input.data)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.not_finite,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else {\r\n                util.assertNever(check);\r\n            }\r\n        }\r\n        return { status: status.value, value: input.data };\r\n    }\r\n    gte(value, message) {\r\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\r\n    }\r\n    gt(value, message) {\r\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\r\n    }\r\n    lte(value, message) {\r\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\r\n    }\r\n    lt(value, message) {\r\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\r\n    }\r\n    setLimit(kind, value, inclusive, message) {\r\n        return new ZodNumber({\r\n            ...this._def,\r\n            checks: [\r\n                ...this._def.checks,\r\n                {\r\n                    kind,\r\n                    value,\r\n                    inclusive,\r\n                    message: errorUtil.toString(message),\r\n                },\r\n            ],\r\n        });\r\n    }\r\n    _addCheck(check) {\r\n        return new ZodNumber({\r\n            ...this._def,\r\n            checks: [...this._def.checks, check],\r\n        });\r\n    }\r\n    int(message) {\r\n        return this._addCheck({\r\n            kind: \"int\",\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    positive(message) {\r\n        return this._addCheck({\r\n            kind: \"min\",\r\n            value: 0,\r\n            inclusive: false,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    negative(message) {\r\n        return this._addCheck({\r\n            kind: \"max\",\r\n            value: 0,\r\n            inclusive: false,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    nonpositive(message) {\r\n        return this._addCheck({\r\n            kind: \"max\",\r\n            value: 0,\r\n            inclusive: true,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    nonnegative(message) {\r\n        return this._addCheck({\r\n            kind: \"min\",\r\n            value: 0,\r\n            inclusive: true,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    multipleOf(value, message) {\r\n        return this._addCheck({\r\n            kind: \"multipleOf\",\r\n            value: value,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    finite(message) {\r\n        return this._addCheck({\r\n            kind: \"finite\",\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    safe(message) {\r\n        return this._addCheck({\r\n            kind: \"min\",\r\n            inclusive: true,\r\n            value: Number.MIN_SAFE_INTEGER,\r\n            message: errorUtil.toString(message),\r\n        })._addCheck({\r\n            kind: \"max\",\r\n            inclusive: true,\r\n            value: Number.MAX_SAFE_INTEGER,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    get minValue() {\r\n        let min = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"min\") {\r\n                if (min === null || ch.value > min)\r\n                    min = ch.value;\r\n            }\r\n        }\r\n        return min;\r\n    }\r\n    get maxValue() {\r\n        let max = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"max\") {\r\n                if (max === null || ch.value < max)\r\n                    max = ch.value;\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n    get isInt() {\r\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" ||\r\n            (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\r\n    }\r\n    get isFinite() {\r\n        let max = null, min = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"finite\" ||\r\n                ch.kind === \"int\" ||\r\n                ch.kind === \"multipleOf\") {\r\n                return true;\r\n            }\r\n            else if (ch.kind === \"min\") {\r\n                if (min === null || ch.value > min)\r\n                    min = ch.value;\r\n            }\r\n            else if (ch.kind === \"max\") {\r\n                if (max === null || ch.value < max)\r\n                    max = ch.value;\r\n            }\r\n        }\r\n        return Number.isFinite(min) && Number.isFinite(max);\r\n    }\r\n}\r\nZodNumber.create = (params) => {\r\n    return new ZodNumber({\r\n        checks: [],\r\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\r\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodBigInt extends ZodType {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.min = this.gte;\r\n        this.max = this.lte;\r\n    }\r\n    _parse(input) {\r\n        if (this._def.coerce) {\r\n            input.data = BigInt(input.data);\r\n        }\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.bigint) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.bigint,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        let ctx = undefined;\r\n        const status = new ParseStatus();\r\n        for (const check of this._def.checks) {\r\n            if (check.kind === \"min\") {\r\n                const tooSmall = check.inclusive\r\n                    ? input.data < check.value\r\n                    : input.data <= check.value;\r\n                if (tooSmall) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_small,\r\n                        type: \"bigint\",\r\n                        minimum: check.value,\r\n                        inclusive: check.inclusive,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"max\") {\r\n                const tooBig = check.inclusive\r\n                    ? input.data > check.value\r\n                    : input.data >= check.value;\r\n                if (tooBig) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_big,\r\n                        type: \"bigint\",\r\n                        maximum: check.value,\r\n                        inclusive: check.inclusive,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"multipleOf\") {\r\n                if (input.data % check.value !== BigInt(0)) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.not_multiple_of,\r\n                        multipleOf: check.value,\r\n                        message: check.message,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else {\r\n                util.assertNever(check);\r\n            }\r\n        }\r\n        return { status: status.value, value: input.data };\r\n    }\r\n    gte(value, message) {\r\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\r\n    }\r\n    gt(value, message) {\r\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\r\n    }\r\n    lte(value, message) {\r\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\r\n    }\r\n    lt(value, message) {\r\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\r\n    }\r\n    setLimit(kind, value, inclusive, message) {\r\n        return new ZodBigInt({\r\n            ...this._def,\r\n            checks: [\r\n                ...this._def.checks,\r\n                {\r\n                    kind,\r\n                    value,\r\n                    inclusive,\r\n                    message: errorUtil.toString(message),\r\n                },\r\n            ],\r\n        });\r\n    }\r\n    _addCheck(check) {\r\n        return new ZodBigInt({\r\n            ...this._def,\r\n            checks: [...this._def.checks, check],\r\n        });\r\n    }\r\n    positive(message) {\r\n        return this._addCheck({\r\n            kind: \"min\",\r\n            value: BigInt(0),\r\n            inclusive: false,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    negative(message) {\r\n        return this._addCheck({\r\n            kind: \"max\",\r\n            value: BigInt(0),\r\n            inclusive: false,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    nonpositive(message) {\r\n        return this._addCheck({\r\n            kind: \"max\",\r\n            value: BigInt(0),\r\n            inclusive: true,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    nonnegative(message) {\r\n        return this._addCheck({\r\n            kind: \"min\",\r\n            value: BigInt(0),\r\n            inclusive: true,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    multipleOf(value, message) {\r\n        return this._addCheck({\r\n            kind: \"multipleOf\",\r\n            value,\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    get minValue() {\r\n        let min = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"min\") {\r\n                if (min === null || ch.value > min)\r\n                    min = ch.value;\r\n            }\r\n        }\r\n        return min;\r\n    }\r\n    get maxValue() {\r\n        let max = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"max\") {\r\n                if (max === null || ch.value < max)\r\n                    max = ch.value;\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n}\r\nZodBigInt.create = (params) => {\r\n    var _a;\r\n    return new ZodBigInt({\r\n        checks: [],\r\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\r\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodBoolean extends ZodType {\r\n    _parse(input) {\r\n        if (this._def.coerce) {\r\n            input.data = Boolean(input.data);\r\n        }\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.boolean) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.boolean,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return OK(input.data);\r\n    }\r\n}\r\nZodBoolean.create = (params) => {\r\n    return new ZodBoolean({\r\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\r\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodDate extends ZodType {\r\n    _parse(input) {\r\n        if (this._def.coerce) {\r\n            input.data = new Date(input.data);\r\n        }\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.date) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.date,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        if (isNaN(input.data.getTime())) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_date,\r\n            });\r\n            return INVALID;\r\n        }\r\n        const status = new ParseStatus();\r\n        let ctx = undefined;\r\n        for (const check of this._def.checks) {\r\n            if (check.kind === \"min\") {\r\n                if (input.data.getTime() < check.value) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_small,\r\n                        message: check.message,\r\n                        inclusive: true,\r\n                        exact: false,\r\n                        minimum: check.value,\r\n                        type: \"date\",\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (check.kind === \"max\") {\r\n                if (input.data.getTime() > check.value) {\r\n                    ctx = this._getOrReturnCtx(input, ctx);\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.too_big,\r\n                        message: check.message,\r\n                        inclusive: true,\r\n                        exact: false,\r\n                        maximum: check.value,\r\n                        type: \"date\",\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else {\r\n                util.assertNever(check);\r\n            }\r\n        }\r\n        return {\r\n            status: status.value,\r\n            value: new Date(input.data.getTime()),\r\n        };\r\n    }\r\n    _addCheck(check) {\r\n        return new ZodDate({\r\n            ...this._def,\r\n            checks: [...this._def.checks, check],\r\n        });\r\n    }\r\n    min(minDate, message) {\r\n        return this._addCheck({\r\n            kind: \"min\",\r\n            value: minDate.getTime(),\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    max(maxDate, message) {\r\n        return this._addCheck({\r\n            kind: \"max\",\r\n            value: maxDate.getTime(),\r\n            message: errorUtil.toString(message),\r\n        });\r\n    }\r\n    get minDate() {\r\n        let min = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"min\") {\r\n                if (min === null || ch.value > min)\r\n                    min = ch.value;\r\n            }\r\n        }\r\n        return min != null ? new Date(min) : null;\r\n    }\r\n    get maxDate() {\r\n        let max = null;\r\n        for (const ch of this._def.checks) {\r\n            if (ch.kind === \"max\") {\r\n                if (max === null || ch.value < max)\r\n                    max = ch.value;\r\n            }\r\n        }\r\n        return max != null ? new Date(max) : null;\r\n    }\r\n}\r\nZodDate.create = (params) => {\r\n    return new ZodDate({\r\n        checks: [],\r\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\r\n        typeName: ZodFirstPartyTypeKind.ZodDate,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodSymbol extends ZodType {\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.symbol) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.symbol,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return OK(input.data);\r\n    }\r\n}\r\nZodSymbol.create = (params) => {\r\n    return new ZodSymbol({\r\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodUndefined extends ZodType {\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.undefined) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.undefined,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return OK(input.data);\r\n    }\r\n}\r\nZodUndefined.create = (params) => {\r\n    return new ZodUndefined({\r\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodNull extends ZodType {\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.null) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.null,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return OK(input.data);\r\n    }\r\n}\r\nZodNull.create = (params) => {\r\n    return new ZodNull({\r\n        typeName: ZodFirstPartyTypeKind.ZodNull,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodAny extends ZodType {\r\n    constructor() {\r\n        super(...arguments);\r\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\r\n        this._any = true;\r\n    }\r\n    _parse(input) {\r\n        return OK(input.data);\r\n    }\r\n}\r\nZodAny.create = (params) => {\r\n    return new ZodAny({\r\n        typeName: ZodFirstPartyTypeKind.ZodAny,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodUnknown extends ZodType {\r\n    constructor() {\r\n        super(...arguments);\r\n        // required\r\n        this._unknown = true;\r\n    }\r\n    _parse(input) {\r\n        return OK(input.data);\r\n    }\r\n}\r\nZodUnknown.create = (params) => {\r\n    return new ZodUnknown({\r\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodNever extends ZodType {\r\n    _parse(input) {\r\n        const ctx = this._getOrReturnCtx(input);\r\n        addIssueToContext(ctx, {\r\n            code: ZodIssueCode.invalid_type,\r\n            expected: ZodParsedType.never,\r\n            received: ctx.parsedType,\r\n        });\r\n        return INVALID;\r\n    }\r\n}\r\nZodNever.create = (params) => {\r\n    return new ZodNever({\r\n        typeName: ZodFirstPartyTypeKind.ZodNever,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodVoid extends ZodType {\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.undefined) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.void,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return OK(input.data);\r\n    }\r\n}\r\nZodVoid.create = (params) => {\r\n    return new ZodVoid({\r\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodArray extends ZodType {\r\n    _parse(input) {\r\n        const { ctx, status } = this._processInputParams(input);\r\n        const def = this._def;\r\n        if (ctx.parsedType !== ZodParsedType.array) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.array,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        if (def.exactLength !== null) {\r\n            const tooBig = ctx.data.length > def.exactLength.value;\r\n            const tooSmall = ctx.data.length < def.exactLength.value;\r\n            if (tooBig || tooSmall) {\r\n                addIssueToContext(ctx, {\r\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\r\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\r\n                    maximum: (tooBig ? def.exactLength.value : undefined),\r\n                    type: \"array\",\r\n                    inclusive: true,\r\n                    exact: true,\r\n                    message: def.exactLength.message,\r\n                });\r\n                status.dirty();\r\n            }\r\n        }\r\n        if (def.minLength !== null) {\r\n            if (ctx.data.length < def.minLength.value) {\r\n                addIssueToContext(ctx, {\r\n                    code: ZodIssueCode.too_small,\r\n                    minimum: def.minLength.value,\r\n                    type: \"array\",\r\n                    inclusive: true,\r\n                    exact: false,\r\n                    message: def.minLength.message,\r\n                });\r\n                status.dirty();\r\n            }\r\n        }\r\n        if (def.maxLength !== null) {\r\n            if (ctx.data.length > def.maxLength.value) {\r\n                addIssueToContext(ctx, {\r\n                    code: ZodIssueCode.too_big,\r\n                    maximum: def.maxLength.value,\r\n                    type: \"array\",\r\n                    inclusive: true,\r\n                    exact: false,\r\n                    message: def.maxLength.message,\r\n                });\r\n                status.dirty();\r\n            }\r\n        }\r\n        if (ctx.common.async) {\r\n            return Promise.all([...ctx.data].map((item, i) => {\r\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\r\n            })).then((result) => {\r\n                return ParseStatus.mergeArray(status, result);\r\n            });\r\n        }\r\n        const result = [...ctx.data].map((item, i) => {\r\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\r\n        });\r\n        return ParseStatus.mergeArray(status, result);\r\n    }\r\n    get element() {\r\n        return this._def.type;\r\n    }\r\n    min(minLength, message) {\r\n        return new ZodArray({\r\n            ...this._def,\r\n            minLength: { value: minLength, message: errorUtil.toString(message) },\r\n        });\r\n    }\r\n    max(maxLength, message) {\r\n        return new ZodArray({\r\n            ...this._def,\r\n            maxLength: { value: maxLength, message: errorUtil.toString(message) },\r\n        });\r\n    }\r\n    length(len, message) {\r\n        return new ZodArray({\r\n            ...this._def,\r\n            exactLength: { value: len, message: errorUtil.toString(message) },\r\n        });\r\n    }\r\n    nonempty(message) {\r\n        return this.min(1, message);\r\n    }\r\n}\r\nZodArray.create = (schema, params) => {\r\n    return new ZodArray({\r\n        type: schema,\r\n        minLength: null,\r\n        maxLength: null,\r\n        exactLength: null,\r\n        typeName: ZodFirstPartyTypeKind.ZodArray,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nfunction deepPartialify(schema) {\r\n    if (schema instanceof ZodObject) {\r\n        const newShape = {};\r\n        for (const key in schema.shape) {\r\n            const fieldSchema = schema.shape[key];\r\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\r\n        }\r\n        return new ZodObject({\r\n            ...schema._def,\r\n            shape: () => newShape,\r\n        });\r\n    }\r\n    else if (schema instanceof ZodArray) {\r\n        return new ZodArray({\r\n            ...schema._def,\r\n            type: deepPartialify(schema.element),\r\n        });\r\n    }\r\n    else if (schema instanceof ZodOptional) {\r\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\r\n    }\r\n    else if (schema instanceof ZodNullable) {\r\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\r\n    }\r\n    else if (schema instanceof ZodTuple) {\r\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\r\n    }\r\n    else {\r\n        return schema;\r\n    }\r\n}\r\nclass ZodObject extends ZodType {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._cached = null;\r\n        /**\r\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\r\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\r\n         */\r\n        this.nonstrict = this.passthrough;\r\n        // extend<\r\n        //   Augmentation extends ZodRawShape,\r\n        //   NewOutput extends util.flatten<{\r\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\r\n        //       ? Augmentation[k][\"_output\"]\r\n        //       : k extends keyof Output\r\n        //       ? Output[k]\r\n        //       : never;\r\n        //   }>,\r\n        //   NewInput extends util.flatten<{\r\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\r\n        //       ? Augmentation[k][\"_input\"]\r\n        //       : k extends keyof Input\r\n        //       ? Input[k]\r\n        //       : never;\r\n        //   }>\r\n        // >(\r\n        //   augmentation: Augmentation\r\n        // ): ZodObject<\r\n        //   extendShape<T, Augmentation>,\r\n        //   UnknownKeys,\r\n        //   Catchall,\r\n        //   NewOutput,\r\n        //   NewInput\r\n        // > {\r\n        //   return new ZodObject({\r\n        //     ...this._def,\r\n        //     shape: () => ({\r\n        //       ...this._def.shape(),\r\n        //       ...augmentation,\r\n        //     }),\r\n        //   }) as any;\r\n        // }\r\n        /**\r\n         * @deprecated Use `.extend` instead\r\n         *  */\r\n        this.augment = this.extend;\r\n    }\r\n    _getCached() {\r\n        if (this._cached !== null)\r\n            return this._cached;\r\n        const shape = this._def.shape();\r\n        const keys = util.objectKeys(shape);\r\n        return (this._cached = { shape, keys });\r\n    }\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.object) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.object,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        const { status, ctx } = this._processInputParams(input);\r\n        const { shape, keys: shapeKeys } = this._getCached();\r\n        const extraKeys = [];\r\n        if (!(this._def.catchall instanceof ZodNever &&\r\n            this._def.unknownKeys === \"strip\")) {\r\n            for (const key in ctx.data) {\r\n                if (!shapeKeys.includes(key)) {\r\n                    extraKeys.push(key);\r\n                }\r\n            }\r\n        }\r\n        const pairs = [];\r\n        for (const key of shapeKeys) {\r\n            const keyValidator = shape[key];\r\n            const value = ctx.data[key];\r\n            pairs.push({\r\n                key: { status: \"valid\", value: key },\r\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\r\n                alwaysSet: key in ctx.data,\r\n            });\r\n        }\r\n        if (this._def.catchall instanceof ZodNever) {\r\n            const unknownKeys = this._def.unknownKeys;\r\n            if (unknownKeys === \"passthrough\") {\r\n                for (const key of extraKeys) {\r\n                    pairs.push({\r\n                        key: { status: \"valid\", value: key },\r\n                        value: { status: \"valid\", value: ctx.data[key] },\r\n                    });\r\n                }\r\n            }\r\n            else if (unknownKeys === \"strict\") {\r\n                if (extraKeys.length > 0) {\r\n                    addIssueToContext(ctx, {\r\n                        code: ZodIssueCode.unrecognized_keys,\r\n                        keys: extraKeys,\r\n                    });\r\n                    status.dirty();\r\n                }\r\n            }\r\n            else if (unknownKeys === \"strip\") ;\r\n            else {\r\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\r\n            }\r\n        }\r\n        else {\r\n            // run catchall validation\r\n            const catchall = this._def.catchall;\r\n            for (const key of extraKeys) {\r\n                const value = ctx.data[key];\r\n                pairs.push({\r\n                    key: { status: \"valid\", value: key },\r\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\r\n                    ),\r\n                    alwaysSet: key in ctx.data,\r\n                });\r\n            }\r\n        }\r\n        if (ctx.common.async) {\r\n            return Promise.resolve()\r\n                .then(async () => {\r\n                const syncPairs = [];\r\n                for (const pair of pairs) {\r\n                    const key = await pair.key;\r\n                    syncPairs.push({\r\n                        key,\r\n                        value: await pair.value,\r\n                        alwaysSet: pair.alwaysSet,\r\n                    });\r\n                }\r\n                return syncPairs;\r\n            })\r\n                .then((syncPairs) => {\r\n                return ParseStatus.mergeObjectSync(status, syncPairs);\r\n            });\r\n        }\r\n        else {\r\n            return ParseStatus.mergeObjectSync(status, pairs);\r\n        }\r\n    }\r\n    get shape() {\r\n        return this._def.shape();\r\n    }\r\n    strict(message) {\r\n        errorUtil.errToObj;\r\n        return new ZodObject({\r\n            ...this._def,\r\n            unknownKeys: \"strict\",\r\n            ...(message !== undefined\r\n                ? {\r\n                    errorMap: (issue, ctx) => {\r\n                        var _a, _b, _c, _d;\r\n                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\r\n                        if (issue.code === \"unrecognized_keys\")\r\n                            return {\r\n                                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,\r\n                            };\r\n                        return {\r\n                            message: defaultError,\r\n                        };\r\n                    },\r\n                }\r\n                : {}),\r\n        });\r\n    }\r\n    strip() {\r\n        return new ZodObject({\r\n            ...this._def,\r\n            unknownKeys: \"strip\",\r\n        });\r\n    }\r\n    passthrough() {\r\n        return new ZodObject({\r\n            ...this._def,\r\n            unknownKeys: \"passthrough\",\r\n        });\r\n    }\r\n    // const AugmentFactory =\r\n    //   <Def extends ZodObjectDef>(def: Def) =>\r\n    //   <Augmentation extends ZodRawShape>(\r\n    //     augmentation: Augmentation\r\n    //   ): ZodObject<\r\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\r\n    //     Def[\"unknownKeys\"],\r\n    //     Def[\"catchall\"]\r\n    //   > => {\r\n    //     return new ZodObject({\r\n    //       ...def,\r\n    //       shape: () => ({\r\n    //         ...def.shape(),\r\n    //         ...augmentation,\r\n    //       }),\r\n    //     }) as any;\r\n    //   };\r\n    extend(augmentation) {\r\n        return new ZodObject({\r\n            ...this._def,\r\n            shape: () => ({\r\n                ...this._def.shape(),\r\n                ...augmentation,\r\n            }),\r\n        });\r\n    }\r\n    /**\r\n     * Prior to zod@1.0.12 there was a bug in the\r\n     * inferred type of merged objects. Please\r\n     * upgrade if you are experiencing issues.\r\n     */\r\n    merge(merging) {\r\n        const merged = new ZodObject({\r\n            unknownKeys: merging._def.unknownKeys,\r\n            catchall: merging._def.catchall,\r\n            shape: () => ({\r\n                ...this._def.shape(),\r\n                ...merging._def.shape(),\r\n            }),\r\n            typeName: ZodFirstPartyTypeKind.ZodObject,\r\n        });\r\n        return merged;\r\n    }\r\n    // merge<\r\n    //   Incoming extends AnyZodObject,\r\n    //   Augmentation extends Incoming[\"shape\"],\r\n    //   NewOutput extends {\r\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\r\n    //       ? Augmentation[k][\"_output\"]\r\n    //       : k extends keyof Output\r\n    //       ? Output[k]\r\n    //       : never;\r\n    //   },\r\n    //   NewInput extends {\r\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\r\n    //       ? Augmentation[k][\"_input\"]\r\n    //       : k extends keyof Input\r\n    //       ? Input[k]\r\n    //       : never;\r\n    //   }\r\n    // >(\r\n    //   merging: Incoming\r\n    // ): ZodObject<\r\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\r\n    //   Incoming[\"_def\"][\"unknownKeys\"],\r\n    //   Incoming[\"_def\"][\"catchall\"],\r\n    //   NewOutput,\r\n    //   NewInput\r\n    // > {\r\n    //   const merged: any = new ZodObject({\r\n    //     unknownKeys: merging._def.unknownKeys,\r\n    //     catchall: merging._def.catchall,\r\n    //     shape: () =>\r\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\r\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\r\n    //   }) as any;\r\n    //   return merged;\r\n    // }\r\n    setKey(key, schema) {\r\n        return this.augment({ [key]: schema });\r\n    }\r\n    // merge<Incoming extends AnyZodObject>(\r\n    //   merging: Incoming\r\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\r\n    // ZodObject<\r\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\r\n    //   Incoming[\"_def\"][\"unknownKeys\"],\r\n    //   Incoming[\"_def\"][\"catchall\"]\r\n    // > {\r\n    //   // const mergedShape = objectUtil.mergeShapes(\r\n    //   //   this._def.shape(),\r\n    //   //   merging._def.shape()\r\n    //   // );\r\n    //   const merged: any = new ZodObject({\r\n    //     unknownKeys: merging._def.unknownKeys,\r\n    //     catchall: merging._def.catchall,\r\n    //     shape: () =>\r\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\r\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\r\n    //   }) as any;\r\n    //   return merged;\r\n    // }\r\n    catchall(index) {\r\n        return new ZodObject({\r\n            ...this._def,\r\n            catchall: index,\r\n        });\r\n    }\r\n    pick(mask) {\r\n        const shape = {};\r\n        util.objectKeys(mask).forEach((key) => {\r\n            if (mask[key] && this.shape[key]) {\r\n                shape[key] = this.shape[key];\r\n            }\r\n        });\r\n        return new ZodObject({\r\n            ...this._def,\r\n            shape: () => shape,\r\n        });\r\n    }\r\n    omit(mask) {\r\n        const shape = {};\r\n        util.objectKeys(this.shape).forEach((key) => {\r\n            if (!mask[key]) {\r\n                shape[key] = this.shape[key];\r\n            }\r\n        });\r\n        return new ZodObject({\r\n            ...this._def,\r\n            shape: () => shape,\r\n        });\r\n    }\r\n    /**\r\n     * @deprecated\r\n     */\r\n    deepPartial() {\r\n        return deepPartialify(this);\r\n    }\r\n    partial(mask) {\r\n        const newShape = {};\r\n        util.objectKeys(this.shape).forEach((key) => {\r\n            const fieldSchema = this.shape[key];\r\n            if (mask && !mask[key]) {\r\n                newShape[key] = fieldSchema;\r\n            }\r\n            else {\r\n                newShape[key] = fieldSchema.optional();\r\n            }\r\n        });\r\n        return new ZodObject({\r\n            ...this._def,\r\n            shape: () => newShape,\r\n        });\r\n    }\r\n    required(mask) {\r\n        const newShape = {};\r\n        util.objectKeys(this.shape).forEach((key) => {\r\n            if (mask && !mask[key]) {\r\n                newShape[key] = this.shape[key];\r\n            }\r\n            else {\r\n                const fieldSchema = this.shape[key];\r\n                let newField = fieldSchema;\r\n                while (newField instanceof ZodOptional) {\r\n                    newField = newField._def.innerType;\r\n                }\r\n                newShape[key] = newField;\r\n            }\r\n        });\r\n        return new ZodObject({\r\n            ...this._def,\r\n            shape: () => newShape,\r\n        });\r\n    }\r\n    keyof() {\r\n        return createZodEnum(util.objectKeys(this.shape));\r\n    }\r\n}\r\nZodObject.create = (shape, params) => {\r\n    return new ZodObject({\r\n        shape: () => shape,\r\n        unknownKeys: \"strip\",\r\n        catchall: ZodNever.create(),\r\n        typeName: ZodFirstPartyTypeKind.ZodObject,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nZodObject.strictCreate = (shape, params) => {\r\n    return new ZodObject({\r\n        shape: () => shape,\r\n        unknownKeys: \"strict\",\r\n        catchall: ZodNever.create(),\r\n        typeName: ZodFirstPartyTypeKind.ZodObject,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nZodObject.lazycreate = (shape, params) => {\r\n    return new ZodObject({\r\n        shape,\r\n        unknownKeys: \"strip\",\r\n        catchall: ZodNever.create(),\r\n        typeName: ZodFirstPartyTypeKind.ZodObject,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodUnion extends ZodType {\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        const options = this._def.options;\r\n        function handleResults(results) {\r\n            // return first issue-free validation if it exists\r\n            for (const result of results) {\r\n                if (result.result.status === \"valid\") {\r\n                    return result.result;\r\n                }\r\n            }\r\n            for (const result of results) {\r\n                if (result.result.status === \"dirty\") {\r\n                    // add issues from dirty option\r\n                    ctx.common.issues.push(...result.ctx.common.issues);\r\n                    return result.result;\r\n                }\r\n            }\r\n            // return invalid\r\n            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_union,\r\n                unionErrors,\r\n            });\r\n            return INVALID;\r\n        }\r\n        if (ctx.common.async) {\r\n            return Promise.all(options.map(async (option) => {\r\n                const childCtx = {\r\n                    ...ctx,\r\n                    common: {\r\n                        ...ctx.common,\r\n                        issues: [],\r\n                    },\r\n                    parent: null,\r\n                };\r\n                return {\r\n                    result: await option._parseAsync({\r\n                        data: ctx.data,\r\n                        path: ctx.path,\r\n                        parent: childCtx,\r\n                    }),\r\n                    ctx: childCtx,\r\n                };\r\n            })).then(handleResults);\r\n        }\r\n        else {\r\n            let dirty = undefined;\r\n            const issues = [];\r\n            for (const option of options) {\r\n                const childCtx = {\r\n                    ...ctx,\r\n                    common: {\r\n                        ...ctx.common,\r\n                        issues: [],\r\n                    },\r\n                    parent: null,\r\n                };\r\n                const result = option._parseSync({\r\n                    data: ctx.data,\r\n                    path: ctx.path,\r\n                    parent: childCtx,\r\n                });\r\n                if (result.status === \"valid\") {\r\n                    return result;\r\n                }\r\n                else if (result.status === \"dirty\" && !dirty) {\r\n                    dirty = { result, ctx: childCtx };\r\n                }\r\n                if (childCtx.common.issues.length) {\r\n                    issues.push(childCtx.common.issues);\r\n                }\r\n            }\r\n            if (dirty) {\r\n                ctx.common.issues.push(...dirty.ctx.common.issues);\r\n                return dirty.result;\r\n            }\r\n            const unionErrors = issues.map((issues) => new ZodError(issues));\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_union,\r\n                unionErrors,\r\n            });\r\n            return INVALID;\r\n        }\r\n    }\r\n    get options() {\r\n        return this._def.options;\r\n    }\r\n}\r\nZodUnion.create = (types, params) => {\r\n    return new ZodUnion({\r\n        options: types,\r\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\n/////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////\r\n//////////                                 //////////\r\n//////////      ZodDiscriminatedUnion      //////////\r\n//////////                                 //////////\r\n/////////////////////////////////////////////////////\r\n/////////////////////////////////////////////////////\r\nconst getDiscriminator = (type) => {\r\n    if (type instanceof ZodLazy) {\r\n        return getDiscriminator(type.schema);\r\n    }\r\n    else if (type instanceof ZodEffects) {\r\n        return getDiscriminator(type.innerType());\r\n    }\r\n    else if (type instanceof ZodLiteral) {\r\n        return [type.value];\r\n    }\r\n    else if (type instanceof ZodEnum) {\r\n        return type.options;\r\n    }\r\n    else if (type instanceof ZodNativeEnum) {\r\n        // eslint-disable-next-line ban/ban\r\n        return Object.keys(type.enum);\r\n    }\r\n    else if (type instanceof ZodDefault) {\r\n        return getDiscriminator(type._def.innerType);\r\n    }\r\n    else if (type instanceof ZodUndefined) {\r\n        return [undefined];\r\n    }\r\n    else if (type instanceof ZodNull) {\r\n        return [null];\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n};\r\nclass ZodDiscriminatedUnion extends ZodType {\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        if (ctx.parsedType !== ZodParsedType.object) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.object,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        const discriminator = this.discriminator;\r\n        const discriminatorValue = ctx.data[discriminator];\r\n        const option = this.optionsMap.get(discriminatorValue);\r\n        if (!option) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_union_discriminator,\r\n                options: Array.from(this.optionsMap.keys()),\r\n                path: [discriminator],\r\n            });\r\n            return INVALID;\r\n        }\r\n        if (ctx.common.async) {\r\n            return option._parseAsync({\r\n                data: ctx.data,\r\n                path: ctx.path,\r\n                parent: ctx,\r\n            });\r\n        }\r\n        else {\r\n            return option._parseSync({\r\n                data: ctx.data,\r\n                path: ctx.path,\r\n                parent: ctx,\r\n            });\r\n        }\r\n    }\r\n    get discriminator() {\r\n        return this._def.discriminator;\r\n    }\r\n    get options() {\r\n        return this._def.options;\r\n    }\r\n    get optionsMap() {\r\n        return this._def.optionsMap;\r\n    }\r\n    /**\r\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\r\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\r\n     * have a different value for each object in the union.\r\n     * @param discriminator the name of the discriminator property\r\n     * @param types an array of object schemas\r\n     * @param params\r\n     */\r\n    static create(discriminator, options, params) {\r\n        // Get all the valid discriminator values\r\n        const optionsMap = new Map();\r\n        // try {\r\n        for (const type of options) {\r\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\r\n            if (!discriminatorValues) {\r\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\r\n            }\r\n            for (const value of discriminatorValues) {\r\n                if (optionsMap.has(value)) {\r\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\r\n                }\r\n                optionsMap.set(value, type);\r\n            }\r\n        }\r\n        return new ZodDiscriminatedUnion({\r\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\r\n            discriminator,\r\n            options,\r\n            optionsMap,\r\n            ...processCreateParams(params),\r\n        });\r\n    }\r\n}\r\nfunction mergeValues(a, b) {\r\n    const aType = getParsedType(a);\r\n    const bType = getParsedType(b);\r\n    if (a === b) {\r\n        return { valid: true, data: a };\r\n    }\r\n    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\r\n        const bKeys = util.objectKeys(b);\r\n        const sharedKeys = util\r\n            .objectKeys(a)\r\n            .filter((key) => bKeys.indexOf(key) !== -1);\r\n        const newObj = { ...a, ...b };\r\n        for (const key of sharedKeys) {\r\n            const sharedValue = mergeValues(a[key], b[key]);\r\n            if (!sharedValue.valid) {\r\n                return { valid: false };\r\n            }\r\n            newObj[key] = sharedValue.data;\r\n        }\r\n        return { valid: true, data: newObj };\r\n    }\r\n    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\r\n        if (a.length !== b.length) {\r\n            return { valid: false };\r\n        }\r\n        const newArray = [];\r\n        for (let index = 0; index < a.length; index++) {\r\n            const itemA = a[index];\r\n            const itemB = b[index];\r\n            const sharedValue = mergeValues(itemA, itemB);\r\n            if (!sharedValue.valid) {\r\n                return { valid: false };\r\n            }\r\n            newArray.push(sharedValue.data);\r\n        }\r\n        return { valid: true, data: newArray };\r\n    }\r\n    else if (aType === ZodParsedType.date &&\r\n        bType === ZodParsedType.date &&\r\n        +a === +b) {\r\n        return { valid: true, data: a };\r\n    }\r\n    else {\r\n        return { valid: false };\r\n    }\r\n}\r\nclass ZodIntersection extends ZodType {\r\n    _parse(input) {\r\n        const { status, ctx } = this._processInputParams(input);\r\n        const handleParsed = (parsedLeft, parsedRight) => {\r\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\r\n                return INVALID;\r\n            }\r\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\r\n            if (!merged.valid) {\r\n                addIssueToContext(ctx, {\r\n                    code: ZodIssueCode.invalid_intersection_types,\r\n                });\r\n                return INVALID;\r\n            }\r\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\r\n                status.dirty();\r\n            }\r\n            return { status: status.value, value: merged.data };\r\n        };\r\n        if (ctx.common.async) {\r\n            return Promise.all([\r\n                this._def.left._parseAsync({\r\n                    data: ctx.data,\r\n                    path: ctx.path,\r\n                    parent: ctx,\r\n                }),\r\n                this._def.right._parseAsync({\r\n                    data: ctx.data,\r\n                    path: ctx.path,\r\n                    parent: ctx,\r\n                }),\r\n            ]).then(([left, right]) => handleParsed(left, right));\r\n        }\r\n        else {\r\n            return handleParsed(this._def.left._parseSync({\r\n                data: ctx.data,\r\n                path: ctx.path,\r\n                parent: ctx,\r\n            }), this._def.right._parseSync({\r\n                data: ctx.data,\r\n                path: ctx.path,\r\n                parent: ctx,\r\n            }));\r\n        }\r\n    }\r\n}\r\nZodIntersection.create = (left, right, params) => {\r\n    return new ZodIntersection({\r\n        left: left,\r\n        right: right,\r\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodTuple extends ZodType {\r\n    _parse(input) {\r\n        const { status, ctx } = this._processInputParams(input);\r\n        if (ctx.parsedType !== ZodParsedType.array) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.array,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        if (ctx.data.length < this._def.items.length) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.too_small,\r\n                minimum: this._def.items.length,\r\n                inclusive: true,\r\n                exact: false,\r\n                type: \"array\",\r\n            });\r\n            return INVALID;\r\n        }\r\n        const rest = this._def.rest;\r\n        if (!rest && ctx.data.length > this._def.items.length) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.too_big,\r\n                maximum: this._def.items.length,\r\n                inclusive: true,\r\n                exact: false,\r\n                type: \"array\",\r\n            });\r\n            status.dirty();\r\n        }\r\n        const items = [...ctx.data]\r\n            .map((item, itemIndex) => {\r\n            const schema = this._def.items[itemIndex] || this._def.rest;\r\n            if (!schema)\r\n                return null;\r\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\r\n        })\r\n            .filter((x) => !!x); // filter nulls\r\n        if (ctx.common.async) {\r\n            return Promise.all(items).then((results) => {\r\n                return ParseStatus.mergeArray(status, results);\r\n            });\r\n        }\r\n        else {\r\n            return ParseStatus.mergeArray(status, items);\r\n        }\r\n    }\r\n    get items() {\r\n        return this._def.items;\r\n    }\r\n    rest(rest) {\r\n        return new ZodTuple({\r\n            ...this._def,\r\n            rest,\r\n        });\r\n    }\r\n}\r\nZodTuple.create = (schemas, params) => {\r\n    if (!Array.isArray(schemas)) {\r\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\r\n    }\r\n    return new ZodTuple({\r\n        items: schemas,\r\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\r\n        rest: null,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodRecord extends ZodType {\r\n    get keySchema() {\r\n        return this._def.keyType;\r\n    }\r\n    get valueSchema() {\r\n        return this._def.valueType;\r\n    }\r\n    _parse(input) {\r\n        const { status, ctx } = this._processInputParams(input);\r\n        if (ctx.parsedType !== ZodParsedType.object) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.object,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        const pairs = [];\r\n        const keyType = this._def.keyType;\r\n        const valueType = this._def.valueType;\r\n        for (const key in ctx.data) {\r\n            pairs.push({\r\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\r\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\r\n            });\r\n        }\r\n        if (ctx.common.async) {\r\n            return ParseStatus.mergeObjectAsync(status, pairs);\r\n        }\r\n        else {\r\n            return ParseStatus.mergeObjectSync(status, pairs);\r\n        }\r\n    }\r\n    get element() {\r\n        return this._def.valueType;\r\n    }\r\n    static create(first, second, third) {\r\n        if (second instanceof ZodType) {\r\n            return new ZodRecord({\r\n                keyType: first,\r\n                valueType: second,\r\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\r\n                ...processCreateParams(third),\r\n            });\r\n        }\r\n        return new ZodRecord({\r\n            keyType: ZodString.create(),\r\n            valueType: first,\r\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\r\n            ...processCreateParams(second),\r\n        });\r\n    }\r\n}\r\nclass ZodMap extends ZodType {\r\n    get keySchema() {\r\n        return this._def.keyType;\r\n    }\r\n    get valueSchema() {\r\n        return this._def.valueType;\r\n    }\r\n    _parse(input) {\r\n        const { status, ctx } = this._processInputParams(input);\r\n        if (ctx.parsedType !== ZodParsedType.map) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.map,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        const keyType = this._def.keyType;\r\n        const valueType = this._def.valueType;\r\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\r\n            return {\r\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\r\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\r\n            };\r\n        });\r\n        if (ctx.common.async) {\r\n            const finalMap = new Map();\r\n            return Promise.resolve().then(async () => {\r\n                for (const pair of pairs) {\r\n                    const key = await pair.key;\r\n                    const value = await pair.value;\r\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\r\n                        return INVALID;\r\n                    }\r\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\r\n                        status.dirty();\r\n                    }\r\n                    finalMap.set(key.value, value.value);\r\n                }\r\n                return { status: status.value, value: finalMap };\r\n            });\r\n        }\r\n        else {\r\n            const finalMap = new Map();\r\n            for (const pair of pairs) {\r\n                const key = pair.key;\r\n                const value = pair.value;\r\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\r\n                    return INVALID;\r\n                }\r\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\r\n                    status.dirty();\r\n                }\r\n                finalMap.set(key.value, value.value);\r\n            }\r\n            return { status: status.value, value: finalMap };\r\n        }\r\n    }\r\n}\r\nZodMap.create = (keyType, valueType, params) => {\r\n    return new ZodMap({\r\n        valueType,\r\n        keyType,\r\n        typeName: ZodFirstPartyTypeKind.ZodMap,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodSet extends ZodType {\r\n    _parse(input) {\r\n        const { status, ctx } = this._processInputParams(input);\r\n        if (ctx.parsedType !== ZodParsedType.set) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.set,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        const def = this._def;\r\n        if (def.minSize !== null) {\r\n            if (ctx.data.size < def.minSize.value) {\r\n                addIssueToContext(ctx, {\r\n                    code: ZodIssueCode.too_small,\r\n                    minimum: def.minSize.value,\r\n                    type: \"set\",\r\n                    inclusive: true,\r\n                    exact: false,\r\n                    message: def.minSize.message,\r\n                });\r\n                status.dirty();\r\n            }\r\n        }\r\n        if (def.maxSize !== null) {\r\n            if (ctx.data.size > def.maxSize.value) {\r\n                addIssueToContext(ctx, {\r\n                    code: ZodIssueCode.too_big,\r\n                    maximum: def.maxSize.value,\r\n                    type: \"set\",\r\n                    inclusive: true,\r\n                    exact: false,\r\n                    message: def.maxSize.message,\r\n                });\r\n                status.dirty();\r\n            }\r\n        }\r\n        const valueType = this._def.valueType;\r\n        function finalizeSet(elements) {\r\n            const parsedSet = new Set();\r\n            for (const element of elements) {\r\n                if (element.status === \"aborted\")\r\n                    return INVALID;\r\n                if (element.status === \"dirty\")\r\n                    status.dirty();\r\n                parsedSet.add(element.value);\r\n            }\r\n            return { status: status.value, value: parsedSet };\r\n        }\r\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\r\n        if (ctx.common.async) {\r\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\r\n        }\r\n        else {\r\n            return finalizeSet(elements);\r\n        }\r\n    }\r\n    min(minSize, message) {\r\n        return new ZodSet({\r\n            ...this._def,\r\n            minSize: { value: minSize, message: errorUtil.toString(message) },\r\n        });\r\n    }\r\n    max(maxSize, message) {\r\n        return new ZodSet({\r\n            ...this._def,\r\n            maxSize: { value: maxSize, message: errorUtil.toString(message) },\r\n        });\r\n    }\r\n    size(size, message) {\r\n        return this.min(size, message).max(size, message);\r\n    }\r\n    nonempty(message) {\r\n        return this.min(1, message);\r\n    }\r\n}\r\nZodSet.create = (valueType, params) => {\r\n    return new ZodSet({\r\n        valueType,\r\n        minSize: null,\r\n        maxSize: null,\r\n        typeName: ZodFirstPartyTypeKind.ZodSet,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodFunction extends ZodType {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.validate = this.implement;\r\n    }\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        if (ctx.parsedType !== ZodParsedType.function) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.function,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        function makeArgsIssue(args, error) {\r\n            return makeIssue({\r\n                data: args,\r\n                path: ctx.path,\r\n                errorMaps: [\r\n                    ctx.common.contextualErrorMap,\r\n                    ctx.schemaErrorMap,\r\n                    getErrorMap(),\r\n                    errorMap,\r\n                ].filter((x) => !!x),\r\n                issueData: {\r\n                    code: ZodIssueCode.invalid_arguments,\r\n                    argumentsError: error,\r\n                },\r\n            });\r\n        }\r\n        function makeReturnsIssue(returns, error) {\r\n            return makeIssue({\r\n                data: returns,\r\n                path: ctx.path,\r\n                errorMaps: [\r\n                    ctx.common.contextualErrorMap,\r\n                    ctx.schemaErrorMap,\r\n                    getErrorMap(),\r\n                    errorMap,\r\n                ].filter((x) => !!x),\r\n                issueData: {\r\n                    code: ZodIssueCode.invalid_return_type,\r\n                    returnTypeError: error,\r\n                },\r\n            });\r\n        }\r\n        const params = { errorMap: ctx.common.contextualErrorMap };\r\n        const fn = ctx.data;\r\n        if (this._def.returns instanceof ZodPromise) {\r\n            // Would love a way to avoid disabling this rule, but we need\r\n            // an alias (using an arrow function was what caused 2651).\r\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n            const me = this;\r\n            return OK(async function (...args) {\r\n                const error = new ZodError([]);\r\n                const parsedArgs = await me._def.args\r\n                    .parseAsync(args, params)\r\n                    .catch((e) => {\r\n                    error.addIssue(makeArgsIssue(args, e));\r\n                    throw error;\r\n                });\r\n                const result = await Reflect.apply(fn, this, parsedArgs);\r\n                const parsedReturns = await me._def.returns._def.type\r\n                    .parseAsync(result, params)\r\n                    .catch((e) => {\r\n                    error.addIssue(makeReturnsIssue(result, e));\r\n                    throw error;\r\n                });\r\n                return parsedReturns;\r\n            });\r\n        }\r\n        else {\r\n            // Would love a way to avoid disabling this rule, but we need\r\n            // an alias (using an arrow function was what caused 2651).\r\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n            const me = this;\r\n            return OK(function (...args) {\r\n                const parsedArgs = me._def.args.safeParse(args, params);\r\n                if (!parsedArgs.success) {\r\n                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\r\n                }\r\n                const result = Reflect.apply(fn, this, parsedArgs.data);\r\n                const parsedReturns = me._def.returns.safeParse(result, params);\r\n                if (!parsedReturns.success) {\r\n                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\r\n                }\r\n                return parsedReturns.data;\r\n            });\r\n        }\r\n    }\r\n    parameters() {\r\n        return this._def.args;\r\n    }\r\n    returnType() {\r\n        return this._def.returns;\r\n    }\r\n    args(...items) {\r\n        return new ZodFunction({\r\n            ...this._def,\r\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\r\n        });\r\n    }\r\n    returns(returnType) {\r\n        return new ZodFunction({\r\n            ...this._def,\r\n            returns: returnType,\r\n        });\r\n    }\r\n    implement(func) {\r\n        const validatedFunc = this.parse(func);\r\n        return validatedFunc;\r\n    }\r\n    strictImplement(func) {\r\n        const validatedFunc = this.parse(func);\r\n        return validatedFunc;\r\n    }\r\n    static create(args, returns, params) {\r\n        return new ZodFunction({\r\n            args: (args\r\n                ? args\r\n                : ZodTuple.create([]).rest(ZodUnknown.create())),\r\n            returns: returns || ZodUnknown.create(),\r\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\r\n            ...processCreateParams(params),\r\n        });\r\n    }\r\n}\r\nclass ZodLazy extends ZodType {\r\n    get schema() {\r\n        return this._def.getter();\r\n    }\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        const lazySchema = this._def.getter();\r\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\r\n    }\r\n}\r\nZodLazy.create = (getter, params) => {\r\n    return new ZodLazy({\r\n        getter: getter,\r\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodLiteral extends ZodType {\r\n    _parse(input) {\r\n        if (input.data !== this._def.value) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                received: ctx.data,\r\n                code: ZodIssueCode.invalid_literal,\r\n                expected: this._def.value,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return { status: \"valid\", value: input.data };\r\n    }\r\n    get value() {\r\n        return this._def.value;\r\n    }\r\n}\r\nZodLiteral.create = (value, params) => {\r\n    return new ZodLiteral({\r\n        value: value,\r\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nfunction createZodEnum(values, params) {\r\n    return new ZodEnum({\r\n        values,\r\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\r\n        ...processCreateParams(params),\r\n    });\r\n}\r\nclass ZodEnum extends ZodType {\r\n    _parse(input) {\r\n        if (typeof input.data !== \"string\") {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            const expectedValues = this._def.values;\r\n            addIssueToContext(ctx, {\r\n                expected: util.joinValues(expectedValues),\r\n                received: ctx.parsedType,\r\n                code: ZodIssueCode.invalid_type,\r\n            });\r\n            return INVALID;\r\n        }\r\n        if (this._def.values.indexOf(input.data) === -1) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            const expectedValues = this._def.values;\r\n            addIssueToContext(ctx, {\r\n                received: ctx.data,\r\n                code: ZodIssueCode.invalid_enum_value,\r\n                options: expectedValues,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return OK(input.data);\r\n    }\r\n    get options() {\r\n        return this._def.values;\r\n    }\r\n    get enum() {\r\n        const enumValues = {};\r\n        for (const val of this._def.values) {\r\n            enumValues[val] = val;\r\n        }\r\n        return enumValues;\r\n    }\r\n    get Values() {\r\n        const enumValues = {};\r\n        for (const val of this._def.values) {\r\n            enumValues[val] = val;\r\n        }\r\n        return enumValues;\r\n    }\r\n    get Enum() {\r\n        const enumValues = {};\r\n        for (const val of this._def.values) {\r\n            enumValues[val] = val;\r\n        }\r\n        return enumValues;\r\n    }\r\n    extract(values) {\r\n        return ZodEnum.create(values);\r\n    }\r\n    exclude(values) {\r\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));\r\n    }\r\n}\r\nZodEnum.create = createZodEnum;\r\nclass ZodNativeEnum extends ZodType {\r\n    _parse(input) {\r\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\r\n        const ctx = this._getOrReturnCtx(input);\r\n        if (ctx.parsedType !== ZodParsedType.string &&\r\n            ctx.parsedType !== ZodParsedType.number) {\r\n            const expectedValues = util.objectValues(nativeEnumValues);\r\n            addIssueToContext(ctx, {\r\n                expected: util.joinValues(expectedValues),\r\n                received: ctx.parsedType,\r\n                code: ZodIssueCode.invalid_type,\r\n            });\r\n            return INVALID;\r\n        }\r\n        if (nativeEnumValues.indexOf(input.data) === -1) {\r\n            const expectedValues = util.objectValues(nativeEnumValues);\r\n            addIssueToContext(ctx, {\r\n                received: ctx.data,\r\n                code: ZodIssueCode.invalid_enum_value,\r\n                options: expectedValues,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return OK(input.data);\r\n    }\r\n    get enum() {\r\n        return this._def.values;\r\n    }\r\n}\r\nZodNativeEnum.create = (values, params) => {\r\n    return new ZodNativeEnum({\r\n        values: values,\r\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodPromise extends ZodType {\r\n    unwrap() {\r\n        return this._def.type;\r\n    }\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        if (ctx.parsedType !== ZodParsedType.promise &&\r\n            ctx.common.async === false) {\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.promise,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        const promisified = ctx.parsedType === ZodParsedType.promise\r\n            ? ctx.data\r\n            : Promise.resolve(ctx.data);\r\n        return OK(promisified.then((data) => {\r\n            return this._def.type.parseAsync(data, {\r\n                path: ctx.path,\r\n                errorMap: ctx.common.contextualErrorMap,\r\n            });\r\n        }));\r\n    }\r\n}\r\nZodPromise.create = (schema, params) => {\r\n    return new ZodPromise({\r\n        type: schema,\r\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodEffects extends ZodType {\r\n    innerType() {\r\n        return this._def.schema;\r\n    }\r\n    sourceType() {\r\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\r\n            ? this._def.schema.sourceType()\r\n            : this._def.schema;\r\n    }\r\n    _parse(input) {\r\n        const { status, ctx } = this._processInputParams(input);\r\n        const effect = this._def.effect || null;\r\n        const checkCtx = {\r\n            addIssue: (arg) => {\r\n                addIssueToContext(ctx, arg);\r\n                if (arg.fatal) {\r\n                    status.abort();\r\n                }\r\n                else {\r\n                    status.dirty();\r\n                }\r\n            },\r\n            get path() {\r\n                return ctx.path;\r\n            },\r\n        };\r\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\r\n        if (effect.type === \"preprocess\") {\r\n            const processed = effect.transform(ctx.data, checkCtx);\r\n            if (ctx.common.issues.length) {\r\n                return {\r\n                    status: \"dirty\",\r\n                    value: ctx.data,\r\n                };\r\n            }\r\n            if (ctx.common.async) {\r\n                return Promise.resolve(processed).then((processed) => {\r\n                    return this._def.schema._parseAsync({\r\n                        data: processed,\r\n                        path: ctx.path,\r\n                        parent: ctx,\r\n                    });\r\n                });\r\n            }\r\n            else {\r\n                return this._def.schema._parseSync({\r\n                    data: processed,\r\n                    path: ctx.path,\r\n                    parent: ctx,\r\n                });\r\n            }\r\n        }\r\n        if (effect.type === \"refinement\") {\r\n            const executeRefinement = (acc\r\n            // effect: RefinementEffect<any>\r\n            ) => {\r\n                const result = effect.refinement(acc, checkCtx);\r\n                if (ctx.common.async) {\r\n                    return Promise.resolve(result);\r\n                }\r\n                if (result instanceof Promise) {\r\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\r\n                }\r\n                return acc;\r\n            };\r\n            if (ctx.common.async === false) {\r\n                const inner = this._def.schema._parseSync({\r\n                    data: ctx.data,\r\n                    path: ctx.path,\r\n                    parent: ctx,\r\n                });\r\n                if (inner.status === \"aborted\")\r\n                    return INVALID;\r\n                if (inner.status === \"dirty\")\r\n                    status.dirty();\r\n                // return value is ignored\r\n                executeRefinement(inner.value);\r\n                return { status: status.value, value: inner.value };\r\n            }\r\n            else {\r\n                return this._def.schema\r\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\r\n                    .then((inner) => {\r\n                    if (inner.status === \"aborted\")\r\n                        return INVALID;\r\n                    if (inner.status === \"dirty\")\r\n                        status.dirty();\r\n                    return executeRefinement(inner.value).then(() => {\r\n                        return { status: status.value, value: inner.value };\r\n                    });\r\n                });\r\n            }\r\n        }\r\n        if (effect.type === \"transform\") {\r\n            if (ctx.common.async === false) {\r\n                const base = this._def.schema._parseSync({\r\n                    data: ctx.data,\r\n                    path: ctx.path,\r\n                    parent: ctx,\r\n                });\r\n                if (!isValid(base))\r\n                    return base;\r\n                const result = effect.transform(base.value, checkCtx);\r\n                if (result instanceof Promise) {\r\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\r\n                }\r\n                return { status: status.value, value: result };\r\n            }\r\n            else {\r\n                return this._def.schema\r\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\r\n                    .then((base) => {\r\n                    if (!isValid(base))\r\n                        return base;\r\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));\r\n                });\r\n            }\r\n        }\r\n        util.assertNever(effect);\r\n    }\r\n}\r\nZodEffects.create = (schema, effect, params) => {\r\n    return new ZodEffects({\r\n        schema,\r\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\r\n        effect,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\r\n    return new ZodEffects({\r\n        schema,\r\n        effect: { type: \"preprocess\", transform: preprocess },\r\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodOptional extends ZodType {\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType === ZodParsedType.undefined) {\r\n            return OK(undefined);\r\n        }\r\n        return this._def.innerType._parse(input);\r\n    }\r\n    unwrap() {\r\n        return this._def.innerType;\r\n    }\r\n}\r\nZodOptional.create = (type, params) => {\r\n    return new ZodOptional({\r\n        innerType: type,\r\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodNullable extends ZodType {\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType === ZodParsedType.null) {\r\n            return OK(null);\r\n        }\r\n        return this._def.innerType._parse(input);\r\n    }\r\n    unwrap() {\r\n        return this._def.innerType;\r\n    }\r\n}\r\nZodNullable.create = (type, params) => {\r\n    return new ZodNullable({\r\n        innerType: type,\r\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodDefault extends ZodType {\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        let data = ctx.data;\r\n        if (ctx.parsedType === ZodParsedType.undefined) {\r\n            data = this._def.defaultValue();\r\n        }\r\n        return this._def.innerType._parse({\r\n            data,\r\n            path: ctx.path,\r\n            parent: ctx,\r\n        });\r\n    }\r\n    removeDefault() {\r\n        return this._def.innerType;\r\n    }\r\n}\r\nZodDefault.create = (type, params) => {\r\n    return new ZodDefault({\r\n        innerType: type,\r\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\r\n        defaultValue: typeof params.default === \"function\"\r\n            ? params.default\r\n            : () => params.default,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodCatch extends ZodType {\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        // newCtx is used to not collect issues from inner types in ctx\r\n        const newCtx = {\r\n            ...ctx,\r\n            common: {\r\n                ...ctx.common,\r\n                issues: [],\r\n            },\r\n        };\r\n        const result = this._def.innerType._parse({\r\n            data: newCtx.data,\r\n            path: newCtx.path,\r\n            parent: {\r\n                ...newCtx,\r\n            },\r\n        });\r\n        if (isAsync(result)) {\r\n            return result.then((result) => {\r\n                return {\r\n                    status: \"valid\",\r\n                    value: result.status === \"valid\"\r\n                        ? result.value\r\n                        : this._def.catchValue({\r\n                            get error() {\r\n                                return new ZodError(newCtx.common.issues);\r\n                            },\r\n                            input: newCtx.data,\r\n                        }),\r\n                };\r\n            });\r\n        }\r\n        else {\r\n            return {\r\n                status: \"valid\",\r\n                value: result.status === \"valid\"\r\n                    ? result.value\r\n                    : this._def.catchValue({\r\n                        get error() {\r\n                            return new ZodError(newCtx.common.issues);\r\n                        },\r\n                        input: newCtx.data,\r\n                    }),\r\n            };\r\n        }\r\n    }\r\n    removeCatch() {\r\n        return this._def.innerType;\r\n    }\r\n}\r\nZodCatch.create = (type, params) => {\r\n    return new ZodCatch({\r\n        innerType: type,\r\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\r\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nclass ZodNaN extends ZodType {\r\n    _parse(input) {\r\n        const parsedType = this._getType(input);\r\n        if (parsedType !== ZodParsedType.nan) {\r\n            const ctx = this._getOrReturnCtx(input);\r\n            addIssueToContext(ctx, {\r\n                code: ZodIssueCode.invalid_type,\r\n                expected: ZodParsedType.nan,\r\n                received: ctx.parsedType,\r\n            });\r\n            return INVALID;\r\n        }\r\n        return { status: \"valid\", value: input.data };\r\n    }\r\n}\r\nZodNaN.create = (params) => {\r\n    return new ZodNaN({\r\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nconst BRAND = Symbol(\"zod_brand\");\r\nclass ZodBranded extends ZodType {\r\n    _parse(input) {\r\n        const { ctx } = this._processInputParams(input);\r\n        const data = ctx.data;\r\n        return this._def.type._parse({\r\n            data,\r\n            path: ctx.path,\r\n            parent: ctx,\r\n        });\r\n    }\r\n    unwrap() {\r\n        return this._def.type;\r\n    }\r\n}\r\nclass ZodPipeline extends ZodType {\r\n    _parse(input) {\r\n        const { status, ctx } = this._processInputParams(input);\r\n        if (ctx.common.async) {\r\n            const handleAsync = async () => {\r\n                const inResult = await this._def.in._parseAsync({\r\n                    data: ctx.data,\r\n                    path: ctx.path,\r\n                    parent: ctx,\r\n                });\r\n                if (inResult.status === \"aborted\")\r\n                    return INVALID;\r\n                if (inResult.status === \"dirty\") {\r\n                    status.dirty();\r\n                    return DIRTY(inResult.value);\r\n                }\r\n                else {\r\n                    return this._def.out._parseAsync({\r\n                        data: inResult.value,\r\n                        path: ctx.path,\r\n                        parent: ctx,\r\n                    });\r\n                }\r\n            };\r\n            return handleAsync();\r\n        }\r\n        else {\r\n            const inResult = this._def.in._parseSync({\r\n                data: ctx.data,\r\n                path: ctx.path,\r\n                parent: ctx,\r\n            });\r\n            if (inResult.status === \"aborted\")\r\n                return INVALID;\r\n            if (inResult.status === \"dirty\") {\r\n                status.dirty();\r\n                return {\r\n                    status: \"dirty\",\r\n                    value: inResult.value,\r\n                };\r\n            }\r\n            else {\r\n                return this._def.out._parseSync({\r\n                    data: inResult.value,\r\n                    path: ctx.path,\r\n                    parent: ctx,\r\n                });\r\n            }\r\n        }\r\n    }\r\n    static create(a, b) {\r\n        return new ZodPipeline({\r\n            in: a,\r\n            out: b,\r\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\r\n        });\r\n    }\r\n}\r\nclass ZodReadonly extends ZodType {\r\n    _parse(input) {\r\n        const result = this._def.innerType._parse(input);\r\n        if (isValid(result)) {\r\n            result.value = Object.freeze(result.value);\r\n        }\r\n        return result;\r\n    }\r\n}\r\nZodReadonly.create = (type, params) => {\r\n    return new ZodReadonly({\r\n        innerType: type,\r\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\r\n        ...processCreateParams(params),\r\n    });\r\n};\r\nconst custom = (check, params = {}, \r\n/**\r\n * @deprecated\r\n *\r\n * Pass `fatal` into the params object instead:\r\n *\r\n * ```ts\r\n * z.string().custom((val) => val.length > 5, { fatal: false })\r\n * ```\r\n *\r\n */\r\nfatal) => {\r\n    if (check)\r\n        return ZodAny.create().superRefine((data, ctx) => {\r\n            var _a, _b;\r\n            if (!check(data)) {\r\n                const p = typeof params === \"function\"\r\n                    ? params(data)\r\n                    : typeof params === \"string\"\r\n                        ? { message: params }\r\n                        : params;\r\n                const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\r\n                const p2 = typeof p === \"string\" ? { message: p } : p;\r\n                ctx.addIssue({ code: \"custom\", ...p2, fatal: _fatal });\r\n            }\r\n        });\r\n    return ZodAny.create();\r\n};\r\nconst late = {\r\n    object: ZodObject.lazycreate,\r\n};\r\nvar ZodFirstPartyTypeKind;\r\n(function (ZodFirstPartyTypeKind) {\r\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\r\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\r\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\r\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\r\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\r\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\r\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\r\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\r\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\r\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\r\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\r\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\r\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\r\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\r\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\r\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\r\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\r\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\r\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\r\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\r\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\r\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\r\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\r\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\r\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\r\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\r\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\r\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\r\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\r\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\r\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\r\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\r\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\r\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\r\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\r\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\r\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\r\nconst instanceOfType = (\r\n// const instanceOfType = <T extends new (...args: any[]) => any>(\r\ncls, params = {\r\n    message: `Input not instance of ${cls.name}`,\r\n}) => custom((data) => data instanceof cls, params);\r\nconst stringType = ZodString.create;\r\nconst numberType = ZodNumber.create;\r\nconst nanType = ZodNaN.create;\r\nconst bigIntType = ZodBigInt.create;\r\nconst booleanType = ZodBoolean.create;\r\nconst dateType = ZodDate.create;\r\nconst symbolType = ZodSymbol.create;\r\nconst undefinedType = ZodUndefined.create;\r\nconst nullType = ZodNull.create;\r\nconst anyType = ZodAny.create;\r\nconst unknownType = ZodUnknown.create;\r\nconst neverType = ZodNever.create;\r\nconst voidType = ZodVoid.create;\r\nconst arrayType = ZodArray.create;\r\nconst objectType = ZodObject.create;\r\nconst strictObjectType = ZodObject.strictCreate;\r\nconst unionType = ZodUnion.create;\r\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\r\nconst intersectionType = ZodIntersection.create;\r\nconst tupleType = ZodTuple.create;\r\nconst recordType = ZodRecord.create;\r\nconst mapType = ZodMap.create;\r\nconst setType = ZodSet.create;\r\nconst functionType = ZodFunction.create;\r\nconst lazyType = ZodLazy.create;\r\nconst literalType = ZodLiteral.create;\r\nconst enumType = ZodEnum.create;\r\nconst nativeEnumType = ZodNativeEnum.create;\r\nconst promiseType = ZodPromise.create;\r\nconst effectsType = ZodEffects.create;\r\nconst optionalType = ZodOptional.create;\r\nconst nullableType = ZodNullable.create;\r\nconst preprocessType = ZodEffects.createWithPreprocess;\r\nconst pipelineType = ZodPipeline.create;\r\nconst ostring = () => stringType().optional();\r\nconst onumber = () => numberType().optional();\r\nconst oboolean = () => booleanType().optional();\r\nconst coerce = {\r\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\r\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\r\n    boolean: ((arg) => ZodBoolean.create({\r\n        ...arg,\r\n        coerce: true,\r\n    })),\r\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\r\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\r\n};\r\nconst NEVER = INVALID;\r\n\r\nvar z = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    defaultErrorMap: errorMap,\r\n    setErrorMap: setErrorMap,\r\n    getErrorMap: getErrorMap,\r\n    makeIssue: makeIssue,\r\n    EMPTY_PATH: EMPTY_PATH,\r\n    addIssueToContext: addIssueToContext,\r\n    ParseStatus: ParseStatus,\r\n    INVALID: INVALID,\r\n    DIRTY: DIRTY,\r\n    OK: OK,\r\n    isAborted: isAborted,\r\n    isDirty: isDirty,\r\n    isValid: isValid,\r\n    isAsync: isAsync,\r\n    get util () { return util; },\r\n    get objectUtil () { return objectUtil; },\r\n    ZodParsedType: ZodParsedType,\r\n    getParsedType: getParsedType,\r\n    ZodType: ZodType,\r\n    ZodString: ZodString,\r\n    ZodNumber: ZodNumber,\r\n    ZodBigInt: ZodBigInt,\r\n    ZodBoolean: ZodBoolean,\r\n    ZodDate: ZodDate,\r\n    ZodSymbol: ZodSymbol,\r\n    ZodUndefined: ZodUndefined,\r\n    ZodNull: ZodNull,\r\n    ZodAny: ZodAny,\r\n    ZodUnknown: ZodUnknown,\r\n    ZodNever: ZodNever,\r\n    ZodVoid: ZodVoid,\r\n    ZodArray: ZodArray,\r\n    ZodObject: ZodObject,\r\n    ZodUnion: ZodUnion,\r\n    ZodDiscriminatedUnion: ZodDiscriminatedUnion,\r\n    ZodIntersection: ZodIntersection,\r\n    ZodTuple: ZodTuple,\r\n    ZodRecord: ZodRecord,\r\n    ZodMap: ZodMap,\r\n    ZodSet: ZodSet,\r\n    ZodFunction: ZodFunction,\r\n    ZodLazy: ZodLazy,\r\n    ZodLiteral: ZodLiteral,\r\n    ZodEnum: ZodEnum,\r\n    ZodNativeEnum: ZodNativeEnum,\r\n    ZodPromise: ZodPromise,\r\n    ZodEffects: ZodEffects,\r\n    ZodTransformer: ZodEffects,\r\n    ZodOptional: ZodOptional,\r\n    ZodNullable: ZodNullable,\r\n    ZodDefault: ZodDefault,\r\n    ZodCatch: ZodCatch,\r\n    ZodNaN: ZodNaN,\r\n    BRAND: BRAND,\r\n    ZodBranded: ZodBranded,\r\n    ZodPipeline: ZodPipeline,\r\n    ZodReadonly: ZodReadonly,\r\n    custom: custom,\r\n    Schema: ZodType,\r\n    ZodSchema: ZodType,\r\n    late: late,\r\n    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },\r\n    coerce: coerce,\r\n    any: anyType,\r\n    array: arrayType,\r\n    bigint: bigIntType,\r\n    boolean: booleanType,\r\n    date: dateType,\r\n    discriminatedUnion: discriminatedUnionType,\r\n    effect: effectsType,\r\n    'enum': enumType,\r\n    'function': functionType,\r\n    'instanceof': instanceOfType,\r\n    intersection: intersectionType,\r\n    lazy: lazyType,\r\n    literal: literalType,\r\n    map: mapType,\r\n    nan: nanType,\r\n    nativeEnum: nativeEnumType,\r\n    never: neverType,\r\n    'null': nullType,\r\n    nullable: nullableType,\r\n    number: numberType,\r\n    object: objectType,\r\n    oboolean: oboolean,\r\n    onumber: onumber,\r\n    optional: optionalType,\r\n    ostring: ostring,\r\n    pipeline: pipelineType,\r\n    preprocess: preprocessType,\r\n    promise: promiseType,\r\n    record: recordType,\r\n    set: setType,\r\n    strictObject: strictObjectType,\r\n    string: stringType,\r\n    symbol: symbolType,\r\n    transformer: effectsType,\r\n    tuple: tupleType,\r\n    'undefined': undefinedType,\r\n    union: unionType,\r\n    unknown: unknownType,\r\n    'void': voidType,\r\n    NEVER: NEVER,\r\n    ZodIssueCode: ZodIssueCode,\r\n    quotelessJson: quotelessJson,\r\n    ZodError: ZodError\r\n});\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvem9kL2xpYi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxJQUFJO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaURBQWlEO0FBQ3ZGO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MseUJBQXlCO0FBQy9EO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsdUJBQXVCO0FBQzdEO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdDQUFnQywrQ0FBK0M7QUFDL0U7QUFDQTtBQUNBLGdDQUFnQyw2Q0FBNkM7QUFDN0U7QUFDQTtBQUNBLGdDQUFnQywrQ0FBK0M7QUFDL0U7QUFDQTtBQUNBLGdDQUFnQyw4Q0FBOEM7QUFDOUU7QUFDQTtBQUNBLGdDQUFnQyw4Q0FBOEM7QUFDOUU7QUFDQTtBQUNBLGdDQUFnQywrQ0FBK0M7QUFDL0U7QUFDQTtBQUNBLGdDQUFnQyw4Q0FBOEM7QUFDOUU7QUFDQTtBQUNBLGdDQUFnQyw0Q0FBNEM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsY0FBYztBQUMxRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMscUJBQXFCO0FBQ2pFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxxQkFBcUI7QUFDakUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7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LCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXN0X2NvdXJzZS8uL25vZGVfbW9kdWxlcy96b2QvbGliL2luZGV4Lm1qcz8xYmI2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB1dGlsO1xyXG4oZnVuY3Rpb24gKHV0aWwpIHtcclxuICAgIHV0aWwuYXNzZXJ0RXF1YWwgPSAodmFsKSA9PiB2YWw7XHJcbiAgICBmdW5jdGlvbiBhc3NlcnRJcyhfYXJnKSB7IH1cclxuICAgIHV0aWwuYXNzZXJ0SXMgPSBhc3NlcnRJcztcclxuICAgIGZ1bmN0aW9uIGFzc2VydE5ldmVyKF94KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XHJcbiAgICB9XHJcbiAgICB1dGlsLmFzc2VydE5ldmVyID0gYXNzZXJ0TmV2ZXI7XHJcbiAgICB1dGlsLmFycmF5VG9FbnVtID0gKGl0ZW1zKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgb2JqID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XHJcbiAgICAgICAgICAgIG9ialtpdGVtXSA9IGl0ZW07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9O1xyXG4gICAgdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXMgPSAob2JqKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdmFsaWRLZXlzID0gdXRpbC5vYmplY3RLZXlzKG9iaikuZmlsdGVyKChrKSA9PiB0eXBlb2Ygb2JqW29ialtrXV0gIT09IFwibnVtYmVyXCIpO1xyXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBrIG9mIHZhbGlkS2V5cykge1xyXG4gICAgICAgICAgICBmaWx0ZXJlZFtrXSA9IG9ialtrXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0VmFsdWVzKGZpbHRlcmVkKTtcclxuICAgIH07XHJcbiAgICB1dGlsLm9iamVjdFZhbHVlcyA9IChvYmopID0+IHtcclxuICAgICAgICByZXR1cm4gdXRpbC5vYmplY3RLZXlzKG9iaikubWFwKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmpbZV07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgdXRpbC5vYmplY3RLZXlzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSBcImZ1bmN0aW9uXCIgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXHJcbiAgICAgICAgPyAob2JqKSA9PiBPYmplY3Qua2V5cyhvYmopIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxyXG4gICAgICAgIDogKG9iamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBrZXlzID0gW107XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ga2V5cztcclxuICAgICAgICB9O1xyXG4gICAgdXRpbC5maW5kID0gKGFyciwgY2hlY2tlcikgPT4ge1xyXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcclxuICAgICAgICAgICAgaWYgKGNoZWNrZXIoaXRlbSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICB1dGlsLmlzSW50ZWdlciA9IHR5cGVvZiBOdW1iZXIuaXNJbnRlZ2VyID09PSBcImZ1bmN0aW9uXCJcclxuICAgICAgICA/ICh2YWwpID0+IE51bWJlci5pc0ludGVnZXIodmFsKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cclxuICAgICAgICA6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsKSAmJiBNYXRoLmZsb29yKHZhbCkgPT09IHZhbDtcclxuICAgIGZ1bmN0aW9uIGpvaW5WYWx1ZXMoYXJyYXksIHNlcGFyYXRvciA9IFwiIHwgXCIpIHtcclxuICAgICAgICByZXR1cm4gYXJyYXlcclxuICAgICAgICAgICAgLm1hcCgodmFsKSA9PiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiA/IGAnJHt2YWx9J2AgOiB2YWwpKVxyXG4gICAgICAgICAgICAuam9pbihzZXBhcmF0b3IpO1xyXG4gICAgfVxyXG4gICAgdXRpbC5qb2luVmFsdWVzID0gam9pblZhbHVlcztcclxuICAgIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyID0gKF8sIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxufSkodXRpbCB8fCAodXRpbCA9IHt9KSk7XHJcbnZhciBvYmplY3RVdGlsO1xyXG4oZnVuY3Rpb24gKG9iamVjdFV0aWwpIHtcclxuICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXMgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC4uLmZpcnN0LFxyXG4gICAgICAgICAgICAuLi5zZWNvbmQsIC8vIHNlY29uZCBvdmVyd3JpdGVzIGZpcnN0XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbn0pKG9iamVjdFV0aWwgfHwgKG9iamVjdFV0aWwgPSB7fSkpO1xyXG5jb25zdCBab2RQYXJzZWRUeXBlID0gdXRpbC5hcnJheVRvRW51bShbXHJcbiAgICBcInN0cmluZ1wiLFxyXG4gICAgXCJuYW5cIixcclxuICAgIFwibnVtYmVyXCIsXHJcbiAgICBcImludGVnZXJcIixcclxuICAgIFwiZmxvYXRcIixcclxuICAgIFwiYm9vbGVhblwiLFxyXG4gICAgXCJkYXRlXCIsXHJcbiAgICBcImJpZ2ludFwiLFxyXG4gICAgXCJzeW1ib2xcIixcclxuICAgIFwiZnVuY3Rpb25cIixcclxuICAgIFwidW5kZWZpbmVkXCIsXHJcbiAgICBcIm51bGxcIixcclxuICAgIFwiYXJyYXlcIixcclxuICAgIFwib2JqZWN0XCIsXHJcbiAgICBcInVua25vd25cIixcclxuICAgIFwicHJvbWlzZVwiLFxyXG4gICAgXCJ2b2lkXCIsXHJcbiAgICBcIm5ldmVyXCIsXHJcbiAgICBcIm1hcFwiLFxyXG4gICAgXCJzZXRcIixcclxuXSk7XHJcbmNvbnN0IGdldFBhcnNlZFR5cGUgPSAoZGF0YSkgPT4ge1xyXG4gICAgY29uc3QgdCA9IHR5cGVvZiBkYXRhO1xyXG4gICAgc3dpdGNoICh0KSB7XHJcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQ7XHJcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zdHJpbmc7XHJcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxyXG4gICAgICAgICAgICByZXR1cm4gaXNOYU4oZGF0YSkgPyBab2RQYXJzZWRUeXBlLm5hbiA6IFpvZFBhcnNlZFR5cGUubnVtYmVyO1xyXG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJvb2xlYW47XHJcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uO1xyXG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYmlnaW50O1xyXG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcclxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc3ltYm9sO1xyXG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmFycmF5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5udWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkYXRhLnRoZW4gJiZcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhLnRoZW4gPT09IFwiZnVuY3Rpb25cIiAmJlxyXG4gICAgICAgICAgICAgICAgZGF0YS5jYXRjaCAmJlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGRhdGEuY2F0Y2ggPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUucHJvbWlzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgTWFwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5tYXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBTZXQgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIFNldCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgRGF0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuZGF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5vYmplY3Q7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUudW5rbm93bjtcclxuICAgIH1cclxufTtcclxuXHJcbmNvbnN0IFpvZElzc3VlQ29kZSA9IHV0aWwuYXJyYXlUb0VudW0oW1xyXG4gICAgXCJpbnZhbGlkX3R5cGVcIixcclxuICAgIFwiaW52YWxpZF9saXRlcmFsXCIsXHJcbiAgICBcImN1c3RvbVwiLFxyXG4gICAgXCJpbnZhbGlkX3VuaW9uXCIsXHJcbiAgICBcImludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvclwiLFxyXG4gICAgXCJpbnZhbGlkX2VudW1fdmFsdWVcIixcclxuICAgIFwidW5yZWNvZ25pemVkX2tleXNcIixcclxuICAgIFwiaW52YWxpZF9hcmd1bWVudHNcIixcclxuICAgIFwiaW52YWxpZF9yZXR1cm5fdHlwZVwiLFxyXG4gICAgXCJpbnZhbGlkX2RhdGVcIixcclxuICAgIFwiaW52YWxpZF9zdHJpbmdcIixcclxuICAgIFwidG9vX3NtYWxsXCIsXHJcbiAgICBcInRvb19iaWdcIixcclxuICAgIFwiaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcIixcclxuICAgIFwibm90X211bHRpcGxlX29mXCIsXHJcbiAgICBcIm5vdF9maW5pdGVcIixcclxuXSk7XHJcbmNvbnN0IHF1b3RlbGVzc0pzb24gPSAob2JqKSA9PiB7XHJcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKTtcclxuICAgIHJldHVybiBqc29uLnJlcGxhY2UoL1wiKFteXCJdKylcIjovZywgXCIkMTpcIik7XHJcbn07XHJcbmNsYXNzIFpvZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoaXNzdWVzKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlzc3VlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuYWRkSXNzdWUgPSAoc3ViKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCBzdWJdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hZGRJc3N1ZXMgPSAoc3VicyA9IFtdKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCAuLi5zdWJzXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGFjdHVhbFByb3RvID0gbmV3LnRhcmdldC5wcm90b3R5cGU7XHJcbiAgICAgICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYmFuL2JhblxyXG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgYWN0dWFsUHJvdG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBhY3R1YWxQcm90bztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJab2RFcnJvclwiO1xyXG4gICAgICAgIHRoaXMuaXNzdWVzID0gaXNzdWVzO1xyXG4gICAgfVxyXG4gICAgZ2V0IGVycm9ycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc3N1ZXM7XHJcbiAgICB9XHJcbiAgICBmb3JtYXQoX21hcHBlcikge1xyXG4gICAgICAgIGNvbnN0IG1hcHBlciA9IF9tYXBwZXIgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGlzc3VlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNzdWUubWVzc2FnZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBmaWVsZEVycm9ycyA9IHsgX2Vycm9yczogW10gfTtcclxuICAgICAgICBjb25zdCBwcm9jZXNzRXJyb3IgPSAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBlcnJvci5pc3N1ZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfdW5pb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzc3VlLnVuaW9uRXJyb3JzLm1hcChwcm9jZXNzRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3JldHVybl90eXBlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUucmV0dXJuVHlwZUVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9hcmd1bWVudHNcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5hcmd1bWVudHNFcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5wYXRoLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyID0gZmllbGRFcnJvcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgaXNzdWUucGF0aC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWwgPSBpc3N1ZS5wYXRoW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXJtaW5hbCA9IGkgPT09IGlzc3VlLnBhdGgubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXJtaW5hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAodHlwZW9mIGVsID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfSBlbHNlIGlmICh0eXBlb2YgZWwgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY29uc3QgZXJyb3JBcnJheTogYW55ID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGVycm9yQXJyYXkuX2Vycm9ycyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IGVycm9yQXJyYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyID0gY3VycltlbF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHByb2Nlc3NFcnJvcih0aGlzKTtcclxuICAgICAgICByZXR1cm4gZmllbGRFcnJvcnM7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1lc3NhZ2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuaXNzdWVzLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc3N1ZXMubGVuZ3RoID09PSAwO1xyXG4gICAgfVxyXG4gICAgZmxhdHRlbihtYXBwZXIgPSAoaXNzdWUpID0+IGlzc3VlLm1lc3NhZ2UpIHtcclxuICAgICAgICBjb25zdCBmaWVsZEVycm9ycyA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGZvcm1FcnJvcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHN1YiBvZiB0aGlzLmlzc3Vlcykge1xyXG4gICAgICAgICAgICBpZiAoc3ViLnBhdGgubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dID0gZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dLnB1c2gobWFwcGVyKHN1YikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9ybUVycm9ycy5wdXNoKG1hcHBlcihzdWIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBmb3JtRXJyb3JzLCBmaWVsZEVycm9ycyB9O1xyXG4gICAgfVxyXG4gICAgZ2V0IGZvcm1FcnJvcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhdHRlbigpO1xyXG4gICAgfVxyXG59XHJcblpvZEVycm9yLmNyZWF0ZSA9IChpc3N1ZXMpID0+IHtcclxuICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKGlzc3Vlcyk7XHJcbiAgICByZXR1cm4gZXJyb3I7XHJcbn07XHJcblxyXG5jb25zdCBlcnJvck1hcCA9IChpc3N1ZSwgX2N0eCkgPT4ge1xyXG4gICAgbGV0IG1lc3NhZ2U7XHJcbiAgICBzd2l0Y2ggKGlzc3VlLmNvZGUpIHtcclxuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGU6XHJcbiAgICAgICAgICAgIGlmIChpc3N1ZS5yZWNlaXZlZCA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlJlcXVpcmVkXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEV4cGVjdGVkICR7aXNzdWUuZXhwZWN0ZWR9LCByZWNlaXZlZCAke2lzc3VlLnJlY2VpdmVkfWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsOlxyXG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgbGl0ZXJhbCB2YWx1ZSwgZXhwZWN0ZWQgJHtKU09OLnN0cmluZ2lmeShpc3N1ZS5leHBlY3RlZCwgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIpfWA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzOlxyXG4gICAgICAgICAgICBtZXNzYWdlID0gYFVucmVjb2duaXplZCBrZXkocykgaW4gb2JqZWN0OiAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5rZXlzLCBcIiwgXCIpfWA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb246XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dGA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvcjpcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfWA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZTpcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGVudW0gdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfSwgcmVjZWl2ZWQgJyR7aXNzdWUucmVjZWl2ZWR9J2A7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfYXJndW1lbnRzOlxyXG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZnVuY3Rpb24gYXJndW1lbnRzYDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9yZXR1cm5fdHlwZTpcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGZ1bmN0aW9uIHJldHVybiB0eXBlYDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9kYXRlOlxyXG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZGF0ZWA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nOlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24gPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChcImluY2x1ZGVzXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBpbmNsdWRlIFwiJHtpc3N1ZS52YWxpZGF0aW9uLmluY2x1ZGVzfVwiYDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24ucG9zaXRpb24gPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGAke21lc3NhZ2V9IGF0IG9uZSBvciBtb3JlIHBvc2l0aW9ucyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHtpc3N1ZS52YWxpZGF0aW9uLnBvc2l0aW9ufWA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJzdGFydHNXaXRoXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBzdGFydCB3aXRoIFwiJHtpc3N1ZS52YWxpZGF0aW9uLnN0YXJ0c1dpdGh9XCJgO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJlbmRzV2l0aFwiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3QgZW5kIHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uZW5kc1dpdGh9XCJgO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihpc3N1ZS52YWxpZGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS52YWxpZGF0aW9uICE9PSBcInJlZ2V4XCIpIHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCAke2lzc3VlLnZhbGlkYXRpb259YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS50b29fc21hbGw6XHJcbiAgICAgICAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEFycmF5IG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG1vcmUgdGhhbmB9ICR7aXNzdWUubWluaW11bX0gZWxlbWVudChzKWA7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IFwiZXhhY3RseVwiIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IGxlYXN0YCA6IGBvdmVyYH0gJHtpc3N1ZS5taW5pbXVtfSBjaGFyYWN0ZXIocylgO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0XHJcbiAgICAgICAgICAgICAgICAgICAgPyBgZXhhY3RseSBlcXVhbCB0byBgXHJcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgZ3JlYXRlciB0aGFuIGB9JHtpc3N1ZS5taW5pbXVtfWA7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiZGF0ZVwiKVxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBEYXRlIG11c3QgYmUgJHtpc3N1ZS5leGFjdFxyXG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHkgZXF1YWwgdG8gYFxyXG4gICAgICAgICAgICAgICAgICAgIDogaXNzdWUuaW5jbHVzaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYGdyZWF0ZXIgdGhhbiBgfSR7bmV3IERhdGUoTnVtYmVyKGlzc3VlLm1pbmltdW0pKX1gO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnRvb19iaWc6XHJcbiAgICAgICAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEFycmF5IG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IG1vc3RgIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX0gZWxlbWVudChzKWA7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGB1bmRlcmB9ICR7aXNzdWUubWF4aW11bX0gY2hhcmFjdGVyKHMpYDtcclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdFxyXG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHlgXHJcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgbGVzcyB0aGFuIG9yIGVxdWFsIHRvYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJiaWdpbnRcIilcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQmlnSW50IG11c3QgYmUgJHtpc3N1ZS5leGFjdFxyXG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHlgXHJcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgbGVzcyB0aGFuIG9yIGVxdWFsIHRvYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYERhdGUgbXVzdCBiZSAke2lzc3VlLmV4YWN0XHJcbiAgICAgICAgICAgICAgICAgICAgPyBgZXhhY3RseWBcclxuICAgICAgICAgICAgICAgICAgICA6IGlzc3VlLmluY2x1c2l2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBzbWFsbGVyIHRoYW4gb3IgZXF1YWwgdG9gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYHNtYWxsZXIgdGhhbmB9ICR7bmV3IERhdGUoTnVtYmVyKGlzc3VlLm1heGltdW0pKX1gO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmN1c3RvbTpcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0YDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXM6XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW50ZXJzZWN0aW9uIHJlc3VsdHMgY291bGQgbm90IGJlIG1lcmdlZGA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZjpcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSBhIG11bHRpcGxlIG9mICR7aXNzdWUubXVsdGlwbGVPZn1gO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5ub3RfZmluaXRlOlxyXG4gICAgICAgICAgICBtZXNzYWdlID0gXCJOdW1iZXIgbXVzdCBiZSBmaW5pdGVcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgbWVzc2FnZSA9IF9jdHguZGVmYXVsdEVycm9yO1xyXG4gICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcclxufTtcclxuXHJcbmxldCBvdmVycmlkZUVycm9yTWFwID0gZXJyb3JNYXA7XHJcbmZ1bmN0aW9uIHNldEVycm9yTWFwKG1hcCkge1xyXG4gICAgb3ZlcnJpZGVFcnJvck1hcCA9IG1hcDtcclxufVxyXG5mdW5jdGlvbiBnZXRFcnJvck1hcCgpIHtcclxuICAgIHJldHVybiBvdmVycmlkZUVycm9yTWFwO1xyXG59XHJcblxyXG5jb25zdCBtYWtlSXNzdWUgPSAocGFyYW1zKSA9PiB7XHJcbiAgICBjb25zdCB7IGRhdGEsIHBhdGgsIGVycm9yTWFwcywgaXNzdWVEYXRhIH0gPSBwYXJhbXM7XHJcbiAgICBjb25zdCBmdWxsUGF0aCA9IFsuLi5wYXRoLCAuLi4oaXNzdWVEYXRhLnBhdGggfHwgW10pXTtcclxuICAgIGNvbnN0IGZ1bGxJc3N1ZSA9IHtcclxuICAgICAgICAuLi5pc3N1ZURhdGEsXHJcbiAgICAgICAgcGF0aDogZnVsbFBhdGgsXHJcbiAgICB9O1xyXG4gICAgbGV0IGVycm9yTWVzc2FnZSA9IFwiXCI7XHJcbiAgICBjb25zdCBtYXBzID0gZXJyb3JNYXBzXHJcbiAgICAgICAgLmZpbHRlcigobSkgPT4gISFtKVxyXG4gICAgICAgIC5zbGljZSgpXHJcbiAgICAgICAgLnJldmVyc2UoKTtcclxuICAgIGZvciAoY29uc3QgbWFwIG9mIG1hcHMpIHtcclxuICAgICAgICBlcnJvck1lc3NhZ2UgPSBtYXAoZnVsbElzc3VlLCB7IGRhdGEsIGRlZmF1bHRFcnJvcjogZXJyb3JNZXNzYWdlIH0pLm1lc3NhZ2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLmlzc3VlRGF0YSxcclxuICAgICAgICBwYXRoOiBmdWxsUGF0aCxcclxuICAgICAgICBtZXNzYWdlOiBpc3N1ZURhdGEubWVzc2FnZSB8fCBlcnJvck1lc3NhZ2UsXHJcbiAgICB9O1xyXG59O1xyXG5jb25zdCBFTVBUWV9QQVRIID0gW107XHJcbmZ1bmN0aW9uIGFkZElzc3VlVG9Db250ZXh0KGN0eCwgaXNzdWVEYXRhKSB7XHJcbiAgICBjb25zdCBpc3N1ZSA9IG1ha2VJc3N1ZSh7XHJcbiAgICAgICAgaXNzdWVEYXRhOiBpc3N1ZURhdGEsXHJcbiAgICAgICAgZGF0YTogY3R4LmRhdGEsXHJcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXHJcbiAgICAgICAgZXJyb3JNYXBzOiBbXHJcbiAgICAgICAgICAgIGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxyXG4gICAgICAgICAgICBjdHguc2NoZW1hRXJyb3JNYXAsXHJcbiAgICAgICAgICAgIGdldEVycm9yTWFwKCksXHJcbiAgICAgICAgICAgIGVycm9yTWFwLCAvLyB0aGVuIGdsb2JhbCBkZWZhdWx0IG1hcFxyXG4gICAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxyXG4gICAgfSk7XHJcbiAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKGlzc3VlKTtcclxufVxyXG5jbGFzcyBQYXJzZVN0YXR1cyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gXCJ2YWxpZFwiO1xyXG4gICAgfVxyXG4gICAgZGlydHkoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwidmFsaWRcIilcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiZGlydHlcIjtcclxuICAgIH1cclxuICAgIGFib3J0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9PSBcImFib3J0ZWRcIilcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiYWJvcnRlZFwiO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzKSB7XHJcbiAgICAgICAgY29uc3QgYXJyYXlWYWx1ZSA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgcyBvZiByZXN1bHRzKSB7XHJcbiAgICAgICAgICAgIGlmIChzLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICAgICAgaWYgKHMuc3RhdHVzID09PSBcImRpcnR5XCIpXHJcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgYXJyYXlWYWx1ZS5wdXNoKHMudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGFycmF5VmFsdWUgfTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBtZXJnZU9iamVjdEFzeW5jKHN0YXR1cywgcGFpcnMpIHtcclxuICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcclxuICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAga2V5OiBhd2FpdCBwYWlyLmtleSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBhd2FpdCBwYWlyLnZhbHVlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpIHtcclxuICAgICAgICBjb25zdCBmaW5hbE9iamVjdCA9IHt9O1xyXG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xyXG4gICAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHBhaXI7XHJcbiAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxyXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIilcclxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICBpZiAoa2V5LnZhbHVlICE9PSBcIl9fcHJvdG9fX1wiICYmXHJcbiAgICAgICAgICAgICAgICAodHlwZW9mIHZhbHVlLnZhbHVlICE9PSBcInVuZGVmaW5lZFwiIHx8IHBhaXIuYWx3YXlzU2V0KSkge1xyXG4gICAgICAgICAgICAgICAgZmluYWxPYmplY3Rba2V5LnZhbHVlXSA9IHZhbHVlLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogZmluYWxPYmplY3QgfTtcclxuICAgIH1cclxufVxyXG5jb25zdCBJTlZBTElEID0gT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICBzdGF0dXM6IFwiYWJvcnRlZFwiLFxyXG59KTtcclxuY29uc3QgRElSVFkgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJkaXJ0eVwiLCB2YWx1ZSB9KTtcclxuY29uc3QgT0sgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZSB9KTtcclxuY29uc3QgaXNBYm9ydGVkID0gKHgpID0+IHguc3RhdHVzID09PSBcImFib3J0ZWRcIjtcclxuY29uc3QgaXNEaXJ0eSA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJkaXJ0eVwiO1xyXG5jb25zdCBpc1ZhbGlkID0gKHgpID0+IHguc3RhdHVzID09PSBcInZhbGlkXCI7XHJcbmNvbnN0IGlzQXN5bmMgPSAoeCkgPT4gdHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgeCBpbnN0YW5jZW9mIFByb21pc2U7XHJcblxyXG52YXIgZXJyb3JVdGlsO1xyXG4oZnVuY3Rpb24gKGVycm9yVXRpbCkge1xyXG4gICAgZXJyb3JVdGlsLmVyclRvT2JqID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlIH0gOiBtZXNzYWdlIHx8IHt9O1xyXG4gICAgZXJyb3JVdGlsLnRvU3RyaW5nID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IG1lc3NhZ2UgPT09IG51bGwgfHwgbWVzc2FnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVzc2FnZS5tZXNzYWdlO1xyXG59KShlcnJvclV0aWwgfHwgKGVycm9yVXRpbCA9IHt9KSk7XHJcblxyXG5jbGFzcyBQYXJzZUlucHV0TGF6eVBhdGgge1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50LCB2YWx1ZSwgcGF0aCwga2V5KSB7XHJcbiAgICAgICAgdGhpcy5fY2FjaGVkUGF0aCA9IFtdO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuX3BhdGggPSBwYXRoO1xyXG4gICAgICAgIHRoaXMuX2tleSA9IGtleTtcclxuICAgIH1cclxuICAgIGdldCBwYXRoKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fY2FjaGVkUGF0aC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2tleSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgLi4udGhpcy5fa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZFBhdGgucHVzaCguLi50aGlzLl9wYXRoLCB0aGlzLl9rZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRQYXRoO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGhhbmRsZVJlc3VsdCA9IChjdHgsIHJlc3VsdCkgPT4ge1xyXG4gICAgaWYgKGlzVmFsaWQocmVzdWx0KSkge1xyXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHJlc3VsdC52YWx1ZSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKCFjdHguY29tbW9uLmlzc3Vlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdGlvbiBmYWlsZWQgYnV0IG5vIGlzc3VlcyBkZXRlY3RlZC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICBnZXQgZXJyb3IoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZXJyb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoY3R4LmNvbW1vbi5pc3N1ZXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBwcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcykge1xyXG4gICAgaWYgKCFwYXJhbXMpXHJcbiAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgY29uc3QgeyBlcnJvck1hcCwgaW52YWxpZF90eXBlX2Vycm9yLCByZXF1aXJlZF9lcnJvciwgZGVzY3JpcHRpb24gfSA9IHBhcmFtcztcclxuICAgIGlmIChlcnJvck1hcCAmJiAoaW52YWxpZF90eXBlX2Vycm9yIHx8IHJlcXVpcmVkX2Vycm9yKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgdXNlIFwiaW52YWxpZF90eXBlX2Vycm9yXCIgb3IgXCJyZXF1aXJlZF9lcnJvclwiIGluIGNvbmp1bmN0aW9uIHdpdGggY3VzdG9tIGVycm9yIG1hcC5gKTtcclxuICAgIH1cclxuICAgIGlmIChlcnJvck1hcClcclxuICAgICAgICByZXR1cm4geyBlcnJvck1hcDogZXJyb3JNYXAsIGRlc2NyaXB0aW9uIH07XHJcbiAgICBjb25zdCBjdXN0b21NYXAgPSAoaXNzLCBjdHgpID0+IHtcclxuICAgICAgICBpZiAoaXNzLmNvZGUgIT09IFwiaW52YWxpZF90eXBlXCIpXHJcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IGN0eC5kZWZhdWx0RXJyb3IgfTtcclxuICAgICAgICBpZiAodHlwZW9mIGN0eC5kYXRhID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IHJlcXVpcmVkX2Vycm9yICE9PSBudWxsICYmIHJlcXVpcmVkX2Vycm9yICE9PSB2b2lkIDAgPyByZXF1aXJlZF9lcnJvciA6IGN0eC5kZWZhdWx0RXJyb3IgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogaW52YWxpZF90eXBlX2Vycm9yICE9PSBudWxsICYmIGludmFsaWRfdHlwZV9lcnJvciAhPT0gdm9pZCAwID8gaW52YWxpZF90eXBlX2Vycm9yIDogY3R4LmRlZmF1bHRFcnJvciB9O1xyXG4gICAgfTtcclxuICAgIHJldHVybiB7IGVycm9yTWFwOiBjdXN0b21NYXAsIGRlc2NyaXB0aW9uIH07XHJcbn1cclxuY2xhc3MgWm9kVHlwZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihkZWYpIHtcclxuICAgICAgICAvKiogQWxpYXMgb2Ygc2FmZVBhcnNlQXN5bmMgKi9cclxuICAgICAgICB0aGlzLnNwYSA9IHRoaXMuc2FmZVBhcnNlQXN5bmM7XHJcbiAgICAgICAgdGhpcy5fZGVmID0gZGVmO1xyXG4gICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnBhcnNlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zYWZlUGFyc2UgPSB0aGlzLnNhZmVQYXJzZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMucGFyc2VBc3luYyA9IHRoaXMucGFyc2VBc3luYy5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2FmZVBhcnNlQXN5bmMgPSB0aGlzLnNhZmVQYXJzZUFzeW5jLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zcGEgPSB0aGlzLnNwYS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMucmVmaW5lID0gdGhpcy5yZWZpbmUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlZmluZW1lbnQgPSB0aGlzLnJlZmluZW1lbnQuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnN1cGVyUmVmaW5lID0gdGhpcy5zdXBlclJlZmluZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub3B0aW9uYWwgPSB0aGlzLm9wdGlvbmFsLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5udWxsYWJsZSA9IHRoaXMubnVsbGFibGUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLm51bGxpc2ggPSB0aGlzLm51bGxpc2guYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmFycmF5ID0gdGhpcy5hcnJheS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHRoaXMucHJvbWlzZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub3IgPSB0aGlzLm9yLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5hbmQgPSB0aGlzLmFuZC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0uYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmJyYW5kID0gdGhpcy5icmFuZC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IHRoaXMuZGVmYXVsdC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuY2F0Y2ggPSB0aGlzLmNhdGNoLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5kZXNjcmliZSA9IHRoaXMuZGVzY3JpYmUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnBpcGUgPSB0aGlzLnBpcGUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlYWRvbmx5ID0gdGhpcy5yZWFkb25seS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaXNOdWxsYWJsZSA9IHRoaXMuaXNOdWxsYWJsZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaXNPcHRpb25hbCA9IHRoaXMuaXNPcHRpb25hbC5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZGVzY3JpcHRpb247XHJcbiAgICB9XHJcbiAgICBfZ2V0VHlwZShpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpO1xyXG4gICAgfVxyXG4gICAgX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpIHtcclxuICAgICAgICByZXR1cm4gKGN0eCB8fCB7XHJcbiAgICAgICAgICAgIGNvbW1vbjogaW5wdXQucGFyZW50LmNvbW1vbixcclxuICAgICAgICAgICAgZGF0YTogaW5wdXQuZGF0YSxcclxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKSxcclxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcclxuICAgICAgICAgICAgcGF0aDogaW5wdXQucGF0aCxcclxuICAgICAgICAgICAgcGFyZW50OiBpbnB1dC5wYXJlbnQsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RhdHVzOiBuZXcgUGFyc2VTdGF0dXMoKSxcclxuICAgICAgICAgICAgY3R4OiB7XHJcbiAgICAgICAgICAgICAgICBjb21tb246IGlucHV0LnBhcmVudC5jb21tb24sXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKSxcclxuICAgICAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXHJcbiAgICAgICAgICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgcGFyZW50OiBpbnB1dC5wYXJlbnQsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIF9wYXJzZVN5bmMoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZShpbnB1dCk7XHJcbiAgICAgICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeW5jaHJvbm91cyBwYXJzZSBlbmNvdW50ZXJlZCBwcm9taXNlLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIF9wYXJzZUFzeW5jKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2UoaW5wdXQpO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuICAgIH1cclxuICAgIHBhcnNlKGRhdGEsIHBhcmFtcykge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc2FmZVBhcnNlKGRhdGEsIHBhcmFtcyk7XHJcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XHJcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xyXG4gICAgfVxyXG4gICAgc2FmZVBhcnNlKGRhdGEsIHBhcmFtcykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBjdHggPSB7XHJcbiAgICAgICAgICAgIGNvbW1vbjoge1xyXG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcclxuICAgICAgICAgICAgICAgIGFzeW5jOiAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYXN5bmMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY29udGV4dHVhbEVycm9yTWFwOiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuZXJyb3JNYXAsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBhdGg6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGF0aCkgfHwgW10sXHJcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXHJcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcclxuICAgICAgICAgICAgZGF0YSxcclxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShkYXRhKSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcclxuICAgICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcclxuICAgIH1cclxuICAgIGFzeW5jIHBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zYWZlUGFyc2VBc3luYyhkYXRhLCBwYXJhbXMpO1xyXG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcylcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xyXG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcclxuICAgIH1cclxuICAgIGFzeW5jIHNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xyXG4gICAgICAgIGNvbnN0IGN0eCA9IHtcclxuICAgICAgICAgICAgY29tbW9uOiB7XHJcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgY29udGV4dHVhbEVycm9yTWFwOiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuZXJyb3JNYXAsXHJcbiAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcGF0aDogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5wYXRoKSB8fCBbXSxcclxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcclxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxyXG4gICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgbWF5YmVBc3luY1Jlc3VsdCA9IHRoaXMuX3BhcnNlKHsgZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IChpc0FzeW5jKG1heWJlQXN5bmNSZXN1bHQpXHJcbiAgICAgICAgICAgID8gbWF5YmVBc3luY1Jlc3VsdFxyXG4gICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZShtYXliZUFzeW5jUmVzdWx0KSk7XHJcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChjdHgsIHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICByZWZpbmUoY2hlY2ssIG1lc3NhZ2UpIHtcclxuICAgICAgICBjb25zdCBnZXRJc3N1ZVByb3BlcnRpZXMgPSAodmFsKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbWVzc2FnZSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlKHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoKHZhbCwgY3R4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrKHZhbCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNldEVycm9yID0gKCkgPT4gY3R4LmFkZElzc3VlKHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5jdXN0b20sXHJcbiAgICAgICAgICAgICAgICAuLi5nZXRJc3N1ZVByb3BlcnRpZXModmFsKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiByZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RXJyb3IoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIHNldEVycm9yKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVmaW5lbWVudChjaGVjaywgcmVmaW5lbWVudERhdGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgodmFsLCBjdHgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFjaGVjayh2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUodHlwZW9mIHJlZmluZW1lbnREYXRhID09PSBcImZ1bmN0aW9uXCJcclxuICAgICAgICAgICAgICAgICAgICA/IHJlZmluZW1lbnREYXRhKHZhbCwgY3R4KVxyXG4gICAgICAgICAgICAgICAgICAgIDogcmVmaW5lbWVudERhdGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9yZWZpbmVtZW50KHJlZmluZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xyXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMsXHJcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcclxuICAgICAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicmVmaW5lbWVudFwiLCByZWZpbmVtZW50IH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdXBlclJlZmluZShyZWZpbmVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQocmVmaW5lbWVudCk7XHJcbiAgICB9XHJcbiAgICBvcHRpb25hbCgpIHtcclxuICAgICAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XHJcbiAgICB9XHJcbiAgICBudWxsYWJsZSgpIHtcclxuICAgICAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XHJcbiAgICB9XHJcbiAgICBudWxsaXNoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm51bGxhYmxlKCkub3B0aW9uYWwoKTtcclxuICAgIH1cclxuICAgIGFycmF5KCkge1xyXG4gICAgICAgIHJldHVybiBab2RBcnJheS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcclxuICAgIH1cclxuICAgIHByb21pc2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIFpvZFByb21pc2UuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XHJcbiAgICB9XHJcbiAgICBvcihvcHRpb24pIHtcclxuICAgICAgICByZXR1cm4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBvcHRpb25dLCB0aGlzLl9kZWYpO1xyXG4gICAgfVxyXG4gICAgYW5kKGluY29taW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIFpvZEludGVyc2VjdGlvbi5jcmVhdGUodGhpcywgaW5jb21pbmcsIHRoaXMuX2RlZik7XHJcbiAgICB9XHJcbiAgICB0cmFuc2Zvcm0odHJhbnNmb3JtKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcclxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxyXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMsXHJcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcclxuICAgICAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZGVmYXVsdChkZWYpIHtcclxuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XHJcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcclxuICAgICAgICAgICAgaW5uZXJUeXBlOiB0aGlzLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZUZ1bmMsXHJcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGVmYXVsdCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGJyYW5kKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kQnJhbmRlZCh7XHJcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQnJhbmRlZCxcclxuICAgICAgICAgICAgdHlwZTogdGhpcyxcclxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY2F0Y2goZGVmKSB7XHJcbiAgICAgICAgY29uc3QgY2F0Y2hWYWx1ZUZ1bmMgPSB0eXBlb2YgZGVmID09PSBcImZ1bmN0aW9uXCIgPyBkZWYgOiAoKSA9PiBkZWY7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RDYXRjaCh7XHJcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcclxuICAgICAgICAgICAgaW5uZXJUeXBlOiB0aGlzLFxyXG4gICAgICAgICAgICBjYXRjaFZhbHVlOiBjYXRjaFZhbHVlRnVuYyxcclxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RDYXRjaCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGRlc2NyaWJlKGRlc2NyaXB0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgVGhpcyA9IHRoaXMuY29uc3RydWN0b3I7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUaGlzKHtcclxuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHBpcGUodGFyZ2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIFpvZFBpcGVsaW5lLmNyZWF0ZSh0aGlzLCB0YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgcmVhZG9ubHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIFpvZFJlYWRvbmx5LmNyZWF0ZSh0aGlzKTtcclxuICAgIH1cclxuICAgIGlzT3B0aW9uYWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKHVuZGVmaW5lZCkuc3VjY2VzcztcclxuICAgIH1cclxuICAgIGlzTnVsbGFibGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKG51bGwpLnN1Y2Nlc3M7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgY3VpZFJlZ2V4ID0gL15jW15cXHMtXXs4LH0kL2k7XHJcbmNvbnN0IGN1aWQyUmVnZXggPSAvXlthLXpdW2EtejAtOV0qJC87XHJcbmNvbnN0IHVsaWRSZWdleCA9IC9eWzAtOUEtSEpLTU5QLVRWLVpdezI2fSQvO1xyXG4vLyBjb25zdCB1dWlkUmVnZXggPVxyXG4vLyAgIC9eKFthLWYwLTldezh9LVthLWYwLTldezR9LVsxLTVdW2EtZjAtOV17M30tW2EtZjAtOV17NH0tW2EtZjAtOV17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7XHJcbmNvbnN0IHV1aWRSZWdleCA9IC9eWzAtOWEtZkEtRl17OH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17MTJ9JC9pO1xyXG4vLyBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NjE4MS8xNTUwMTU1XHJcbi8vIG9sZCB2ZXJzaW9uOiB0b28gc2xvdywgZGlkbid0IHN1cHBvcnQgdW5pY29kZVxyXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID0gL14oKChbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKFxcLihbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKSopfCgoXFx4MjIpKCgoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oKFtcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXXxcXHgyMXxbXFx4MjMtXFx4NWJdfFtcXHg1ZC1cXHg3ZV18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfChcXFxcKFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3Zl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkpKigoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oXFx4MjIpKSlAKCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLikrKChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpJC9pO1xyXG4vL29sZCBlbWFpbCByZWdleFxyXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID0gL14oKFtePD4oKVtcXF0uLDs6XFxzQFwiXSsoXFwuW148PigpW1xcXS4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAKCg/IS0pKFtePD4oKVtcXF0uLDs6XFxzQFwiXStcXC4pK1tePD4oKVtcXF0uLDs6XFxzQFwiXXsxLH0pW14tPD4oKVtcXF0uLDs6XFxzQFwiXSQvaTtcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxyXG4vLyAgIC9eKChbXjw+KClbXFxdXFxcXC4sOzpcXHNAXFxcIl0rKFxcLltePD4oKVtcXF1cXFxcLiw7Olxcc0BcXFwiXSspKil8KFxcXCIuK1xcXCIpKUAoKFxcWygoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcXSl8KFxcW0lQdjY6KChbYS1mMC05XXsxLDR9Oil7N318OjooW2EtZjAtOV17MSw0fTopezAsNn18KFthLWYwLTldezEsNH06KXsxfTooW2EtZjAtOV17MSw0fTopezAsNX18KFthLWYwLTldezEsNH06KXsyfTooW2EtZjAtOV17MSw0fTopezAsNH18KFthLWYwLTldezEsNH06KXszfTooW2EtZjAtOV17MSw0fTopezAsM318KFthLWYwLTldezEsNH06KXs0fTooW2EtZjAtOV17MSw0fTopezAsMn18KFthLWYwLTldezEsNH06KXs1fTooW2EtZjAtOV17MSw0fTopezAsMX0pKFthLWYwLTldezEsNH18KCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpKVxcXSl8KFtBLVphLXowLTldKFtBLVphLXowLTktXSpbQS1aYS16MC05XSkqKFxcLltBLVphLXpdezIsfSkrKSkkLztcclxuLy8gY29uc3QgZW1haWxSZWdleCA9XHJcbi8vICAgL15bYS16QS1aMC05XFwuXFwhXFwjXFwkXFwlXFwmXFwnXFwqXFwrXFwvXFw9XFw/XFxeXFxfXFxgXFx7XFx8XFx9XFx+XFwtXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSokLztcclxuLy8gY29uc3QgZW1haWxSZWdleCA9XHJcbi8vICAgL14oPzpbYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqfFwiKD86W1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4MjFcXHgyMy1cXHg1YlxceDVkLVxceDdmXXxcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBlLVxceDdmXSkqXCIpQCg/Oig/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT98XFxbKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT98W2EtejAtOS1dKlthLXowLTldOig/OltcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDIxLVxceDVhXFx4NTMtXFx4N2ZdfFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGUtXFx4N2ZdKSspXFxdKSQvaTtcclxuY29uc3QgZW1haWxSZWdleCA9IC9eKD8hXFwuKSg/IS4qXFwuXFwuKShbQS1aMC05XystXFwuXSopW0EtWjAtOV8rLV1AKFtBLVowLTldW0EtWjAtOVxcLV0qXFwuKStbQS1aXXsyLH0kL2k7XHJcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxyXG4vLyAgIC9eW2EtejAtOS4hIyQlJuKAmSorLz0/Xl9ge3x9fi1dK0BbYS16MC05LV0rKD86XFwuW2EtejAtOVxcLV0rKSokL2k7XHJcbi8vIGZyb20gaHR0cHM6Ly90aGVrZXZpbnNjb3R0LmNvbS9lbW9qaXMtaW4tamF2YXNjcmlwdC8jd3JpdGluZy1hLXJlZ3VsYXItZXhwcmVzc2lvblxyXG5jb25zdCBfZW1vamlSZWdleCA9IGBeKFxcXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY318XFxcXHB7RW1vamlfQ29tcG9uZW50fSkrJGA7XHJcbmxldCBlbW9qaVJlZ2V4O1xyXG5jb25zdCBpcHY0UmVnZXggPSAvXigoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKSQvO1xyXG5jb25zdCBpcHY2UmVnZXggPSAvXigoW2EtZjAtOV17MSw0fTopezd9fDo6KFthLWYwLTldezEsNH06KXswLDZ9fChbYS1mMC05XXsxLDR9Oil7MX06KFthLWYwLTldezEsNH06KXswLDV9fChbYS1mMC05XXsxLDR9Oil7Mn06KFthLWYwLTldezEsNH06KXswLDR9fChbYS1mMC05XXsxLDR9Oil7M306KFthLWYwLTldezEsNH06KXswLDN9fChbYS1mMC05XXsxLDR9Oil7NH06KFthLWYwLTldezEsNH06KXswLDJ9fChbYS1mMC05XXsxLDR9Oil7NX06KFthLWYwLTldezEsNH06KXswLDF9KShbYS1mMC05XXsxLDR9fCgoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKSkkLztcclxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMTQzMjMxXHJcbmNvbnN0IGRhdGV0aW1lUmVnZXggPSAoYXJncykgPT4ge1xyXG4gICAgaWYgKGFyZ3MucHJlY2lzaW9uKSB7XHJcbiAgICAgICAgaWYgKGFyZ3Mub2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBeXFxcXGR7NH0tXFxcXGR7Mn0tXFxcXGR7Mn1UXFxcXGR7Mn06XFxcXGR7Mn06XFxcXGR7Mn1cXFxcLlxcXFxkeyR7YXJncy5wcmVjaXNpb259fSgoWystXVxcXFxkezJ9KDo/XFxcXGR7Mn0pPyl8WikkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgXlxcXFxkezR9LVxcXFxkezJ9LVxcXFxkezJ9VFxcXFxkezJ9OlxcXFxkezJ9OlxcXFxkezJ9XFxcXC5cXFxcZHske2FyZ3MucHJlY2lzaW9ufX1aJGApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGFyZ3MucHJlY2lzaW9uID09PSAwKSB7XHJcbiAgICAgICAgaWYgKGFyZ3Mub2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBeXFxcXGR7NH0tXFxcXGR7Mn0tXFxcXGR7Mn1UXFxcXGR7Mn06XFxcXGR7Mn06XFxcXGR7Mn0oKFsrLV1cXFxcZHsyfSg6P1xcXFxkezJ9KT8pfFopJGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5cXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfVRcXFxcZHsyfTpcXFxcZHsyfTpcXFxcZHsyfVokYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGFyZ3Mub2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBeXFxcXGR7NH0tXFxcXGR7Mn0tXFxcXGR7Mn1UXFxcXGR7Mn06XFxcXGR7Mn06XFxcXGR7Mn0oXFxcXC5cXFxcZCspPygoWystXVxcXFxkezJ9KDo/XFxcXGR7Mn0pPyl8WikkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgXlxcXFxkezR9LVxcXFxkezJ9LVxcXFxkezJ9VFxcXFxkezJ9OlxcXFxkezJ9OlxcXFxkezJ9KFxcXFwuXFxcXGQrKT9aJGApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gaXNWYWxpZElQKGlwLCB2ZXJzaW9uKSB7XHJcbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjRcIiB8fCAhdmVyc2lvbikgJiYgaXB2NFJlZ2V4LnRlc3QoaXApKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjZcIiB8fCAhdmVyc2lvbikgJiYgaXB2NlJlZ2V4LnRlc3QoaXApKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuY2xhc3MgWm9kU3RyaW5nIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xyXG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gU3RyaW5nKGlucHV0LmRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XHJcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcclxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxyXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcclxuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xyXG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEubGVuZ3RoIDwgY2hlY2sudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmxlbmd0aCA+IGNoZWNrLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJsZW5ndGhcIikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gaW5wdXQuZGF0YS5sZW5ndGggPiBjaGVjay52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICh0b29CaWcgfHwgdG9vU21hbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b29TbWFsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImVtYWlsXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZW1haWxSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZW1haWxcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1vamlcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlbW9qaVJlZ2V4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW1vamlSZWdleCA9IG5ldyBSZWdFeHAoX2Vtb2ppUmVnZXgsIFwidVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghZW1vamlSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZW1vamlcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidXVpZFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXV1aWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidXVpZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghY3VpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjdWlkXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImN1aWQyXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghY3VpZDJSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY3VpZDJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidWxpZFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXVsaWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidWxpZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1cmxcIikge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgVVJMKGlucHV0LmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidXJsXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInJlZ2V4XCIpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrLnJlZ2V4Lmxhc3RJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0UmVzdWx0ID0gY2hlY2sucmVnZXgudGVzdChpbnB1dC5kYXRhKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGVzdFJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInJlZ2V4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRyaW1cIikge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudHJpbSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiaW5jbHVkZXNcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmluY2x1ZGVzKGNoZWNrLnZhbHVlLCBjaGVjay5wb3NpdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGluY2x1ZGVzOiBjaGVjay52YWx1ZSwgcG9zaXRpb246IGNoZWNrLnBvc2l0aW9uIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0b0xvd2VyQ2FzZVwiKSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidG9VcHBlckNhc2VcIikge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInN0YXJ0c1dpdGhcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLnN0YXJ0c1dpdGgoY2hlY2sudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBzdGFydHNXaXRoOiBjaGVjay52YWx1ZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW5kc1dpdGhcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmVuZHNXaXRoKGNoZWNrLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IHsgZW5kc1dpdGg6IGNoZWNrLnZhbHVlIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkYXRldGltZVwiKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGRhdGV0aW1lUmVnZXgoY2hlY2spO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJkYXRldGltZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiaXBcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkSVAoaW5wdXQuZGF0YSwgY2hlY2sudmVyc2lvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJpcFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcclxuICAgIH1cclxuICAgIF9yZWdleChyZWdleCwgdmFsaWRhdGlvbiwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlZmluZW1lbnQoKGRhdGEpID0+IHJlZ2V4LnRlc3QoZGF0YSksIHtcclxuICAgICAgICAgICAgdmFsaWRhdGlvbixcclxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxyXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZW1haWwobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1haWxcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xyXG4gICAgfVxyXG4gICAgdXJsKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInVybFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XHJcbiAgICB9XHJcbiAgICBlbW9qaShtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJlbW9qaVwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XHJcbiAgICB9XHJcbiAgICB1dWlkKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInV1aWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xyXG4gICAgfVxyXG4gICAgY3VpZChtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjdWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcclxuICAgIH1cclxuICAgIGN1aWQyKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWQyXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcclxuICAgIH1cclxuICAgIHVsaWQobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidWxpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XHJcbiAgICB9XHJcbiAgICBpcChvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJpcFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucykgfSk7XHJcbiAgICB9XHJcbiAgICBkYXRldGltZShvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICAgICAga2luZDogXCJkYXRldGltZVwiLFxyXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcImRhdGV0aW1lXCIsXHJcbiAgICAgICAgICAgIHByZWNpc2lvbjogdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlY2lzaW9uKSA9PT0gXCJ1bmRlZmluZWRcIiA/IG51bGwgOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlY2lzaW9uLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vZmZzZXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxyXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVnZXgocmVnZXgsIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcInJlZ2V4XCIsXHJcbiAgICAgICAgICAgIHJlZ2V4OiByZWdleCxcclxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaW5jbHVkZXModmFsdWUsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcImluY2x1ZGVzXCIsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgcG9zaXRpb246IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wb3NpdGlvbixcclxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tZXNzYWdlKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHN0YXJ0c1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcInN0YXJ0c1dpdGhcIixcclxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbmRzV2l0aCh2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwiZW5kc1dpdGhcIixcclxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBtaW4obWluTGVuZ3RoLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJtaW5cIixcclxuICAgICAgICAgICAgdmFsdWU6IG1pbkxlbmd0aCxcclxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbWF4KG1heExlbmd0aCwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXHJcbiAgICAgICAgICAgIHZhbHVlOiBtYXhMZW5ndGgsXHJcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGxlbmd0aChsZW4sIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcImxlbmd0aFwiLFxyXG4gICAgICAgICAgICB2YWx1ZTogbGVuLFxyXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB6LnN0cmluZygpLm1pbigxKSBpbnN0ZWFkLlxyXG4gICAgICogQHNlZSB7QGxpbmsgWm9kU3RyaW5nLm1pbn1cclxuICAgICAqL1xyXG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBlcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkpO1xyXG4gICAgfVxyXG4gICAgdHJpbSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRyaW1cIiB9XSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHRvTG93ZXJDYXNlKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcclxuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxyXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9Mb3dlckNhc2VcIiB9XSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHRvVXBwZXJDYXNlKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcclxuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxyXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9VcHBlckNhc2VcIiB9XSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldCBpc0RhdGV0aW1lKCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZGF0ZXRpbWVcIik7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNFbWFpbCgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImVtYWlsXCIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzVVJMKCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXJsXCIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRW1vamkoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbW9qaVwiKTtcclxuICAgIH1cclxuICAgIGdldCBpc1VVSUQoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1dWlkXCIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzQ1VJRCgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWRcIik7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNDVUlEMigpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWQyXCIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzVUxJRCgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVsaWRcIik7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNJUCgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImlwXCIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1pbkxlbmd0aCgpIHtcclxuICAgICAgICBsZXQgbWluID0gbnVsbDtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcclxuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXHJcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1pbjtcclxuICAgIH1cclxuICAgIGdldCBtYXhMZW5ndGgoKSB7XHJcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XHJcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XHJcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxyXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXg7XHJcbiAgICB9XHJcbn1cclxuWm9kU3RyaW5nLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcclxuICAgIHZhciBfYTtcclxuICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcclxuICAgICAgICBjaGVja3M6IFtdLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3RyaW5nLFxyXG4gICAgICAgIGNvZXJjZTogKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM5NjY0ODQvd2h5LWRvZXMtbW9kdWx1cy1vcGVyYXRvci1yZXR1cm4tZnJhY3Rpb25hbC1udW1iZXItaW4tamF2YXNjcmlwdC8zMTcxMTAzNCMzMTcxMTAzNFxyXG5mdW5jdGlvbiBmbG9hdFNhZmVSZW1haW5kZXIodmFsLCBzdGVwKSB7XHJcbiAgICBjb25zdCB2YWxEZWNDb3VudCA9ICh2YWwudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xyXG4gICAgY29uc3Qgc3RlcERlY0NvdW50ID0gKHN0ZXAudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xyXG4gICAgY29uc3QgZGVjQ291bnQgPSB2YWxEZWNDb3VudCA+IHN0ZXBEZWNDb3VudCA/IHZhbERlY0NvdW50IDogc3RlcERlY0NvdW50O1xyXG4gICAgY29uc3QgdmFsSW50ID0gcGFyc2VJbnQodmFsLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcclxuICAgIGNvbnN0IHN0ZXBJbnQgPSBwYXJzZUludChzdGVwLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcclxuICAgIHJldHVybiAodmFsSW50ICUgc3RlcEludCkgLyBNYXRoLnBvdygxMCwgZGVjQ291bnQpO1xyXG59XHJcbmNsYXNzIFpvZE51bWJlciBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm1pbiA9IHRoaXMuZ3RlO1xyXG4gICAgICAgIHRoaXMubWF4ID0gdGhpcy5sdGU7XHJcbiAgICAgICAgdGhpcy5zdGVwID0gdGhpcy5tdWx0aXBsZU9mO1xyXG4gICAgfVxyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcclxuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IE51bWJlcihpbnB1dC5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xyXG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bWJlcikge1xyXG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bWJlcixcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xyXG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJpbnRcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzSW50ZWdlcihpbnB1dC5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJpbnRlZ2VyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBcImZsb2F0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmVcclxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPCBjaGVjay52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA8PSBjaGVjay52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICh0b29TbWFsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0b29CaWcgPSBjaGVjay5pbmNsdXNpdmVcclxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA+PSBjaGVjay52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICh0b29CaWcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmxvYXRTYWZlUmVtYWluZGVyKGlucHV0LmRhdGEsIGNoZWNrLnZhbHVlKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZU9mOiBjaGVjay52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImZpbml0ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShpbnB1dC5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xyXG4gICAgfVxyXG4gICAgZ3RlKHZhbHVlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XHJcbiAgICB9XHJcbiAgICBndCh2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcclxuICAgIH1cclxuICAgIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xyXG4gICAgfVxyXG4gICAgbHQodmFsdWUsIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XHJcbiAgICB9XHJcbiAgICBzZXRMaW1pdChraW5kLCB2YWx1ZSwgaW5jbHVzaXZlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIGNoZWNrczogW1xyXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBraW5kLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGludChtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJpbnRcIixcclxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcG9zaXRpdmUobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXHJcbiAgICAgICAgICAgIHZhbHVlOiAwLFxyXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJtYXhcIixcclxuICAgICAgICAgICAgdmFsdWU6IDAsXHJcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxyXG4gICAgICAgICAgICB2YWx1ZTogMCxcclxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBub25uZWdhdGl2ZShtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJtaW5cIixcclxuICAgICAgICAgICAgdmFsdWU6IDAsXHJcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxyXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZpbml0ZShtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJmaW5pdGVcIixcclxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2FmZShtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJtaW5cIixcclxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcclxuICAgICAgICB9KS5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxyXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcclxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1pblZhbHVlKCkge1xyXG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xyXG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWluO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1heFZhbHVlKCkge1xyXG4gICAgICAgIGxldCBtYXggPSBudWxsO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xyXG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcclxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF4O1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzSW50KCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiaW50XCIgfHxcclxuICAgICAgICAgICAgKGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiICYmIHV0aWwuaXNJbnRlZ2VyKGNoLnZhbHVlKSkpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRmluaXRlKCkge1xyXG4gICAgICAgIGxldCBtYXggPSBudWxsLCBtaW4gPSBudWxsO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xyXG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJmaW5pdGVcIiB8fFxyXG4gICAgICAgICAgICAgICAgY2gua2luZCA9PT0gXCJpbnRcIiB8fFxyXG4gICAgICAgICAgICAgICAgY2gua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXHJcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcclxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG1pbikgJiYgTnVtYmVyLmlzRmluaXRlKG1heCk7XHJcbiAgICB9XHJcbn1cclxuWm9kTnVtYmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcclxuICAgICAgICBjaGVja3M6IFtdLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVtYmVyLFxyXG4gICAgICAgIGNvZXJjZTogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8IGZhbHNlLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2RCaWdJbnQgZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5taW4gPSB0aGlzLmd0ZTtcclxuICAgICAgICB0aGlzLm1heCA9IHRoaXMubHRlO1xyXG4gICAgfVxyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcclxuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IEJpZ0ludChpbnB1dC5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xyXG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJpZ2ludCkge1xyXG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJpZ2ludCxcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xyXG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmVcclxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPCBjaGVjay52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA8PSBjaGVjay52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICh0b29TbWFsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY2hlY2suaW5jbHVzaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC5kYXRhID4gY2hlY2sudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhICUgY2hlY2sudmFsdWUgIT09IEJpZ0ludCgwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZU9mOiBjaGVjay52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xyXG4gICAgfVxyXG4gICAgZ3RlKHZhbHVlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XHJcbiAgICB9XHJcbiAgICBndCh2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcclxuICAgIH1cclxuICAgIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xyXG4gICAgfVxyXG4gICAgbHQodmFsdWUsIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XHJcbiAgICB9XHJcbiAgICBzZXRMaW1pdChraW5kLCB2YWx1ZSwgaW5jbHVzaXZlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCaWdJbnQoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIGNoZWNrczogW1xyXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBraW5kLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCaWdJbnQoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHBvc2l0aXZlKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxyXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxyXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJtYXhcIixcclxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcclxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcclxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbm9ucG9zaXRpdmUobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXHJcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXHJcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbm9ubmVnYXRpdmUobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXHJcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXHJcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XHJcbiAgICAgICAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxyXG4gICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1pblZhbHVlKCkge1xyXG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xyXG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWluO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1heFZhbHVlKCkge1xyXG4gICAgICAgIGxldCBtYXggPSBudWxsO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xyXG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcclxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF4O1xyXG4gICAgfVxyXG59XHJcblpvZEJpZ0ludC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XHJcbiAgICAgICAgY2hlY2tzOiBbXSxcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJpZ0ludCxcclxuICAgICAgICBjb2VyY2U6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2RCb29sZWFuIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xyXG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gQm9vbGVhbihpbnB1dC5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xyXG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJvb2xlYW4pIHtcclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5ib29sZWFuLFxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcclxuICAgIH1cclxufVxyXG5ab2RCb29sZWFuLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kQm9vbGVhbih7XHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCb29sZWFuLFxyXG4gICAgICAgIGNvZXJjZTogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8IGZhbHNlLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2REYXRlIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xyXG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gbmV3IERhdGUoaW5wdXQuZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcclxuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5kYXRlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcclxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxyXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuZGF0ZSxcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNOYU4oaW5wdXQuZGF0YS5nZXRUaW1lKCkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcclxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9kYXRlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xyXG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5nZXRUaW1lKCkgPCBjaGVjay52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZGF0ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmdldFRpbWUoKSA+IGNoZWNrLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZGF0ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMudmFsdWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgRGF0ZShpbnB1dC5kYXRhLmdldFRpbWUoKSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIF9hZGRDaGVjayhjaGVjaykge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kRGF0ZSh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbWluKG1pbkRhdGUsIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xyXG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxyXG4gICAgICAgICAgICB2YWx1ZTogbWluRGF0ZS5nZXRUaW1lKCksXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG1heChtYXhEYXRlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcclxuICAgICAgICAgICAga2luZDogXCJtYXhcIixcclxuICAgICAgICAgICAgdmFsdWU6IG1heERhdGUuZ2V0VGltZSgpLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXQgbWluRGF0ZSgpIHtcclxuICAgICAgICBsZXQgbWluID0gbnVsbDtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcclxuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXHJcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1pbiAhPSBudWxsID8gbmV3IERhdGUobWluKSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXQgbWF4RGF0ZSgpIHtcclxuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcclxuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1heCAhPSBudWxsID8gbmV3IERhdGUobWF4KSA6IG51bGw7XHJcbiAgICB9XHJcbn1cclxuWm9kRGF0ZS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xyXG4gICAgICAgIGNoZWNrczogW10sXHJcbiAgICAgICAgY29lcmNlOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgfHwgZmFsc2UsXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REYXRlLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2RTeW1ib2wgZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcclxuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zeW1ib2wpIHtcclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zeW1ib2wsXHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xyXG4gICAgfVxyXG59XHJcblpvZFN5bWJvbC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZFN5bWJvbCh7XHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTeW1ib2wsXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmNsYXNzIFpvZFVuZGVmaW5lZCBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xyXG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XHJcbiAgICB9XHJcbn1cclxuWm9kVW5kZWZpbmVkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kVW5kZWZpbmVkKHtcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuZGVmaW5lZCxcclxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICB9KTtcclxufTtcclxuY2xhc3MgWm9kTnVsbCBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xyXG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bGwpIHtcclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5udWxsLFxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcclxuICAgIH1cclxufVxyXG5ab2ROdWxsLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kTnVsbCh7XHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2RBbnkgZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgLy8gdG8gcHJldmVudCBpbnN0YW5jZXMgb2Ygb3RoZXIgY2xhc3NlcyBmcm9tIGV4dGVuZGluZyBab2RBbnkuIHRoaXMgY2F1c2VzIGlzc3VlcyB3aXRoIGNhdGNoYWxsIGluIFpvZE9iamVjdC5cclxuICAgICAgICB0aGlzLl9hbnkgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xyXG4gICAgfVxyXG59XHJcblpvZEFueS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZEFueSh7XHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RBbnksXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmNsYXNzIFpvZFVua25vd24gZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgLy8gcmVxdWlyZWRcclxuICAgICAgICB0aGlzLl91bmtub3duID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcclxuICAgIH1cclxufVxyXG5ab2RVbmtub3duLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kVW5rbm93bih7XHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmtub3duLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2ROZXZlciBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xyXG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxyXG4gICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5uZXZlcixcclxuICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgfVxyXG59XHJcblpvZE5ldmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kTmV2ZXIoe1xyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmV2ZXIsXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmNsYXNzIFpvZFZvaWQgZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcclxuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS52b2lkLFxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcclxuICAgIH1cclxufVxyXG5ab2RWb2lkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kVm9pZCh7XHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RWb2lkLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2RBcnJheSBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgeyBjdHgsIHN0YXR1cyB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcclxuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XHJcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWYuZXhhY3RMZW5ndGggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY3R4LmRhdGEubGVuZ3RoID4gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xyXG4gICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGN0eC5kYXRhLmxlbmd0aCA8IGRlZi5leGFjdExlbmd0aC52YWx1ZTtcclxuICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xyXG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZTogdG9vQmlnID8gWm9kSXNzdWVDb2RlLnRvb19iaWcgOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06ICh0b29TbWFsbCA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogKHRvb0JpZyA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYuZXhhY3RMZW5ndGgubWVzc2FnZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlZi5taW5MZW5ndGggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IGRlZi5taW5MZW5ndGgudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXHJcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pbkxlbmd0aC52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluTGVuZ3RoLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWYubWF4TGVuZ3RoICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPiBkZWYubWF4TGVuZ3RoLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcclxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4TGVuZ3RoLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcclxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhMZW5ndGgubWVzc2FnZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmLnR5cGUuX3BhcnNlQXN5bmMobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSk7XHJcbiAgICAgICAgICAgIH0pKS50aGVuKChyZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWYudHlwZS5fcGFyc2VTeW5jKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcclxuICAgIH1cclxuICAgIGdldCBlbGVtZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcclxuICAgIH1cclxuICAgIG1pbihtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcclxuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxyXG4gICAgICAgICAgICBtaW5MZW5ndGg6IHsgdmFsdWU6IG1pbkxlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBtYXgobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgbWF4TGVuZ3RoOiB7IHZhbHVlOiBtYXhMZW5ndGgsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbGVuZ3RoKGxlbiwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIGV4YWN0TGVuZ3RoOiB7IHZhbHVlOiBsZW4sIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcclxuICAgIH1cclxufVxyXG5ab2RBcnJheS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xyXG4gICAgICAgIHR5cGU6IHNjaGVtYSxcclxuICAgICAgICBtaW5MZW5ndGg6IG51bGwsXHJcbiAgICAgICAgbWF4TGVuZ3RoOiBudWxsLFxyXG4gICAgICAgIGV4YWN0TGVuZ3RoOiBudWxsLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQXJyYXksXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmZ1bmN0aW9uIGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYSkge1xyXG4gICAgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE9iamVjdCkge1xyXG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLnNoYXBlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gc2NoZW1hLnNoYXBlW2tleV07XHJcbiAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBab2RPcHRpb25hbC5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoZmllbGRTY2hlbWEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xyXG4gICAgICAgICAgICAuLi5zY2hlbWEuX2RlZixcclxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kQXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcclxuICAgICAgICAgICAgLi4uc2NoZW1hLl9kZWYsXHJcbiAgICAgICAgICAgIHR5cGU6IGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS5lbGVtZW50KSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE9wdGlvbmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE51bGxhYmxlKSB7XHJcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZFR1cGxlKSB7XHJcbiAgICAgICAgcmV0dXJuIFpvZFR1cGxlLmNyZWF0ZShzY2hlbWEuaXRlbXMubWFwKChpdGVtKSA9PiBkZWVwUGFydGlhbGlmeShpdGVtKSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBab2RPYmplY3QgZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5fY2FjaGVkID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBJbiBtb3N0IGNhc2VzLCB0aGlzIGlzIG5vIGxvbmdlciBuZWVkZWQgLSB1bmtub3duIHByb3BlcnRpZXMgYXJlIG5vdyBzaWxlbnRseSBzdHJpcHBlZC5cclxuICAgICAgICAgKiBJZiB5b3Ugd2FudCB0byBwYXNzIHRocm91Z2ggdW5rbm93biBwcm9wZXJ0aWVzLCB1c2UgYC5wYXNzdGhyb3VnaCgpYCBpbnN0ZWFkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubm9uc3RyaWN0ID0gdGhpcy5wYXNzdGhyb3VnaDtcclxuICAgICAgICAvLyBleHRlbmQ8XHJcbiAgICAgICAgLy8gICBBdWdtZW50YXRpb24gZXh0ZW5kcyBab2RSYXdTaGFwZSxcclxuICAgICAgICAvLyAgIE5ld091dHB1dCBleHRlbmRzIHV0aWwuZmxhdHRlbjx7XHJcbiAgICAgICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cclxuICAgICAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cclxuICAgICAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBPdXRwdXRcclxuICAgICAgICAvLyAgICAgICA/IE91dHB1dFtrXVxyXG4gICAgICAgIC8vICAgICAgIDogbmV2ZXI7XHJcbiAgICAgICAgLy8gICB9PixcclxuICAgICAgICAvLyAgIE5ld0lucHV0IGV4dGVuZHMgdXRpbC5mbGF0dGVuPHtcclxuICAgICAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXHJcbiAgICAgICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfaW5wdXRcIl1cclxuICAgICAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBJbnB1dFxyXG4gICAgICAgIC8vICAgICAgID8gSW5wdXRba11cclxuICAgICAgICAvLyAgICAgICA6IG5ldmVyO1xyXG4gICAgICAgIC8vICAgfT5cclxuICAgICAgICAvLyA+KFxyXG4gICAgICAgIC8vICAgYXVnbWVudGF0aW9uOiBBdWdtZW50YXRpb25cclxuICAgICAgICAvLyApOiBab2RPYmplY3Q8XHJcbiAgICAgICAgLy8gICBleHRlbmRTaGFwZTxULCBBdWdtZW50YXRpb24+LFxyXG4gICAgICAgIC8vICAgVW5rbm93bktleXMsXHJcbiAgICAgICAgLy8gICBDYXRjaGFsbCxcclxuICAgICAgICAvLyAgIE5ld091dHB1dCxcclxuICAgICAgICAvLyAgIE5ld0lucHV0XHJcbiAgICAgICAgLy8gPiB7XHJcbiAgICAgICAgLy8gICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XHJcbiAgICAgICAgLy8gICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAvLyAgICAgc2hhcGU6ICgpID0+ICh7XHJcbiAgICAgICAgLy8gICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXHJcbiAgICAgICAgLy8gICAgICAgLi4uYXVnbWVudGF0aW9uLFxyXG4gICAgICAgIC8vICAgICB9KSxcclxuICAgICAgICAvLyAgIH0pIGFzIGFueTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIGAuZXh0ZW5kYCBpbnN0ZWFkXHJcbiAgICAgICAgICogICovXHJcbiAgICAgICAgdGhpcy5hdWdtZW50ID0gdGhpcy5leHRlbmQ7XHJcbiAgICB9XHJcbiAgICBfZ2V0Q2FjaGVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jYWNoZWQgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWQ7XHJcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLl9kZWYuc2hhcGUoKTtcclxuICAgICAgICBjb25zdCBrZXlzID0gdXRpbC5vYmplY3RLZXlzKHNoYXBlKTtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX2NhY2hlZCA9IHsgc2hhcGUsIGtleXMgfSk7XHJcbiAgICB9XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XHJcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcclxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxyXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XHJcbiAgICAgICAgY29uc3QgeyBzaGFwZSwga2V5czogc2hhcGVLZXlzIH0gPSB0aGlzLl9nZXRDYWNoZWQoKTtcclxuICAgICAgICBjb25zdCBleHRyYUtleXMgPSBbXTtcclxuICAgICAgICBpZiAoISh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBab2ROZXZlciAmJlxyXG4gICAgICAgICAgICB0aGlzLl9kZWYudW5rbm93bktleXMgPT09IFwic3RyaXBcIikpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcclxuICAgICAgICAgICAgICAgIGlmICghc2hhcGVLZXlzLmluY2x1ZGVzKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHRyYUtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Ygc2hhcGVLZXlzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleVZhbGlkYXRvciA9IHNoYXBlW2tleV07XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcclxuICAgICAgICAgICAgcGFpcnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBrZXlWYWxpZGF0b3IuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkpLFxyXG4gICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZGVmLmNhdGNoYWxsIGluc3RhbmNlb2YgWm9kTmV2ZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgdW5rbm93bktleXMgPSB0aGlzLl9kZWYudW5rbm93bktleXM7XHJcbiAgICAgICAgICAgIGlmICh1bmtub3duS2V5cyA9PT0gXCJwYXNzdGhyb3VnaFwiKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogY3R4LmRhdGFba2V5XSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHVua25vd25LZXlzID09PSBcInN0cmljdFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFLZXlzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBleHRyYUtleXMsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaXBcIikgO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW50ZXJuYWwgWm9kT2JqZWN0IGVycm9yOiBpbnZhbGlkIHVua25vd25LZXlzIHZhbHVlLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBydW4gY2F0Y2hhbGwgdmFsaWRhdGlvblxyXG4gICAgICAgICAgICBjb25zdCBjYXRjaGFsbCA9IHRoaXMuX2RlZi5jYXRjaGFsbDtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZXh0cmFLZXlzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XHJcbiAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2F0Y2hhbGwuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkgLy8sIGN0eC5jaGlsZChrZXkpLCB2YWx1ZSwgZ2V0UGFyc2VkVHlwZSh2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bmNQYWlycy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXdhaXQgcGFpci52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBwYWlyLmFsd2F5c1NldCxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBzeW5jUGFpcnM7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbigoc3luY1BhaXJzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgc3luY1BhaXJzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBzaGFwZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNoYXBlKCk7XHJcbiAgICB9XHJcbiAgICBzdHJpY3QobWVzc2FnZSkge1xyXG4gICAgICAgIGVycm9yVXRpbC5lcnJUb09iajtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXHJcbiAgICAgICAgICAgIC4uLihtZXNzYWdlICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWFwOiAoaXNzdWUsIGN0eCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRFcnJvciA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuX2RlZikuZXJyb3JNYXApID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBpc3N1ZSwgY3R4KS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBjdHguZGVmYXVsdEVycm9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJ1bnJlY29nbml6ZWRfa2V5c1wiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAoX2QgPSBlcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkubWVzc2FnZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZGVmYXVsdEVycm9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZmF1bHRFcnJvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgOiB7fSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdHJpcCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHBhc3N0aHJvdWdoKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcclxuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxyXG4gICAgICAgICAgICB1bmtub3duS2V5czogXCJwYXNzdGhyb3VnaFwiLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gY29uc3QgQXVnbWVudEZhY3RvcnkgPVxyXG4gICAgLy8gICA8RGVmIGV4dGVuZHMgWm9kT2JqZWN0RGVmPihkZWY6IERlZikgPT5cclxuICAgIC8vICAgPEF1Z21lbnRhdGlvbiBleHRlbmRzIFpvZFJhd1NoYXBlPihcclxuICAgIC8vICAgICBhdWdtZW50YXRpb246IEF1Z21lbnRhdGlvblxyXG4gICAgLy8gICApOiBab2RPYmplY3Q8XHJcbiAgICAvLyAgICAgZXh0ZW5kU2hhcGU8UmV0dXJuVHlwZTxEZWZbXCJzaGFwZVwiXT4sIEF1Z21lbnRhdGlvbj4sXHJcbiAgICAvLyAgICAgRGVmW1widW5rbm93bktleXNcIl0sXHJcbiAgICAvLyAgICAgRGVmW1wiY2F0Y2hhbGxcIl1cclxuICAgIC8vICAgPiA9PiB7XHJcbiAgICAvLyAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xyXG4gICAgLy8gICAgICAgLi4uZGVmLFxyXG4gICAgLy8gICAgICAgc2hhcGU6ICgpID0+ICh7XHJcbiAgICAvLyAgICAgICAgIC4uLmRlZi5zaGFwZSgpLFxyXG4gICAgLy8gICAgICAgICAuLi5hdWdtZW50YXRpb24sXHJcbiAgICAvLyAgICAgICB9KSxcclxuICAgIC8vICAgICB9KSBhcyBhbnk7XHJcbiAgICAvLyAgIH07XHJcbiAgICBleHRlbmQoYXVnbWVudGF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXHJcbiAgICAgICAgICAgICAgICAuLi5hdWdtZW50YXRpb24sXHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmlvciB0byB6b2RAMS4wLjEyIHRoZXJlIHdhcyBhIGJ1ZyBpbiB0aGVcclxuICAgICAqIGluZmVycmVkIHR5cGUgb2YgbWVyZ2VkIG9iamVjdHMuIFBsZWFzZVxyXG4gICAgICogdXBncmFkZSBpZiB5b3UgYXJlIGV4cGVyaWVuY2luZyBpc3N1ZXMuXHJcbiAgICAgKi9cclxuICAgIG1lcmdlKG1lcmdpbmcpIHtcclxuICAgICAgICBjb25zdCBtZXJnZWQgPSBuZXcgWm9kT2JqZWN0KHtcclxuICAgICAgICAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcclxuICAgICAgICAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcclxuICAgICAgICAgICAgc2hhcGU6ICgpID0+ICh7XHJcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuc2hhcGUoKSxcclxuICAgICAgICAgICAgICAgIC4uLm1lcmdpbmcuX2RlZi5zaGFwZSgpLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG1lcmdlZDtcclxuICAgIH1cclxuICAgIC8vIG1lcmdlPFxyXG4gICAgLy8gICBJbmNvbWluZyBleHRlbmRzIEFueVpvZE9iamVjdCxcclxuICAgIC8vICAgQXVnbWVudGF0aW9uIGV4dGVuZHMgSW5jb21pbmdbXCJzaGFwZVwiXSxcclxuICAgIC8vICAgTmV3T3V0cHV0IGV4dGVuZHMge1xyXG4gICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cclxuICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX291dHB1dFwiXVxyXG4gICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgT3V0cHV0XHJcbiAgICAvLyAgICAgICA/IE91dHB1dFtrXVxyXG4gICAgLy8gICAgICAgOiBuZXZlcjtcclxuICAgIC8vICAgfSxcclxuICAgIC8vICAgTmV3SW5wdXQgZXh0ZW5kcyB7XHJcbiAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXHJcbiAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9pbnB1dFwiXVxyXG4gICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgSW5wdXRcclxuICAgIC8vICAgICAgID8gSW5wdXRba11cclxuICAgIC8vICAgICAgIDogbmV2ZXI7XHJcbiAgICAvLyAgIH1cclxuICAgIC8vID4oXHJcbiAgICAvLyAgIG1lcmdpbmc6IEluY29taW5nXHJcbiAgICAvLyApOiBab2RPYmplY3Q8XHJcbiAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcclxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1widW5rbm93bktleXNcIl0sXHJcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdLFxyXG4gICAgLy8gICBOZXdPdXRwdXQsXHJcbiAgICAvLyAgIE5ld0lucHV0XHJcbiAgICAvLyA+IHtcclxuICAgIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcclxuICAgIC8vICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxyXG4gICAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXHJcbiAgICAvLyAgICAgc2hhcGU6ICgpID0+XHJcbiAgICAvLyAgICAgICBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKHRoaXMuX2RlZi5zaGFwZSgpLCBtZXJnaW5nLl9kZWYuc2hhcGUoKSksXHJcbiAgICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXHJcbiAgICAvLyAgIH0pIGFzIGFueTtcclxuICAgIC8vICAgcmV0dXJuIG1lcmdlZDtcclxuICAgIC8vIH1cclxuICAgIHNldEtleShrZXksIHNjaGVtYSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF1Z21lbnQoeyBba2V5XTogc2NoZW1hIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gbWVyZ2U8SW5jb21pbmcgZXh0ZW5kcyBBbnlab2RPYmplY3Q+KFxyXG4gICAgLy8gICBtZXJnaW5nOiBJbmNvbWluZ1xyXG4gICAgLy8gKTogLy9ab2RPYmplY3Q8VCAmIEluY29taW5nW1wiX3NoYXBlXCJdLCBVbmtub3duS2V5cywgQ2F0Y2hhbGw+ID0gKG1lcmdpbmcpID0+IHtcclxuICAgIC8vIFpvZE9iamVjdDxcclxuICAgIC8vICAgZXh0ZW5kU2hhcGU8VCwgUmV0dXJuVHlwZTxJbmNvbWluZ1tcIl9kZWZcIl1bXCJzaGFwZVwiXT4+LFxyXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcclxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1wiY2F0Y2hhbGxcIl1cclxuICAgIC8vID4ge1xyXG4gICAgLy8gICAvLyBjb25zdCBtZXJnZWRTaGFwZSA9IG9iamVjdFV0aWwubWVyZ2VTaGFwZXMoXHJcbiAgICAvLyAgIC8vICAgdGhpcy5fZGVmLnNoYXBlKCksXHJcbiAgICAvLyAgIC8vICAgbWVyZ2luZy5fZGVmLnNoYXBlKClcclxuICAgIC8vICAgLy8gKTtcclxuICAgIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcclxuICAgIC8vICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxyXG4gICAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXHJcbiAgICAvLyAgICAgc2hhcGU6ICgpID0+XHJcbiAgICAvLyAgICAgICBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKHRoaXMuX2RlZi5zaGFwZSgpLCBtZXJnaW5nLl9kZWYuc2hhcGUoKSksXHJcbiAgICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXHJcbiAgICAvLyAgIH0pIGFzIGFueTtcclxuICAgIC8vICAgcmV0dXJuIG1lcmdlZDtcclxuICAgIC8vIH1cclxuICAgIGNhdGNoYWxsKGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIGNhdGNoYWxsOiBpbmRleCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHBpY2sobWFzaykge1xyXG4gICAgICAgIGNvbnN0IHNoYXBlID0ge307XHJcbiAgICAgICAgdXRpbC5vYmplY3RLZXlzKG1hc2spLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAobWFza1trZXldICYmIHRoaXMuc2hhcGVba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcclxuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxyXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBvbWl0KG1hc2spIHtcclxuICAgICAgICBjb25zdCBzaGFwZSA9IHt9O1xyXG4gICAgICAgIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFtYXNrW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICovXHJcbiAgICBkZWVwUGFydGlhbCgpIHtcclxuICAgICAgICByZXR1cm4gZGVlcFBhcnRpYWxpZnkodGhpcyk7XHJcbiAgICB9XHJcbiAgICBwYXJ0aWFsKG1hc2spIHtcclxuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xyXG4gICAgICAgIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XHJcbiAgICAgICAgICAgIGlmIChtYXNrICYmICFtYXNrW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBmaWVsZFNjaGVtYTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBmaWVsZFNjaGVtYS5vcHRpb25hbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlcXVpcmVkKG1hc2spIHtcclxuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xyXG4gICAgICAgIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgICAgICAgaWYgKG1hc2sgJiYgIW1hc2tba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgbGV0IG5ld0ZpZWxkID0gZmllbGRTY2hlbWE7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV3RmllbGQgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0ZpZWxkID0gbmV3RmllbGQuX2RlZi5pbm5lclR5cGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gbmV3RmllbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAga2V5b2YoKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVpvZEVudW0odXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpKTtcclxuICAgIH1cclxufVxyXG5ab2RPYmplY3QuY3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcclxuICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXHJcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcclxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcblpvZE9iamVjdC5zdHJpY3RDcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xyXG4gICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcclxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcclxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcblpvZE9iamVjdC5sYXp5Y3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcclxuICAgICAgICBzaGFwZSxcclxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxyXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcclxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICB9KTtcclxufTtcclxuY2xhc3MgWm9kVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9kZWYub3B0aW9ucztcclxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVSZXN1bHRzKHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgLy8gcmV0dXJuIGZpcnN0IGlzc3VlLWZyZWUgdmFsaWRhdGlvbiBpZiBpdCBleGlzdHNcclxuICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBpc3N1ZXMgZnJvbSBkaXJ0eSBvcHRpb25cclxuICAgICAgICAgICAgICAgICAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKC4uLnJlc3VsdC5jdHguY29tbW9uLmlzc3Vlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmV0dXJuIGludmFsaWRcclxuICAgICAgICAgICAgY29uc3QgdW5pb25FcnJvcnMgPSByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiBuZXcgWm9kRXJyb3IocmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKSk7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXHJcbiAgICAgICAgICAgICAgICB1bmlvbkVycm9ycyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwob3B0aW9ucy5tYXAoYXN5bmMgKG9wdGlvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDdHggPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4uY3R4LFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jdHguY29tbW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBhd2FpdCBvcHRpb24uX3BhcnNlQXN5bmMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY2hpbGRDdHgsXHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgY3R4OiBjaGlsZEN0eCxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pKS50aGVuKGhhbmRsZVJlc3VsdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGRpcnR5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBjb25zdCBpc3N1ZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDdHggPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4uY3R4LFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jdHguY29tbW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGlvbi5fcGFyc2VTeW5jKHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIiAmJiAhZGlydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXJ0eSA9IHsgcmVzdWx0LCBjdHg6IGNoaWxkQ3R4IH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRDdHguY29tbW9uLmlzc3Vlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpc3N1ZXMucHVzaChjaGlsZEN0eC5jb21tb24uaXNzdWVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlydHkpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goLi4uZGlydHkuY3R4LmNvbW1vbi5pc3N1ZXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpcnR5LnJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB1bmlvbkVycm9ycyA9IGlzc3Vlcy5tYXAoKGlzc3VlcykgPT4gbmV3IFpvZEVycm9yKGlzc3VlcykpO1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uLFxyXG4gICAgICAgICAgICAgICAgdW5pb25FcnJvcnMsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgb3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XHJcbiAgICB9XHJcbn1cclxuWm9kVW5pb24uY3JlYXRlID0gKHR5cGVzLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kVW5pb24oe1xyXG4gICAgICAgIG9wdGlvbnM6IHR5cGVzLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5pb24sXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXHJcbi8vLy8vLy8vLy8gICAgICBab2REaXNjcmltaW5hdGVkVW5pb24gICAgICAvLy8vLy8vLy8vXHJcbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbmNvbnN0IGdldERpc2NyaW1pbmF0b3IgPSAodHlwZSkgPT4ge1xyXG4gICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RMYXp5KSB7XHJcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5zY2hlbWEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEVmZmVjdHMpIHtcclxuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLmlubmVyVHlwZSgpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RMaXRlcmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIFt0eXBlLnZhbHVlXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RFbnVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGUub3B0aW9ucztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROYXRpdmVFbnVtKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGJhbi9iYW5cclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModHlwZS5lbnVtKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2REZWZhdWx0KSB7XHJcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5fZGVmLmlubmVyVHlwZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kVW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIFt1bmRlZmluZWRdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE51bGwpIHtcclxuICAgICAgICByZXR1cm4gW251bGxdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn07XHJcbmNsYXNzIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XHJcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IHRoaXMuZGlzY3JpbWluYXRvcjtcclxuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWUgPSBjdHguZGF0YVtkaXNjcmltaW5hdG9yXTtcclxuICAgICAgICBjb25zdCBvcHRpb24gPSB0aGlzLm9wdGlvbnNNYXAuZ2V0KGRpc2NyaW1pbmF0b3JWYWx1ZSk7XHJcbiAgICAgICAgaWYgKCFvcHRpb24pIHtcclxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9uczogQXJyYXkuZnJvbSh0aGlzLm9wdGlvbnNNYXAua2V5cygpKSxcclxuICAgICAgICAgICAgICAgIHBhdGg6IFtkaXNjcmltaW5hdG9yXSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZUFzeW5jKHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXHJcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZVN5bmMoe1xyXG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXHJcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcclxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgZGlzY3JpbWluYXRvcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmRpc2NyaW1pbmF0b3I7XHJcbiAgICB9XHJcbiAgICBnZXQgb3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBnZXQgb3B0aW9uc01hcCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnNNYXA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZGlzY3JpbWluYXRlZCB1bmlvbiBzY2hlbWEuIEl0cyBiZWhhdmlvdXIgaXMgdmVyeSBzaW1pbGFyIHRvIHRoYXQgb2YgdGhlIG5vcm1hbCB6LnVuaW9uKCkgY29uc3RydWN0b3IuXHJcbiAgICAgKiBIb3dldmVyLCBpdCBvbmx5IGFsbG93cyBhIHVuaW9uIG9mIG9iamVjdHMsIGFsbCBvZiB3aGljaCBuZWVkIHRvIHNoYXJlIGEgZGlzY3JpbWluYXRvciBwcm9wZXJ0eS4gVGhpcyBwcm9wZXJ0eSBtdXN0XHJcbiAgICAgKiBoYXZlIGEgZGlmZmVyZW50IHZhbHVlIGZvciBlYWNoIG9iamVjdCBpbiB0aGUgdW5pb24uXHJcbiAgICAgKiBAcGFyYW0gZGlzY3JpbWluYXRvciB0aGUgbmFtZSBvZiB0aGUgZGlzY3JpbWluYXRvciBwcm9wZXJ0eVxyXG4gICAgICogQHBhcmFtIHR5cGVzIGFuIGFycmF5IG9mIG9iamVjdCBzY2hlbWFzXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1zXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGUoZGlzY3JpbWluYXRvciwgb3B0aW9ucywgcGFyYW1zKSB7XHJcbiAgICAgICAgLy8gR2V0IGFsbCB0aGUgdmFsaWQgZGlzY3JpbWluYXRvciB2YWx1ZXNcclxuICAgICAgICBjb25zdCBvcHRpb25zTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIC8vIHRyeSB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlcyA9IGdldERpc2NyaW1pbmF0b3IodHlwZS5zaGFwZVtkaXNjcmltaW5hdG9yXSk7XHJcbiAgICAgICAgICAgIGlmICghZGlzY3JpbWluYXRvclZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIGRpc2NyaW1pbmF0b3IgdmFsdWUgZm9yIGtleSBcXGAke2Rpc2NyaW1pbmF0b3J9XFxgIGNvdWxkIG5vdCBiZSBleHRyYWN0ZWQgZnJvbSBhbGwgc2NoZW1hIG9wdGlvbnNgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGRpc2NyaW1pbmF0b3JWYWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zTWFwLmhhcyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpc2NyaW1pbmF0b3IgcHJvcGVydHkgJHtTdHJpbmcoZGlzY3JpbWluYXRvcil9IGhhcyBkdXBsaWNhdGUgdmFsdWUgJHtTdHJpbmcodmFsdWUpfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3B0aW9uc01hcC5zZXQodmFsdWUsIHR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgWm9kRGlzY3JpbWluYXRlZFVuaW9uKHtcclxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REaXNjcmltaW5hdGVkVW5pb24sXHJcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3IsXHJcbiAgICAgICAgICAgIG9wdGlvbnMsXHJcbiAgICAgICAgICAgIG9wdGlvbnNNYXAsXHJcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBtZXJnZVZhbHVlcyhhLCBiKSB7XHJcbiAgICBjb25zdCBhVHlwZSA9IGdldFBhcnNlZFR5cGUoYSk7XHJcbiAgICBjb25zdCBiVHlwZSA9IGdldFBhcnNlZFR5cGUoYik7XHJcbiAgICBpZiAoYSA9PT0gYikge1xyXG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5vYmplY3QgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XHJcbiAgICAgICAgY29uc3QgYktleXMgPSB1dGlsLm9iamVjdEtleXMoYik7XHJcbiAgICAgICAgY29uc3Qgc2hhcmVkS2V5cyA9IHV0aWxcclxuICAgICAgICAgICAgLm9iamVjdEtleXMoYSlcclxuICAgICAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBiS2V5cy5pbmRleE9mKGtleSkgIT09IC0xKTtcclxuICAgICAgICBjb25zdCBuZXdPYmogPSB7IC4uLmEsIC4uLmIgfTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFyZWRLZXlzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoYVtrZXldLCBiW2tleV0pO1xyXG4gICAgICAgICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXdPYmpba2V5XSA9IHNoYXJlZFZhbHVlLmRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdPYmogfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5ICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XHJcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV3QXJyYXkgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYS5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgY29uc3QgaXRlbUEgPSBhW2luZGV4XTtcclxuICAgICAgICAgICAgY29uc3QgaXRlbUIgPSBiW2luZGV4XTtcclxuICAgICAgICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhpdGVtQSwgaXRlbUIpO1xyXG4gICAgICAgICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXdBcnJheS5wdXNoKHNoYXJlZFZhbHVlLmRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3QXJyYXkgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmRhdGUgJiZcclxuICAgICAgICBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5kYXRlICYmXHJcbiAgICAgICAgK2EgPT09ICtiKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFpvZEludGVyc2VjdGlvbiBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcclxuICAgICAgICBjb25zdCBoYW5kbGVQYXJzZWQgPSAocGFyc2VkTGVmdCwgcGFyc2VkUmlnaHQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzQWJvcnRlZChwYXJzZWRMZWZ0KSB8fCBpc0Fib3J0ZWQocGFyc2VkUmlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZVZhbHVlcyhwYXJzZWRMZWZ0LnZhbHVlLCBwYXJzZWRSaWdodC52YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmICghbWVyZ2VkLnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXMsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc0RpcnR5KHBhcnNlZExlZnQpIHx8IGlzRGlydHkocGFyc2VkUmlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IG1lcmdlZC5kYXRhIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmLmxlZnQuX3BhcnNlQXN5bmMoe1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWYucmlnaHQuX3BhcnNlQXN5bmMoe1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIF0pLnRoZW4oKFtsZWZ0LCByaWdodF0pID0+IGhhbmRsZVBhcnNlZChsZWZ0LCByaWdodCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVBhcnNlZCh0aGlzLl9kZWYubGVmdC5fcGFyc2VTeW5jKHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXHJcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcclxuICAgICAgICAgICAgfSksIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VTeW5jKHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXHJcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5ab2RJbnRlcnNlY3Rpb24uY3JlYXRlID0gKGxlZnQsIHJpZ2h0LCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kSW50ZXJzZWN0aW9uKHtcclxuICAgICAgICBsZWZ0OiBsZWZ0LFxyXG4gICAgICAgIHJpZ2h0OiByaWdodCxcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEludGVyc2VjdGlvbixcclxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICB9KTtcclxufTtcclxuY2xhc3MgWm9kVHVwbGUgZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XHJcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPCB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcclxuICAgICAgICAgICAgICAgIG1pbmltdW06IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdCA9IHRoaXMuX2RlZi5yZXN0O1xyXG4gICAgICAgIGlmICghcmVzdCAmJiBjdHguZGF0YS5sZW5ndGggPiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXHJcbiAgICAgICAgICAgICAgICBtYXhpbXVtOiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGl0ZW1zID0gWy4uLmN0eC5kYXRhXVxyXG4gICAgICAgICAgICAubWFwKChpdGVtLCBpdGVtSW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5fZGVmLml0ZW1zW2l0ZW1JbmRleF0gfHwgdGhpcy5fZGVmLnJlc3Q7XHJcbiAgICAgICAgICAgIGlmICghc2NoZW1hKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaXRlbUluZGV4KSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmZpbHRlcigoeCkgPT4gISF4KTsgLy8gZmlsdGVyIG51bGxzXHJcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zKS50aGVuKChyZXN1bHRzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdHMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgaXRlbXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBpdGVtcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLml0ZW1zO1xyXG4gICAgfVxyXG4gICAgcmVzdChyZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RUdXBsZSh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgcmVzdCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5ab2RUdXBsZS5jcmVhdGUgPSAoc2NoZW1hcywgcGFyYW1zKSA9PiB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hcykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGFuIGFycmF5IG9mIHNjaGVtYXMgdG8gei50dXBsZShbIC4uLiBdKVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgWm9kVHVwbGUoe1xyXG4gICAgICAgIGl0ZW1zOiBzY2hlbWFzLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVHVwbGUsXHJcbiAgICAgICAgcmVzdDogbnVsbCxcclxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICB9KTtcclxufTtcclxuY2xhc3MgWm9kUmVjb3JkIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBnZXQga2V5U2NoZW1hKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZVNjaGVtYSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcclxuICAgIH1cclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XHJcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFpcnMgPSBbXTtcclxuICAgICAgICBjb25zdCBrZXlUeXBlID0gdGhpcy5fZGVmLmtleVR5cGU7XHJcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdHguZGF0YSkge1xyXG4gICAgICAgICAgICBwYWlycy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGtleToga2V5VHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGtleSwgY3R4LnBhdGgsIGtleSkpLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGN0eC5kYXRhW2tleV0sIGN0eC5wYXRoLCBrZXkpKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdEFzeW5jKHN0YXR1cywgcGFpcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgZWxlbWVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjcmVhdGUoZmlyc3QsIHNlY29uZCwgdGhpcmQpIHtcclxuICAgICAgICBpZiAoc2Vjb25kIGluc3RhbmNlb2YgWm9kVHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XHJcbiAgICAgICAgICAgICAgICBrZXlUeXBlOiBmaXJzdCxcclxuICAgICAgICAgICAgICAgIHZhbHVlVHlwZTogc2Vjb25kLFxyXG4gICAgICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXHJcbiAgICAgICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXJkKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgWm9kUmVjb3JkKHtcclxuICAgICAgICAgICAga2V5VHlwZTogWm9kU3RyaW5nLmNyZWF0ZSgpLFxyXG4gICAgICAgICAgICB2YWx1ZVR5cGU6IGZpcnN0LFxyXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlY29yZCxcclxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhzZWNvbmQpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFpvZE1hcCBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgZ2V0IGtleVNjaGVtYSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmtleVR5cGU7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWVTY2hlbWEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XHJcbiAgICB9XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xyXG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5tYXApIHtcclxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxyXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubWFwLFxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGtleVR5cGUgPSB0aGlzLl9kZWYua2V5VHlwZTtcclxuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xyXG4gICAgICAgIGNvbnN0IHBhaXJzID0gWy4uLmN0eC5kYXRhLmVudHJpZXMoKV0ubWFwKChba2V5LCB2YWx1ZV0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBrZXk6IGtleVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBrZXksIGN0eC5wYXRoLCBbaW5kZXgsIFwia2V5XCJdKSksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgdmFsdWUsIGN0eC5wYXRoLCBbaW5kZXgsIFwidmFsdWVcIl0pKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xyXG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZmluYWxNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcGFpci5rZXk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhaXIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogZmluYWxNYXAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuWm9kTWFwLmNyZWF0ZSA9IChrZXlUeXBlLCB2YWx1ZVR5cGUsIHBhcmFtcykgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBab2RNYXAoe1xyXG4gICAgICAgIHZhbHVlVHlwZSxcclxuICAgICAgICBrZXlUeXBlLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTWFwLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2RTZXQgZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XHJcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnNldCkge1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXHJcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zZXQsXHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5fZGVmO1xyXG4gICAgICAgIGlmIChkZWYubWluU2l6ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEuc2l6ZSA8IGRlZi5taW5TaXplLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGRlZi5taW5TaXplLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluU2l6ZS5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVmLm1heFNpemUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLnNpemUgPiBkZWYubWF4U2l6ZS52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogZGVmLm1heFNpemUudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIixcclxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhTaXplLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XHJcbiAgICAgICAgZnVuY3Rpb24gZmluYWxpemVTZXQoZWxlbWVudHMpIHtcclxuICAgICAgICAgICAgY29uc3QgcGFyc2VkU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiZGlydHlcIilcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIHBhcnNlZFNldC5hZGQoZWxlbWVudC52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBwYXJzZWRTZXQgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbLi4uY3R4LmRhdGEudmFsdWVzKCldLm1hcCgoaXRlbSwgaSkgPT4gdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKSk7XHJcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGVsZW1lbnRzKS50aGVuKChlbGVtZW50cykgPT4gZmluYWxpemVTZXQoZWxlbWVudHMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaW5hbGl6ZVNldChlbGVtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWluKG1pblNpemUsIG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFpvZFNldCh7XHJcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcclxuICAgICAgICAgICAgbWluU2l6ZTogeyB2YWx1ZTogbWluU2l6ZSwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBtYXgobWF4U2l6ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kU2V0KHtcclxuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxyXG4gICAgICAgICAgICBtYXhTaXplOiB7IHZhbHVlOiBtYXhTaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHNpemUoc2l6ZSwgbWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1pbihzaXplLCBtZXNzYWdlKS5tYXgoc2l6ZSwgbWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICBub25lbXB0eShtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKDEsIG1lc3NhZ2UpO1xyXG4gICAgfVxyXG59XHJcblpvZFNldC5jcmVhdGUgPSAodmFsdWVUeXBlLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kU2V0KHtcclxuICAgICAgICB2YWx1ZVR5cGUsXHJcbiAgICAgICAgbWluU2l6ZTogbnVsbCxcclxuICAgICAgICBtYXhTaXplOiBudWxsLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU2V0LFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2RGdW5jdGlvbiBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnZhbGlkYXRlID0gdGhpcy5pbXBsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcclxuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuZnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxyXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuZnVuY3Rpb24sXHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gbWFrZUFyZ3NJc3N1ZShhcmdzLCBlcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbWFrZUlzc3VlKHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IGFyZ3MsXHJcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcclxuICAgICAgICAgICAgICAgIGVycm9yTWFwczogW1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcclxuICAgICAgICAgICAgICAgICAgICBnZXRFcnJvck1hcCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWFwLFxyXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXHJcbiAgICAgICAgICAgICAgICBpc3N1ZURhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzRXJyb3I6IGVycm9yLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VSZXR1cm5zSXNzdWUocmV0dXJucywgZXJyb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1ha2VJc3N1ZSh7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiByZXR1cm5zLFxyXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXHJcbiAgICAgICAgICAgICAgICBlcnJvck1hcHM6IFtcclxuICAgICAgICAgICAgICAgICAgICBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcclxuICAgICAgICAgICAgICAgICAgICBjdHguc2NoZW1hRXJyb3JNYXAsXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0RXJyb3JNYXAoKSxcclxuICAgICAgICAgICAgICAgICAgICBlcnJvck1hcCxcclxuICAgICAgICAgICAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxyXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfcmV0dXJuX3R5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZUVycm9yOiBlcnJvcixcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7IGVycm9yTWFwOiBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCB9O1xyXG4gICAgICAgIGNvbnN0IGZuID0gY3R4LmRhdGE7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5yZXR1cm5zIGluc3RhbmNlb2YgWm9kUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAvLyBXb3VsZCBsb3ZlIGEgd2F5IHRvIGF2b2lkIGRpc2FibGluZyB0aGlzIHJ1bGUsIGJ1dCB3ZSBuZWVkXHJcbiAgICAgICAgICAgIC8vIGFuIGFsaWFzICh1c2luZyBhbiBhcnJvdyBmdW5jdGlvbiB3YXMgd2hhdCBjYXVzZWQgMjY1MSkuXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xyXG4gICAgICAgICAgICBjb25zdCBtZSA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBPSyhhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoW10pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IGF3YWl0IG1lLl9kZWYuYXJnc1xyXG4gICAgICAgICAgICAgICAgICAgIC5wYXJzZUFzeW5jKGFyZ3MsIHBhcmFtcylcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRJc3N1ZShtYWtlQXJnc0lzc3VlKGFyZ3MsIGUpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUmVmbGVjdC5hcHBseShmbiwgdGhpcywgcGFyc2VkQXJncyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gYXdhaXQgbWUuX2RlZi5yZXR1cm5zLl9kZWYudHlwZVxyXG4gICAgICAgICAgICAgICAgICAgIC5wYXJzZUFzeW5jKHJlc3VsdCwgcGFyYW1zKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRSZXR1cm5zO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFdvdWxkIGxvdmUgYSB3YXkgdG8gYXZvaWQgZGlzYWJsaW5nIHRoaXMgcnVsZSwgYnV0IHdlIG5lZWRcclxuICAgICAgICAgICAgLy8gYW4gYWxpYXMgKHVzaW5nIGFuIGFycm93IGZ1bmN0aW9uIHdhcyB3aGF0IGNhdXNlZCAyNjUxKS5cclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXHJcbiAgICAgICAgICAgIGNvbnN0IG1lID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIE9LKGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gbWUuX2RlZi5hcmdzLnNhZmVQYXJzZShhcmdzLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZWRBcmdzLnN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VBcmdzSXNzdWUoYXJncywgcGFyc2VkQXJncy5lcnJvcildKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuYXBwbHkoZm4sIHRoaXMsIHBhcnNlZEFyZ3MuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gbWUuX2RlZi5yZXR1cm5zLnNhZmVQYXJzZShyZXN1bHQsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZFJldHVybnMuc3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBab2RFcnJvcihbbWFrZVJldHVybnNJc3N1ZShyZXN1bHQsIHBhcnNlZFJldHVybnMuZXJyb3IpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucy5kYXRhO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwYXJhbWV0ZXJzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuYXJncztcclxuICAgIH1cclxuICAgIHJldHVyblR5cGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5yZXR1cm5zO1xyXG4gICAgfVxyXG4gICAgYXJncyguLi5pdGVtcykge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIGFyZ3M6IFpvZFR1cGxlLmNyZWF0ZShpdGVtcykucmVzdChab2RVbmtub3duLmNyZWF0ZSgpKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybnMocmV0dXJuVHlwZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xyXG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXHJcbiAgICAgICAgICAgIHJldHVybnM6IHJldHVyblR5cGUsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpbXBsZW1lbnQoZnVuYykge1xyXG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZEZ1bmMgPSB0aGlzLnBhcnNlKGZ1bmMpO1xyXG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xyXG4gICAgfVxyXG4gICAgc3RyaWN0SW1wbGVtZW50KGZ1bmMpIHtcclxuICAgICAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcclxuICAgICAgICByZXR1cm4gdmFsaWRhdGVkRnVuYztcclxuICAgIH1cclxuICAgIHN0YXRpYyBjcmVhdGUoYXJncywgcmV0dXJucywgcGFyYW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XHJcbiAgICAgICAgICAgIGFyZ3M6IChhcmdzXHJcbiAgICAgICAgICAgICAgICA/IGFyZ3NcclxuICAgICAgICAgICAgICAgIDogWm9kVHVwbGUuY3JlYXRlKFtdKS5yZXN0KFpvZFVua25vd24uY3JlYXRlKCkpKSxcclxuICAgICAgICAgICAgcmV0dXJuczogcmV0dXJucyB8fCBab2RVbmtub3duLmNyZWF0ZSgpLFxyXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEZ1bmN0aW9uLFxyXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgWm9kTGF6eSBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgZ2V0IHNjaGVtYSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmdldHRlcigpO1xyXG4gICAgfVxyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XHJcbiAgICAgICAgY29uc3QgbGF6eVNjaGVtYSA9IHRoaXMuX2RlZi5nZXR0ZXIoKTtcclxuICAgICAgICByZXR1cm4gbGF6eVNjaGVtYS5fcGFyc2UoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xyXG4gICAgfVxyXG59XHJcblpvZExhenkuY3JlYXRlID0gKGdldHRlciwgcGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZExhenkoe1xyXG4gICAgICAgIGdldHRlcjogZ2V0dGVyLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTGF6eSxcclxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICB9KTtcclxufTtcclxuY2xhc3MgWm9kTGl0ZXJhbCBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgaWYgKGlucHV0LmRhdGEgIT09IHRoaXMuX2RlZi52YWx1ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfbGl0ZXJhbCxcclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB0aGlzLl9kZWYudmFsdWUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZTtcclxuICAgIH1cclxufVxyXG5ab2RMaXRlcmFsLmNyZWF0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZExpdGVyYWwoe1xyXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExpdGVyYWwsXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZVpvZEVudW0odmFsdWVzLCBwYXJhbXMpIHtcclxuICAgIHJldHVybiBuZXcgWm9kRW51bSh7XHJcbiAgICAgICAgdmFsdWVzLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRW51bSxcclxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICB9KTtcclxufVxyXG5jbGFzcyBab2RFbnVtIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGlucHV0LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xyXG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHRoaXMuX2RlZi52YWx1ZXM7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWwuam9pblZhbHVlcyhleHBlY3RlZFZhbHVlcyksXHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9kZWYudmFsdWVzLmluZGV4T2YoaW5wdXQuZGF0YSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcclxuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB0aGlzLl9kZWYudmFsdWVzO1xyXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcclxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBleHBlY3RlZFZhbHVlcyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XHJcbiAgICB9XHJcbiAgICBnZXQgb3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcclxuICAgIH1cclxuICAgIGdldCBlbnVtKCkge1xyXG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XHJcbiAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XHJcbiAgICB9XHJcbiAgICBnZXQgVmFsdWVzKCkge1xyXG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XHJcbiAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XHJcbiAgICB9XHJcbiAgICBnZXQgRW51bSgpIHtcclxuICAgICAgICBjb25zdCBlbnVtVmFsdWVzID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xyXG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xyXG4gICAgfVxyXG4gICAgZXh0cmFjdCh2YWx1ZXMpIHtcclxuICAgICAgICByZXR1cm4gWm9kRW51bS5jcmVhdGUodmFsdWVzKTtcclxuICAgIH1cclxuICAgIGV4Y2x1ZGUodmFsdWVzKSB7XHJcbiAgICAgICAgcmV0dXJuIFpvZEVudW0uY3JlYXRlKHRoaXMub3B0aW9ucy5maWx0ZXIoKG9wdCkgPT4gIXZhbHVlcy5pbmNsdWRlcyhvcHQpKSk7XHJcbiAgICB9XHJcbn1cclxuWm9kRW51bS5jcmVhdGUgPSBjcmVhdGVab2RFbnVtO1xyXG5jbGFzcyBab2ROYXRpdmVFbnVtIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCBuYXRpdmVFbnVtVmFsdWVzID0gdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcyk7XHJcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xyXG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcgJiZcclxuICAgICAgICAgICAgY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWwuam9pblZhbHVlcyhleHBlY3RlZFZhbHVlcyksXHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXHJcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuYXRpdmVFbnVtVmFsdWVzLmluZGV4T2YoaW5wdXQuZGF0YSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZSxcclxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcclxuICAgIH1cclxuICAgIGdldCBlbnVtKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xyXG4gICAgfVxyXG59XHJcblpvZE5hdGl2ZUVudW0uY3JlYXRlID0gKHZhbHVlcywgcGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZE5hdGl2ZUVudW0oe1xyXG4gICAgICAgIHZhbHVlczogdmFsdWVzLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmF0aXZlRW51bSxcclxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICB9KTtcclxufTtcclxuY2xhc3MgWm9kUHJvbWlzZSBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgdW53cmFwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcclxuICAgIH1cclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xyXG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlICYmXHJcbiAgICAgICAgICAgIGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnByb21pc2UsXHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcHJvbWlzaWZpZWQgPSBjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlXHJcbiAgICAgICAgICAgID8gY3R4LmRhdGFcclxuICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoY3R4LmRhdGEpO1xyXG4gICAgICAgIHJldHVybiBPSyhwcm9taXNpZmllZC50aGVuKChkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5wYXJzZUFzeW5jKGRhdGEsIHtcclxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbn1cclxuWm9kUHJvbWlzZS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kUHJvbWlzZSh7XHJcbiAgICAgICAgdHlwZTogc2NoZW1hLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUHJvbWlzZSxcclxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICB9KTtcclxufTtcclxuY2xhc3MgWm9kRWZmZWN0cyBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgaW5uZXJUeXBlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hO1xyXG4gICAgfVxyXG4gICAgc291cmNlVHlwZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fZGVmLnR5cGVOYW1lID09PSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0c1xyXG4gICAgICAgICAgICA/IHRoaXMuX2RlZi5zY2hlbWEuc291cmNlVHlwZSgpXHJcbiAgICAgICAgICAgIDogdGhpcy5fZGVmLnNjaGVtYTtcclxuICAgIH1cclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XHJcbiAgICAgICAgY29uc3QgZWZmZWN0ID0gdGhpcy5fZGVmLmVmZmVjdCB8fCBudWxsO1xyXG4gICAgICAgIGNvbnN0IGNoZWNrQ3R4ID0ge1xyXG4gICAgICAgICAgICBhZGRJc3N1ZTogKGFyZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBhcmcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZy5mYXRhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5hYm9ydCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldCBwYXRoKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5wYXRoO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY2hlY2tDdHguYWRkSXNzdWUgPSBjaGVja0N0eC5hZGRJc3N1ZS5iaW5kKGNoZWNrQ3R4KTtcclxuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicHJlcHJvY2Vzc1wiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IGVmZmVjdC50cmFuc2Zvcm0oY3R4LmRhdGEsIGNoZWNrQ3R4KTtcclxuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwiZGlydHlcIixcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY3R4LmRhdGEsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByb2Nlc3NlZCkudGhlbigocHJvY2Vzc2VkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlQXN5bmMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogcHJvY2Vzc2VkLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInJlZmluZW1lbnRcIikge1xyXG4gICAgICAgICAgICBjb25zdCBleGVjdXRlUmVmaW5lbWVudCA9IChhY2NcclxuICAgICAgICAgICAgLy8gZWZmZWN0OiBSZWZpbmVtZW50RWZmZWN0PGFueT5cclxuICAgICAgICAgICAgKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QucmVmaW5lbWVudChhY2MsIGNoZWNrQ3R4KTtcclxuICAgICAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyByZWZpbmVtZW50IGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5uZXIgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiZGlydHlcIilcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgIC8vIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkXHJcbiAgICAgICAgICAgICAgICBleGVjdXRlUmVmaW5lbWVudChpbm5lci52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYVxyXG4gICAgICAgICAgICAgICAgICAgIC5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbigoaW5uZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhlY3V0ZVJlZmluZW1lbnQoaW5uZXIudmFsdWUpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwidHJhbnNmb3JtXCIpIHtcclxuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKGJhc2UpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXN5bmNocm9ub3VzIHRyYW5zZm9ybSBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcmVzdWx0IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYVxyXG4gICAgICAgICAgICAgICAgICAgIC5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbigoYmFzZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZChiYXNlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShlZmZlY3QudHJhbnNmb3JtKGJhc2UudmFsdWUsIGNoZWNrQ3R4KSkudGhlbigocmVzdWx0KSA9PiAoeyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IHJlc3VsdCB9KSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGVmZmVjdCk7XHJcbiAgICB9XHJcbn1cclxuWm9kRWZmZWN0cy5jcmVhdGUgPSAoc2NoZW1hLCBlZmZlY3QsIHBhcmFtcykgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcclxuICAgICAgICBzY2hlbWEsXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxyXG4gICAgICAgIGVmZmVjdCxcclxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICB9KTtcclxufTtcclxuWm9kRWZmZWN0cy5jcmVhdGVXaXRoUHJlcHJvY2VzcyA9IChwcmVwcm9jZXNzLCBzY2hlbWEsIHBhcmFtcykgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcclxuICAgICAgICBzY2hlbWEsXHJcbiAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicHJlcHJvY2Vzc1wiLCB0cmFuc2Zvcm06IHByZXByb2Nlc3MgfSxcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmNsYXNzIFpvZE9wdGlvbmFsIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XHJcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPSyh1bmRlZmluZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xyXG4gICAgfVxyXG4gICAgdW53cmFwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xyXG4gICAgfVxyXG59XHJcblpvZE9wdGlvbmFsLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kT3B0aW9uYWwoe1xyXG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9wdGlvbmFsLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2ROdWxsYWJsZSBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xyXG4gICAgICAgIGlmIChwYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLm51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9LKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xyXG4gICAgfVxyXG4gICAgdW53cmFwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xyXG4gICAgfVxyXG59XHJcblpvZE51bGxhYmxlLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kTnVsbGFibGUoe1xyXG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcclxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bGxhYmxlLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jbGFzcyBab2REZWZhdWx0IGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcclxuICAgICAgICBsZXQgZGF0YSA9IGN0eC5kYXRhO1xyXG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2RlZi5kZWZhdWx0VmFsdWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcclxuICAgICAgICAgICAgZGF0YSxcclxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXHJcbiAgICAgICAgICAgIHBhcmVudDogY3R4LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlRGVmYXVsdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcclxuICAgIH1cclxufVxyXG5ab2REZWZhdWx0LmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XHJcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGVmYXVsdCxcclxuICAgICAgICBkZWZhdWx0VmFsdWU6IHR5cGVvZiBwYXJhbXMuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgICAgICAgID8gcGFyYW1zLmRlZmF1bHRcclxuICAgICAgICAgICAgOiAoKSA9PiBwYXJhbXMuZGVmYXVsdCxcclxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXHJcbiAgICB9KTtcclxufTtcclxuY2xhc3MgWm9kQ2F0Y2ggZXh0ZW5kcyBab2RUeXBlIHtcclxuICAgIF9wYXJzZShpbnB1dCkge1xyXG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xyXG4gICAgICAgIC8vIG5ld0N0eCBpcyB1c2VkIHRvIG5vdCBjb2xsZWN0IGlzc3VlcyBmcm9tIGlubmVyIHR5cGVzIGluIGN0eFxyXG4gICAgICAgIGNvbnN0IG5ld0N0eCA9IHtcclxuICAgICAgICAgICAgLi4uY3R4LFxyXG4gICAgICAgICAgICBjb21tb246IHtcclxuICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXHJcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2Uoe1xyXG4gICAgICAgICAgICBkYXRhOiBuZXdDdHguZGF0YSxcclxuICAgICAgICAgICAgcGF0aDogbmV3Q3R4LnBhdGgsXHJcbiAgICAgICAgICAgIHBhcmVudDoge1xyXG4gICAgICAgICAgICAgICAgLi4ubmV3Q3R4LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpc0FzeW5jKHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlc3VsdC52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2RlZi5jYXRjaFZhbHVlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBlcnJvcigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFpvZEVycm9yKG5ld0N0eC5jb21tb24uaXNzdWVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2RlZi5jYXRjaFZhbHVlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBuZXdDdHguZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmVDYXRjaCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcclxuICAgIH1cclxufVxyXG5ab2RDYXRjaC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XHJcbiAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcclxuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXHJcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RDYXRjaCxcclxuICAgICAgICBjYXRjaFZhbHVlOiB0eXBlb2YgcGFyYW1zLmNhdGNoID09PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMuY2F0Y2ggOiAoKSA9PiBwYXJhbXMuY2F0Y2gsXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmNsYXNzIFpvZE5hTiBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xyXG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm5hbikge1xyXG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XHJcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xyXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5hbixcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGlucHV0LmRhdGEgfTtcclxuICAgIH1cclxufVxyXG5ab2ROYU4uY3JlYXRlID0gKHBhcmFtcykgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBab2ROYU4oe1xyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmFOLFxyXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcclxuICAgIH0pO1xyXG59O1xyXG5jb25zdCBCUkFORCA9IFN5bWJvbChcInpvZF9icmFuZFwiKTtcclxuY2xhc3MgWm9kQnJhbmRlZCBleHRlbmRzIFpvZFR5cGUge1xyXG4gICAgX3BhcnNlKGlucHV0KSB7XHJcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGN0eC5kYXRhO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5fcGFyc2Uoe1xyXG4gICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcclxuICAgICAgICAgICAgcGFyZW50OiBjdHgsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1bndyYXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFpvZFBpcGVsaW5lIGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xyXG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUFzeW5jID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5SZXN1bHQgPSBhd2FpdCB0aGlzLl9kZWYuaW4uX3BhcnNlQXN5bmMoe1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcclxuICAgICAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShpblJlc3VsdC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm91dC5fcGFyc2VBc3luYyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGluUmVzdWx0LnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVBc3luYygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaW5SZXN1bHQgPSB0aGlzLl9kZWYuaW4uX3BhcnNlU3luYyh7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcclxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxyXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xyXG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcclxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwiZGlydHlcIixcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5SZXN1bHQudmFsdWUsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vdXQuX3BhcnNlU3luYyh7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBjcmVhdGUoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBuZXcgWm9kUGlwZWxpbmUoe1xyXG4gICAgICAgICAgICBpbjogYSxcclxuICAgICAgICAgICAgb3V0OiBiLFxyXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFBpcGVsaW5lLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFpvZFJlYWRvbmx5IGV4dGVuZHMgWm9kVHlwZSB7XHJcbiAgICBfcGFyc2UoaW5wdXQpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShpbnB1dCk7XHJcbiAgICAgICAgaWYgKGlzVmFsaWQocmVzdWx0KSkge1xyXG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSBPYmplY3QuZnJlZXplKHJlc3VsdC52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuWm9kUmVhZG9ubHkuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xyXG4gICAgcmV0dXJuIG5ldyBab2RSZWFkb25seSh7XHJcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxyXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVhZG9ubHksXHJcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxyXG4gICAgfSk7XHJcbn07XHJcbmNvbnN0IGN1c3RvbSA9IChjaGVjaywgcGFyYW1zID0ge30sIFxyXG4vKipcclxuICogQGRlcHJlY2F0ZWRcclxuICpcclxuICogUGFzcyBgZmF0YWxgIGludG8gdGhlIHBhcmFtcyBvYmplY3QgaW5zdGVhZDpcclxuICpcclxuICogYGBgdHNcclxuICogei5zdHJpbmcoKS5jdXN0b20oKHZhbCkgPT4gdmFsLmxlbmd0aCA+IDUsIHsgZmF0YWw6IGZhbHNlIH0pXHJcbiAqIGBgYFxyXG4gKlxyXG4gKi9cclxuZmF0YWwpID0+IHtcclxuICAgIGlmIChjaGVjaylcclxuICAgICAgICByZXR1cm4gWm9kQW55LmNyZWF0ZSgpLnN1cGVyUmVmaW5lKChkYXRhLCBjdHgpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAgICAgaWYgKCFjaGVjayhkYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIlxyXG4gICAgICAgICAgICAgICAgICAgID8gcGFyYW1zKGRhdGEpXHJcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgcGFyYW1zID09PSBcInN0cmluZ1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyBtZXNzYWdlOiBwYXJhbXMgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBhcmFtcztcclxuICAgICAgICAgICAgICAgIGNvbnN0IF9mYXRhbCA9IChfYiA9IChfYSA9IHAuZmF0YWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhdGFsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcDIgPSB0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogcCB9IDogcDtcclxuICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7IGNvZGU6IFwiY3VzdG9tXCIsIC4uLnAyLCBmYXRhbDogX2ZhdGFsIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICByZXR1cm4gWm9kQW55LmNyZWF0ZSgpO1xyXG59O1xyXG5jb25zdCBsYXRlID0ge1xyXG4gICAgb2JqZWN0OiBab2RPYmplY3QubGF6eWNyZWF0ZSxcclxufTtcclxudmFyIFpvZEZpcnN0UGFydHlUeXBlS2luZDtcclxuKGZ1bmN0aW9uIChab2RGaXJzdFBhcnR5VHlwZUtpbmQpIHtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFN0cmluZ1wiXSA9IFwiWm9kU3RyaW5nXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdW1iZXJcIl0gPSBcIlpvZE51bWJlclwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmFOXCJdID0gXCJab2ROYU5cIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJpZ0ludFwiXSA9IFwiWm9kQmlnSW50XCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCb29sZWFuXCJdID0gXCJab2RCb29sZWFuXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REYXRlXCJdID0gXCJab2REYXRlXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTeW1ib2xcIl0gPSBcIlpvZFN5bWJvbFwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5kZWZpbmVkXCJdID0gXCJab2RVbmRlZmluZWRcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bGxcIl0gPSBcIlpvZE51bGxcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEFueVwiXSA9IFwiWm9kQW55XCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmtub3duXCJdID0gXCJab2RVbmtub3duXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROZXZlclwiXSA9IFwiWm9kTmV2ZXJcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFZvaWRcIl0gPSBcIlpvZFZvaWRcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEFycmF5XCJdID0gXCJab2RBcnJheVwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kT2JqZWN0XCJdID0gXCJab2RPYmplY3RcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFVuaW9uXCJdID0gXCJab2RVbmlvblwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGlzY3JpbWluYXRlZFVuaW9uXCJdID0gXCJab2REaXNjcmltaW5hdGVkVW5pb25cIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEludGVyc2VjdGlvblwiXSA9IFwiWm9kSW50ZXJzZWN0aW9uXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RUdXBsZVwiXSA9IFwiWm9kVHVwbGVcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFJlY29yZFwiXSA9IFwiWm9kUmVjb3JkXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RNYXBcIl0gPSBcIlpvZE1hcFwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU2V0XCJdID0gXCJab2RTZXRcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEZ1bmN0aW9uXCJdID0gXCJab2RGdW5jdGlvblwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTGF6eVwiXSA9IFwiWm9kTGF6eVwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTGl0ZXJhbFwiXSA9IFwiWm9kTGl0ZXJhbFwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRW51bVwiXSA9IFwiWm9kRW51bVwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRWZmZWN0c1wiXSA9IFwiWm9kRWZmZWN0c1wiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmF0aXZlRW51bVwiXSA9IFwiWm9kTmF0aXZlRW51bVwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kT3B0aW9uYWxcIl0gPSBcIlpvZE9wdGlvbmFsXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdWxsYWJsZVwiXSA9IFwiWm9kTnVsbGFibGVcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZERlZmF1bHRcIl0gPSBcIlpvZERlZmF1bHRcIjtcclxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZENhdGNoXCJdID0gXCJab2RDYXRjaFwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUHJvbWlzZVwiXSA9IFwiWm9kUHJvbWlzZVwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQnJhbmRlZFwiXSA9IFwiWm9kQnJhbmRlZFwiO1xyXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUGlwZWxpbmVcIl0gPSBcIlpvZFBpcGVsaW5lXCI7XHJcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RSZWFkb25seVwiXSA9IFwiWm9kUmVhZG9ubHlcIjtcclxufSkoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIHx8IChab2RGaXJzdFBhcnR5VHlwZUtpbmQgPSB7fSkpO1xyXG5jb25zdCBpbnN0YW5jZU9mVHlwZSA9IChcclxuLy8gY29uc3QgaW5zdGFuY2VPZlR5cGUgPSA8VCBleHRlbmRzIG5ldyAoLi4uYXJnczogYW55W10pID0+IGFueT4oXHJcbmNscywgcGFyYW1zID0ge1xyXG4gICAgbWVzc2FnZTogYElucHV0IG5vdCBpbnN0YW5jZSBvZiAke2Nscy5uYW1lfWAsXHJcbn0pID0+IGN1c3RvbSgoZGF0YSkgPT4gZGF0YSBpbnN0YW5jZW9mIGNscywgcGFyYW1zKTtcclxuY29uc3Qgc3RyaW5nVHlwZSA9IFpvZFN0cmluZy5jcmVhdGU7XHJcbmNvbnN0IG51bWJlclR5cGUgPSBab2ROdW1iZXIuY3JlYXRlO1xyXG5jb25zdCBuYW5UeXBlID0gWm9kTmFOLmNyZWF0ZTtcclxuY29uc3QgYmlnSW50VHlwZSA9IFpvZEJpZ0ludC5jcmVhdGU7XHJcbmNvbnN0IGJvb2xlYW5UeXBlID0gWm9kQm9vbGVhbi5jcmVhdGU7XHJcbmNvbnN0IGRhdGVUeXBlID0gWm9kRGF0ZS5jcmVhdGU7XHJcbmNvbnN0IHN5bWJvbFR5cGUgPSBab2RTeW1ib2wuY3JlYXRlO1xyXG5jb25zdCB1bmRlZmluZWRUeXBlID0gWm9kVW5kZWZpbmVkLmNyZWF0ZTtcclxuY29uc3QgbnVsbFR5cGUgPSBab2ROdWxsLmNyZWF0ZTtcclxuY29uc3QgYW55VHlwZSA9IFpvZEFueS5jcmVhdGU7XHJcbmNvbnN0IHVua25vd25UeXBlID0gWm9kVW5rbm93bi5jcmVhdGU7XHJcbmNvbnN0IG5ldmVyVHlwZSA9IFpvZE5ldmVyLmNyZWF0ZTtcclxuY29uc3Qgdm9pZFR5cGUgPSBab2RWb2lkLmNyZWF0ZTtcclxuY29uc3QgYXJyYXlUeXBlID0gWm9kQXJyYXkuY3JlYXRlO1xyXG5jb25zdCBvYmplY3RUeXBlID0gWm9kT2JqZWN0LmNyZWF0ZTtcclxuY29uc3Qgc3RyaWN0T2JqZWN0VHlwZSA9IFpvZE9iamVjdC5zdHJpY3RDcmVhdGU7XHJcbmNvbnN0IHVuaW9uVHlwZSA9IFpvZFVuaW9uLmNyZWF0ZTtcclxuY29uc3QgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSA9IFpvZERpc2NyaW1pbmF0ZWRVbmlvbi5jcmVhdGU7XHJcbmNvbnN0IGludGVyc2VjdGlvblR5cGUgPSBab2RJbnRlcnNlY3Rpb24uY3JlYXRlO1xyXG5jb25zdCB0dXBsZVR5cGUgPSBab2RUdXBsZS5jcmVhdGU7XHJcbmNvbnN0IHJlY29yZFR5cGUgPSBab2RSZWNvcmQuY3JlYXRlO1xyXG5jb25zdCBtYXBUeXBlID0gWm9kTWFwLmNyZWF0ZTtcclxuY29uc3Qgc2V0VHlwZSA9IFpvZFNldC5jcmVhdGU7XHJcbmNvbnN0IGZ1bmN0aW9uVHlwZSA9IFpvZEZ1bmN0aW9uLmNyZWF0ZTtcclxuY29uc3QgbGF6eVR5cGUgPSBab2RMYXp5LmNyZWF0ZTtcclxuY29uc3QgbGl0ZXJhbFR5cGUgPSBab2RMaXRlcmFsLmNyZWF0ZTtcclxuY29uc3QgZW51bVR5cGUgPSBab2RFbnVtLmNyZWF0ZTtcclxuY29uc3QgbmF0aXZlRW51bVR5cGUgPSBab2ROYXRpdmVFbnVtLmNyZWF0ZTtcclxuY29uc3QgcHJvbWlzZVR5cGUgPSBab2RQcm9taXNlLmNyZWF0ZTtcclxuY29uc3QgZWZmZWN0c1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZTtcclxuY29uc3Qgb3B0aW9uYWxUeXBlID0gWm9kT3B0aW9uYWwuY3JlYXRlO1xyXG5jb25zdCBudWxsYWJsZVR5cGUgPSBab2ROdWxsYWJsZS5jcmVhdGU7XHJcbmNvbnN0IHByZXByb2Nlc3NUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGVXaXRoUHJlcHJvY2VzcztcclxuY29uc3QgcGlwZWxpbmVUeXBlID0gWm9kUGlwZWxpbmUuY3JlYXRlO1xyXG5jb25zdCBvc3RyaW5nID0gKCkgPT4gc3RyaW5nVHlwZSgpLm9wdGlvbmFsKCk7XHJcbmNvbnN0IG9udW1iZXIgPSAoKSA9PiBudW1iZXJUeXBlKCkub3B0aW9uYWwoKTtcclxuY29uc3Qgb2Jvb2xlYW4gPSAoKSA9PiBib29sZWFuVHlwZSgpLm9wdGlvbmFsKCk7XHJcbmNvbnN0IGNvZXJjZSA9IHtcclxuICAgIHN0cmluZzogKChhcmcpID0+IFpvZFN0cmluZy5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXHJcbiAgICBudW1iZXI6ICgoYXJnKSA9PiBab2ROdW1iZXIuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxyXG4gICAgYm9vbGVhbjogKChhcmcpID0+IFpvZEJvb2xlYW4uY3JlYXRlKHtcclxuICAgICAgICAuLi5hcmcsXHJcbiAgICAgICAgY29lcmNlOiB0cnVlLFxyXG4gICAgfSkpLFxyXG4gICAgYmlnaW50OiAoKGFyZykgPT4gWm9kQmlnSW50LmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcclxuICAgIGRhdGU6ICgoYXJnKSA9PiBab2REYXRlLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcclxufTtcclxuY29uc3QgTkVWRVIgPSBJTlZBTElEO1xyXG5cclxudmFyIHogPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICBfX3Byb3RvX186IG51bGwsXHJcbiAgICBkZWZhdWx0RXJyb3JNYXA6IGVycm9yTWFwLFxyXG4gICAgc2V0RXJyb3JNYXA6IHNldEVycm9yTWFwLFxyXG4gICAgZ2V0RXJyb3JNYXA6IGdldEVycm9yTWFwLFxyXG4gICAgbWFrZUlzc3VlOiBtYWtlSXNzdWUsXHJcbiAgICBFTVBUWV9QQVRIOiBFTVBUWV9QQVRILFxyXG4gICAgYWRkSXNzdWVUb0NvbnRleHQ6IGFkZElzc3VlVG9Db250ZXh0LFxyXG4gICAgUGFyc2VTdGF0dXM6IFBhcnNlU3RhdHVzLFxyXG4gICAgSU5WQUxJRDogSU5WQUxJRCxcclxuICAgIERJUlRZOiBESVJUWSxcclxuICAgIE9LOiBPSyxcclxuICAgIGlzQWJvcnRlZDogaXNBYm9ydGVkLFxyXG4gICAgaXNEaXJ0eTogaXNEaXJ0eSxcclxuICAgIGlzVmFsaWQ6IGlzVmFsaWQsXHJcbiAgICBpc0FzeW5jOiBpc0FzeW5jLFxyXG4gICAgZ2V0IHV0aWwgKCkgeyByZXR1cm4gdXRpbDsgfSxcclxuICAgIGdldCBvYmplY3RVdGlsICgpIHsgcmV0dXJuIG9iamVjdFV0aWw7IH0sXHJcbiAgICBab2RQYXJzZWRUeXBlOiBab2RQYXJzZWRUeXBlLFxyXG4gICAgZ2V0UGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZSxcclxuICAgIFpvZFR5cGU6IFpvZFR5cGUsXHJcbiAgICBab2RTdHJpbmc6IFpvZFN0cmluZyxcclxuICAgIFpvZE51bWJlcjogWm9kTnVtYmVyLFxyXG4gICAgWm9kQmlnSW50OiBab2RCaWdJbnQsXHJcbiAgICBab2RCb29sZWFuOiBab2RCb29sZWFuLFxyXG4gICAgWm9kRGF0ZTogWm9kRGF0ZSxcclxuICAgIFpvZFN5bWJvbDogWm9kU3ltYm9sLFxyXG4gICAgWm9kVW5kZWZpbmVkOiBab2RVbmRlZmluZWQsXHJcbiAgICBab2ROdWxsOiBab2ROdWxsLFxyXG4gICAgWm9kQW55OiBab2RBbnksXHJcbiAgICBab2RVbmtub3duOiBab2RVbmtub3duLFxyXG4gICAgWm9kTmV2ZXI6IFpvZE5ldmVyLFxyXG4gICAgWm9kVm9pZDogWm9kVm9pZCxcclxuICAgIFpvZEFycmF5OiBab2RBcnJheSxcclxuICAgIFpvZE9iamVjdDogWm9kT2JqZWN0LFxyXG4gICAgWm9kVW5pb246IFpvZFVuaW9uLFxyXG4gICAgWm9kRGlzY3JpbWluYXRlZFVuaW9uOiBab2REaXNjcmltaW5hdGVkVW5pb24sXHJcbiAgICBab2RJbnRlcnNlY3Rpb246IFpvZEludGVyc2VjdGlvbixcclxuICAgIFpvZFR1cGxlOiBab2RUdXBsZSxcclxuICAgIFpvZFJlY29yZDogWm9kUmVjb3JkLFxyXG4gICAgWm9kTWFwOiBab2RNYXAsXHJcbiAgICBab2RTZXQ6IFpvZFNldCxcclxuICAgIFpvZEZ1bmN0aW9uOiBab2RGdW5jdGlvbixcclxuICAgIFpvZExhenk6IFpvZExhenksXHJcbiAgICBab2RMaXRlcmFsOiBab2RMaXRlcmFsLFxyXG4gICAgWm9kRW51bTogWm9kRW51bSxcclxuICAgIFpvZE5hdGl2ZUVudW06IFpvZE5hdGl2ZUVudW0sXHJcbiAgICBab2RQcm9taXNlOiBab2RQcm9taXNlLFxyXG4gICAgWm9kRWZmZWN0czogWm9kRWZmZWN0cyxcclxuICAgIFpvZFRyYW5zZm9ybWVyOiBab2RFZmZlY3RzLFxyXG4gICAgWm9kT3B0aW9uYWw6IFpvZE9wdGlvbmFsLFxyXG4gICAgWm9kTnVsbGFibGU6IFpvZE51bGxhYmxlLFxyXG4gICAgWm9kRGVmYXVsdDogWm9kRGVmYXVsdCxcclxuICAgIFpvZENhdGNoOiBab2RDYXRjaCxcclxuICAgIFpvZE5hTjogWm9kTmFOLFxyXG4gICAgQlJBTkQ6IEJSQU5ELFxyXG4gICAgWm9kQnJhbmRlZDogWm9kQnJhbmRlZCxcclxuICAgIFpvZFBpcGVsaW5lOiBab2RQaXBlbGluZSxcclxuICAgIFpvZFJlYWRvbmx5OiBab2RSZWFkb25seSxcclxuICAgIGN1c3RvbTogY3VzdG9tLFxyXG4gICAgU2NoZW1hOiBab2RUeXBlLFxyXG4gICAgWm9kU2NoZW1hOiBab2RUeXBlLFxyXG4gICAgbGF0ZTogbGF0ZSxcclxuICAgIGdldCBab2RGaXJzdFBhcnR5VHlwZUtpbmQgKCkgeyByZXR1cm4gWm9kRmlyc3RQYXJ0eVR5cGVLaW5kOyB9LFxyXG4gICAgY29lcmNlOiBjb2VyY2UsXHJcbiAgICBhbnk6IGFueVR5cGUsXHJcbiAgICBhcnJheTogYXJyYXlUeXBlLFxyXG4gICAgYmlnaW50OiBiaWdJbnRUeXBlLFxyXG4gICAgYm9vbGVhbjogYm9vbGVhblR5cGUsXHJcbiAgICBkYXRlOiBkYXRlVHlwZSxcclxuICAgIGRpc2NyaW1pbmF0ZWRVbmlvbjogZGlzY3JpbWluYXRlZFVuaW9uVHlwZSxcclxuICAgIGVmZmVjdDogZWZmZWN0c1R5cGUsXHJcbiAgICAnZW51bSc6IGVudW1UeXBlLFxyXG4gICAgJ2Z1bmN0aW9uJzogZnVuY3Rpb25UeXBlLFxyXG4gICAgJ2luc3RhbmNlb2YnOiBpbnN0YW5jZU9mVHlwZSxcclxuICAgIGludGVyc2VjdGlvbjogaW50ZXJzZWN0aW9uVHlwZSxcclxuICAgIGxhenk6IGxhenlUeXBlLFxyXG4gICAgbGl0ZXJhbDogbGl0ZXJhbFR5cGUsXHJcbiAgICBtYXA6IG1hcFR5cGUsXHJcbiAgICBuYW46IG5hblR5cGUsXHJcbiAgICBuYXRpdmVFbnVtOiBuYXRpdmVFbnVtVHlwZSxcclxuICAgIG5ldmVyOiBuZXZlclR5cGUsXHJcbiAgICAnbnVsbCc6IG51bGxUeXBlLFxyXG4gICAgbnVsbGFibGU6IG51bGxhYmxlVHlwZSxcclxuICAgIG51bWJlcjogbnVtYmVyVHlwZSxcclxuICAgIG9iamVjdDogb2JqZWN0VHlwZSxcclxuICAgIG9ib29sZWFuOiBvYm9vbGVhbixcclxuICAgIG9udW1iZXI6IG9udW1iZXIsXHJcbiAgICBvcHRpb25hbDogb3B0aW9uYWxUeXBlLFxyXG4gICAgb3N0cmluZzogb3N0cmluZyxcclxuICAgIHBpcGVsaW5lOiBwaXBlbGluZVR5cGUsXHJcbiAgICBwcmVwcm9jZXNzOiBwcmVwcm9jZXNzVHlwZSxcclxuICAgIHByb21pc2U6IHByb21pc2VUeXBlLFxyXG4gICAgcmVjb3JkOiByZWNvcmRUeXBlLFxyXG4gICAgc2V0OiBzZXRUeXBlLFxyXG4gICAgc3RyaWN0T2JqZWN0OiBzdHJpY3RPYmplY3RUeXBlLFxyXG4gICAgc3RyaW5nOiBzdHJpbmdUeXBlLFxyXG4gICAgc3ltYm9sOiBzeW1ib2xUeXBlLFxyXG4gICAgdHJhbnNmb3JtZXI6IGVmZmVjdHNUeXBlLFxyXG4gICAgdHVwbGU6IHR1cGxlVHlwZSxcclxuICAgICd1bmRlZmluZWQnOiB1bmRlZmluZWRUeXBlLFxyXG4gICAgdW5pb246IHVuaW9uVHlwZSxcclxuICAgIHVua25vd246IHVua25vd25UeXBlLFxyXG4gICAgJ3ZvaWQnOiB2b2lkVHlwZSxcclxuICAgIE5FVkVSOiBORVZFUixcclxuICAgIFpvZElzc3VlQ29kZTogWm9kSXNzdWVDb2RlLFxyXG4gICAgcXVvdGVsZXNzSnNvbjogcXVvdGVsZXNzSnNvbixcclxuICAgIFpvZEVycm9yOiBab2RFcnJvclxyXG59KTtcclxuXHJcbmV4cG9ydCB7IEJSQU5ELCBESVJUWSwgRU1QVFlfUEFUSCwgSU5WQUxJRCwgTkVWRVIsIE9LLCBQYXJzZVN0YXR1cywgWm9kVHlwZSBhcyBTY2hlbWEsIFpvZEFueSwgWm9kQXJyYXksIFpvZEJpZ0ludCwgWm9kQm9vbGVhbiwgWm9kQnJhbmRlZCwgWm9kQ2F0Y2gsIFpvZERhdGUsIFpvZERlZmF1bHQsIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiwgWm9kRWZmZWN0cywgWm9kRW51bSwgWm9kRXJyb3IsIFpvZEZpcnN0UGFydHlUeXBlS2luZCwgWm9kRnVuY3Rpb24sIFpvZEludGVyc2VjdGlvbiwgWm9kSXNzdWVDb2RlLCBab2RMYXp5LCBab2RMaXRlcmFsLCBab2RNYXAsIFpvZE5hTiwgWm9kTmF0aXZlRW51bSwgWm9kTmV2ZXIsIFpvZE51bGwsIFpvZE51bGxhYmxlLCBab2ROdW1iZXIsIFpvZE9iamVjdCwgWm9kT3B0aW9uYWwsIFpvZFBhcnNlZFR5cGUsIFpvZFBpcGVsaW5lLCBab2RQcm9taXNlLCBab2RSZWFkb25seSwgWm9kUmVjb3JkLCBab2RUeXBlIGFzIFpvZFNjaGVtYSwgWm9kU2V0LCBab2RTdHJpbmcsIFpvZFN5bWJvbCwgWm9kRWZmZWN0cyBhcyBab2RUcmFuc2Zvcm1lciwgWm9kVHVwbGUsIFpvZFR5cGUsIFpvZFVuZGVmaW5lZCwgWm9kVW5pb24sIFpvZFVua25vd24sIFpvZFZvaWQsIGFkZElzc3VlVG9Db250ZXh0LCBhbnlUeXBlIGFzIGFueSwgYXJyYXlUeXBlIGFzIGFycmF5LCBiaWdJbnRUeXBlIGFzIGJpZ2ludCwgYm9vbGVhblR5cGUgYXMgYm9vbGVhbiwgY29lcmNlLCBjdXN0b20sIGRhdGVUeXBlIGFzIGRhdGUsIHogYXMgZGVmYXVsdCwgZXJyb3JNYXAgYXMgZGVmYXVsdEVycm9yTWFwLCBkaXNjcmltaW5hdGVkVW5pb25UeXBlIGFzIGRpc2NyaW1pbmF0ZWRVbmlvbiwgZWZmZWN0c1R5cGUgYXMgZWZmZWN0LCBlbnVtVHlwZSBhcyBlbnVtLCBmdW5jdGlvblR5cGUgYXMgZnVuY3Rpb24sIGdldEVycm9yTWFwLCBnZXRQYXJzZWRUeXBlLCBpbnN0YW5jZU9mVHlwZSBhcyBpbnN0YW5jZW9mLCBpbnRlcnNlY3Rpb25UeXBlIGFzIGludGVyc2VjdGlvbiwgaXNBYm9ydGVkLCBpc0FzeW5jLCBpc0RpcnR5LCBpc1ZhbGlkLCBsYXRlLCBsYXp5VHlwZSBhcyBsYXp5LCBsaXRlcmFsVHlwZSBhcyBsaXRlcmFsLCBtYWtlSXNzdWUsIG1hcFR5cGUgYXMgbWFwLCBuYW5UeXBlIGFzIG5hbiwgbmF0aXZlRW51bVR5cGUgYXMgbmF0aXZlRW51bSwgbmV2ZXJUeXBlIGFzIG5ldmVyLCBudWxsVHlwZSBhcyBudWxsLCBudWxsYWJsZVR5cGUgYXMgbnVsbGFibGUsIG51bWJlclR5cGUgYXMgbnVtYmVyLCBvYmplY3RUeXBlIGFzIG9iamVjdCwgb2JqZWN0VXRpbCwgb2Jvb2xlYW4sIG9udW1iZXIsIG9wdGlvbmFsVHlwZSBhcyBvcHRpb25hbCwgb3N0cmluZywgcGlwZWxpbmVUeXBlIGFzIHBpcGVsaW5lLCBwcmVwcm9jZXNzVHlwZSBhcyBwcmVwcm9jZXNzLCBwcm9taXNlVHlwZSBhcyBwcm9taXNlLCBxdW90ZWxlc3NKc29uLCByZWNvcmRUeXBlIGFzIHJlY29yZCwgc2V0VHlwZSBhcyBzZXQsIHNldEVycm9yTWFwLCBzdHJpY3RPYmplY3RUeXBlIGFzIHN0cmljdE9iamVjdCwgc3RyaW5nVHlwZSBhcyBzdHJpbmcsIHN5bWJvbFR5cGUgYXMgc3ltYm9sLCBlZmZlY3RzVHlwZSBhcyB0cmFuc2Zvcm1lciwgdHVwbGVUeXBlIGFzIHR1cGxlLCB1bmRlZmluZWRUeXBlIGFzIHVuZGVmaW5lZCwgdW5pb25UeXBlIGFzIHVuaW9uLCB1bmtub3duVHlwZSBhcyB1bmtub3duLCB1dGlsLCB2b2lkVHlwZSBhcyB2b2lkLCB6IH07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/zod/lib/index.mjs\n");

/***/ })

};
;